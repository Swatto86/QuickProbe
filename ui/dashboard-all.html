<!DOCTYPE html>
<html lang="en" data-theme="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuickProbe</title>
    <!-- Apply theme before any render to prevent FOUC -->
    <script>
        (function () {
            const root = document.documentElement;
            root.classList.add('qp-preload');
            const reveal = () => root.classList.remove('qp-preload');
            window.__qpRevealSettings = reveal;
            window.__qpPreloadTimer = setTimeout(reveal, 100);

            // Apply theme immediately from localStorage (before ThemeModule loads)
            try {
                const settingsStr = localStorage.getItem('quickprobe_settings');
                if (settingsStr) {
                    const settings = JSON.parse(settingsStr);
                    const themeSetting = settings.theme || 'system';

                    // Simple inline resolution - ThemeModule will correct if needed
                    let resolvedTheme = themeSetting;
                    if (themeSetting === 'system') {
                        resolvedTheme = window.matchMedia?.('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
                    }

                    root.setAttribute('data-theme', resolvedTheme);
                } else {
                    root.setAttribute('data-theme', 'dark');
                }
            } catch (e) {
                console.warn('Failed to apply initial theme:', e);
                root.setAttribute('data-theme', 'dark');
            }
        })();
    </script>
    <style>
        .qp-preload body {
            opacity: 0;
            pointer-events: none;
        }
    </style>
    <!-- Tailwind CSS + DaisyUI (locally built) -->
    <link href="styles.css" rel="stylesheet">
    <!-- Dashboard minimal functional CSS (animations, behaviors, grids) -->
    <link href="dashboard-minimal.css" rel="stylesheet">
    <link rel="icon" href="data:,">
    <!-- Unified theme module for cross-window sync -->
    <script src="theme.js"></script>
    <style>
        /* Search highlighting - functional style */
        .highlight {
            background: hsl(var(--p) / 0.15);
            color: hsl(var(--p));
            border-radius: 4px;
            padding: 0 2px;
        }
    </style>
</head>

<body class="bg-base-100">
    <div class="container mx-auto p-4 max-w-7xl">
        <!-- Header -->
        <header class="card bg-base-200 shadow-xl mb-4">
            <div class="card-body">
                <div class="flex justify-between items-center flex-wrap gap-4">
                    <div class="flex items-start gap-4 flex-wrap">
                        <div class="flex flex-col gap-1">
                            <h1 class="text-3xl font-bold text-primary">QuickProbe</h1>
                        </div>
                        <div class="join" role="group" aria-label="Switch dashboard view">
                            <button class="join-item btn btn-sm view-btn" data-view="cards" type="button">Cards</button>
                            <button class="join-item btn btn-sm view-btn" data-view="groups"
                                type="button">Groups</button>
                        </div>
                        <button id="reorder-btn" class="btn btn-sm btn-outline reorder-btn" type="button"
                            title="Toggle compact reorder mode">
                            ‚ÜïÔ∏è Reorder
                        </button>
                    </div>
                    <div class="flex gap-2 flex-wrap">
                        <button id="edit-hosts-btn" class="btn btn-accent gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                            </svg>
                            Edit Hosts
                        </button>
                        <button id="refresh-visible-btn" class="btn btn-primary gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                            </svg>
                            Refresh Visible
                        </button>
                        <button id="back-to-login-btn" class="btn btn-ghost gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                            </svg>
                            Back to Login
                        </button>
                    </div>
                </div>
            </div>
        </header>

        <!-- Search -->
        <section class="card bg-base-200 shadow-lg mb-4">
            <div class="card-body p-4">
                <div class="flex gap-2 items-center flex-wrap">
                    <div class="flex-1 min-w-[200px]">
                        <input id="server-search" type="text" placeholder="Search servers by name or notes..."
                            class="input input-bordered w-full" autocomplete="off" spellcheck="false">
                    </div>
                    <button id="clear-search-btn" class="btn btn-ghost" type="button">Clear</button>
                </div>
                <div id="search-meta" class="text-sm text-base-content/60 mt-2">Showing all servers</div>
            </div>
        </section>

        <!-- Loading Indicator -->
        <div id="loading" class="hidden">
            <div class="flex flex-col items-center justify-center p-10">
                <span class="loading loading-spinner loading-lg text-primary"></span>
                <p class="mt-4 text-center">Refreshing...</p>
            </div>
        </div>

        <div id="load-error-state" class="hidden" role="status">
            <div class="alert alert-error">
                <div>
                    <h3 class="font-bold">Unable to load hosts.</h3>
                    <p id="load-error-text" class="text-sm">Please retry or edit hosts.</p>
                </div>
                <div class="flex gap-2">
                    <button id="load-retry-btn" class="btn btn-sm btn-primary gap-2" type="button">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24"
                            stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                        </svg>
                        Retry
                    </button>
                    <button id="load-edit-hosts-btn" class="btn btn-sm btn-accent gap-2" type="button">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24"
                            stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                        </svg>
                        Edit Hosts
                    </button>
                </div>
            </div>
        </div>

        <div id="empty-state" class="hidden">
            <div class="hero min-h-[300px] bg-base-200 rounded-lg">
                <div class="hero-content text-center">
                    <div class="max-w-md">
                        <h1 class="text-2xl font-bold">No hosts configured yet.</h1>
                        <p class="py-4">Add hosts to get started or import a backup.</p>
                        <button id="empty-edit-hosts-btn" class="btn btn-accent gap-2" type="button">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                            </svg>
                            Edit Hosts
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Notifications -->
        <div id="notification-stack" class="toast toast-top toast-end"></div>

        <!-- Summary Stats -->
        <div id="summary-stats" class="hidden grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4 mb-6">
            <div class="stat bg-base-200 rounded-lg shadow cursor-pointer hover:shadow-lg transition-shadow"
                data-filter="all" role="button" tabindex="0">
                <div class="stat-title">Total Servers</div>
                <div class="stat-value text-2xl" id="stat-total">0</div>
            </div>
            <div class="stat bg-base-200 rounded-lg shadow cursor-pointer hover:shadow-lg transition-shadow"
                data-filter="online" role="button" tabindex="0">
                <div class="stat-title">Online</div>
                <div class="stat-value text-2xl text-success" id="stat-online">0</div>
            </div>
            <div class="stat bg-base-200 rounded-lg shadow cursor-pointer hover:shadow-lg transition-shadow"
                data-filter="offline" role="button" tabindex="0">
                <div class="stat-title">Offline</div>
                <div class="stat-value text-2xl text-error" id="stat-offline">0</div>
            </div>
            <div class="stat bg-base-200 rounded-lg shadow cursor-pointer hover:shadow-lg transition-shadow"
                data-filter="diskWarnings" role="button" tabindex="0">
                <div class="stat-title">Disk Warnings</div>
                <div class="stat-value text-2xl text-warning" id="stat-disk-warnings">0</div>
            </div>
            <div class="stat bg-base-200 rounded-lg shadow cursor-pointer hover:shadow-lg transition-shadow"
                data-filter="serviceIssues" role="button" tabindex="0">
                <div class="stat-title">Service Issues</div>
                <div class="stat-value text-2xl text-error" id="stat-service-issues">0</div>
            </div>
            <div class="stat bg-base-200 rounded-lg shadow cursor-pointer hover:shadow-lg transition-shadow"
                data-filter="winrmIssues" role="button" tabindex="0">
                <div class="stat-title">WinRM Issues</div>
                <div class="stat-value text-2xl text-warning" id="stat-winrm-issues">0</div>
            </div>
            <div class="stat bg-base-200 rounded-lg shadow cursor-pointer hover:shadow-lg transition-shadow"
                data-filter="highCpu" role="button" tabindex="0">
                <div class="stat-title">High CPU</div>
                <div class="stat-value text-2xl text-warning" id="stat-high-cpu">0</div>
            </div>
            <div class="stat bg-base-200 rounded-lg shadow cursor-pointer hover:shadow-lg transition-shadow"
                data-filter="highMemory" role="button" tabindex="0">
                <div class="stat-title">High RAM</div>
                <div class="stat-value text-2xl text-warning" id="stat-high-ram">0</div>
            </div>
            <div class="stat bg-base-200 rounded-lg shadow cursor-pointer hover:shadow-lg transition-shadow"
                data-filter="rebootNeeded" role="button" tabindex="0">
                <div class="stat-title">Reboot Needed</div>
                <div class="stat-value text-2xl text-info" id="stat-reboot-needed">0</div>
            </div>
        </div>

        <!-- Servers Grid -->
        <div id="servers-grid" class="hidden grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"></div>

        <!-- Host Credential Dialog -->
        <dialog id="rdp-credential-modal" class="modal">
            <div class="modal-box">
                <h3 class="font-bold text-lg" id="rdp-credential-title">Save Host Credentials</h3>
                <p class="py-2 text-sm">Host: <span id="rdp-credential-server" class="font-semibold"></span></p>
                <p class="text-sm text-base-content/70">Stored in Windows Credential Manager; used for probes and RDP.
                </p>
                <form id="rdp-credential-form" autocomplete="off" class="mt-4">
                    <div class="form-control">
                        <label class="label" for="rdp-credential-username">
                            <span class="label-text">Username</span>
                        </label>
                        <input id="rdp-credential-username" name="username" type="text" class="input input-bordered"
                            autocomplete="off" spellcheck="false" required>
                    </div>

                    <div class="form-control mt-4">
                        <label class="label" for="rdp-credential-password">
                            <span class="label-text">Password</span>
                        </label>
                        <input id="rdp-credential-password" name="password" type="password" class="input input-bordered"
                            autocomplete="off" required>
                    </div>

                    <div class="modal-action">
                        <button id="rdp-credential-cancel" type="button" class="btn">Cancel</button>
                        <button id="rdp-credential-save" type="submit" class="btn btn-primary">Save</button>
                    </div>
                </form>
                <form method="dialog">
                    <button id="rdp-credential-close"
                        class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button>
                </form>
            </div>
        </dialog>

        <!-- Edit Notes Dialog -->
        <dialog id="notes-modal" class="modal">
            <div class="modal-box">
                <h3 class="font-bold text-lg" id="notes-modal-title">Edit notes</h3>
                <p class="py-2 text-sm">Server: <span id="notes-modal-server" class="font-semibold"></span></p>
                <form id="notes-modal-form" autocomplete="off" class="mt-4">
                    <div class="form-control">
                        <label class="label" for="notes-modal-text">
                            <span class="label-text">Notes</span>
                        </label>
                        <textarea id="notes-modal-text" name="notes" class="textarea textarea-bordered h-32"
                            spellcheck="false" autocomplete="off"></textarea>
                    </div>
                    <div class="modal-action">
                        <button id="notes-modal-cancel" type="button" class="btn">Cancel</button>
                        <button id="notes-modal-save" type="submit" class="btn btn-primary">Save</button>
                    </div>
                </form>
                <form method="dialog">
                    <button id="notes-modal-close"
                        class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button>
                </form>
            </div>
        </dialog>

        <!-- Edit Host Dialog -->
        <dialog id="edit-host-modal" class="modal">
            <div class="modal-box max-w-lg">
                <h3 class="font-bold text-lg" id="edit-host-modal-title">Edit Host</h3>
                <p class="py-2 text-sm">Server: <span id="edit-host-modal-server" class="font-semibold"></span></p>
                <form id="edit-host-modal-form" autocomplete="off" class="mt-4 space-y-4">
                    <div class="form-control">
                        <label class="label" for="edit-host-notes">
                            <span class="label-text">Notes</span>
                        </label>
                        <input type="text" id="edit-host-notes" name="notes" placeholder="Role or description"
                            class="input input-bordered" autocomplete="off" spellcheck="false" />
                    </div>
                    <div class="form-control">
                        <label class="label" for="edit-host-group">
                            <span class="label-text">Group</span>
                        </label>
                        <select id="edit-host-group" name="group" class="select select-bordered w-full">
                            <option value="">(No Group)</option>
                        </select>
                        <label class="label">
                            <span class="label-text-alt text-base-content/60">Optional grouping label for dashboard
                                views.</span>
                        </label>
                    </div>
                    <div class="form-control">
                        <label class="label" for="edit-host-os">
                            <span class="label-text">Host OS</span>
                        </label>
                        <select id="edit-host-os" name="os" class="select select-bordered w-full">
                            <option value="Windows">Windows</option>
                            <option value="Linux">Linux</option>
                        </select>
                        <label class="label">
                            <span class="label-text-alt text-base-content/60">Used for picking probe/connect
                                path.</span>
                        </label>
                    </div>
                    <div class="form-control">
                        <label class="label" for="edit-host-services">
                            <span class="label-text">Critical Services (semicolon separated)</span>
                        </label>
                        <div class="flex gap-2 items-center mb-2">
                            <button type="button" id="edit-host-browse-services" class="btn btn-sm btn-outline gap-1"
                                disabled>
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24"
                                    stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                                </svg>
                                Browse Services
                            </button>
                        </div>
                        <textarea id="edit-host-services" name="services" rows="3"
                            placeholder="WinRM; Print Spooler; Windows Update" class="textarea textarea-bordered"
                            autocomplete="off" spellcheck="false"></textarea>
                        <label class="label">
                            <span class="label-text-alt text-base-content/60">These services will be monitored for this
                                host.</span>
                        </label>
                    </div>
                    <div class="modal-action justify-between">
                        <button id="edit-host-modal-delete" type="button" class="btn btn-error gap-1">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                            </svg>
                            Delete
                        </button>
                        <div class="flex gap-2">
                            <button id="edit-host-modal-cancel" type="button" class="btn">Cancel</button>
                            <button id="edit-host-modal-save" type="submit" class="btn btn-primary">Save</button>
                        </div>
                    </div>
                </form>
                <form method="dialog">
                    <button id="edit-host-modal-close"
                        class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button>
                </form>
            </div>
        </dialog>

        <!-- Service Browser Modal -->
        <dialog id="edit-service-browser-modal" class="modal">
            <div class="modal-box max-w-4xl max-h-[80vh] flex flex-col">
                <h3 class="font-bold text-lg mb-2">Browse Services on <span id="edit-service-browser-host"
                        class="text-primary"></span></h3>
                <p class="text-sm text-base-content/70 mb-3">Select services to monitor from the list below. Use the
                    search box to filter and click column headers to sort.</p>

                <!-- Error/Status message -->
                <div id="edit-service-browser-message" class="alert hidden mb-3"></div>

                <!-- Loading indicator -->
                <div id="edit-service-browser-loading" class="flex flex-col items-center justify-center py-8 hidden">
                    <span class="loading loading-spinner loading-lg text-primary"></span>
                    <p class="mt-3 text-base-content/70">Connecting and fetching services...</p>
                </div>

                <!-- Service list container (shown after loading) -->
                <div id="edit-service-browser-content" class="flex flex-col flex-1 min-h-0 hidden">
                    <!-- Controls row -->
                    <div class="flex flex-wrap gap-2 items-center mb-3">
                        <div class="relative flex-1 min-w-[200px]">
                            <input id="edit-service-browser-search" type="text" placeholder="Filter services..."
                                class="input input-bordered input-sm w-full pr-8" autocomplete="off" spellcheck="false">
                            <span
                                class="absolute right-2 top-1/2 -translate-y-1/2 text-base-content/50 text-sm">üîç</span>
                        </div>
                        <select id="edit-service-browser-status-filter" class="select select-bordered select-sm">
                            <option value="">All statuses</option>
                            <option value="Running">Running</option>
                            <option value="Stopped">Stopped</option>
                        </select>
                        <div class="text-sm text-base-content/60">
                            <span id="edit-service-browser-count">0</span> services
                            (<span id="edit-service-browser-selected-count">0</span> selected)
                        </div>
                    </div>

                    <!-- Select all / Deselect all buttons -->
                    <div class="flex gap-2 mb-2">
                        <button type="button" id="edit-service-browser-select-visible"
                            class="btn btn-xs btn-ghost">Select visible</button>
                        <button type="button" id="edit-service-browser-deselect-all"
                            class="btn btn-xs btn-ghost">Deselect all</button>
                    </div>

                    <!-- Table container with scroll -->
                    <div class="overflow-auto flex-1 border border-base-300 rounded-lg">
                        <table class="table table-sm table-pin-rows">
                            <thead>
                                <tr class="bg-base-200">
                                    <th class="w-10"></th>
                                    <th class="cursor-pointer hover:bg-base-300" data-sort="name">
                                        Name <span class="sort-indicator"></span>
                                    </th>
                                    <th class="cursor-pointer hover:bg-base-300" data-sort="display_name">
                                        Display Name <span class="sort-indicator"></span>
                                    </th>
                                    <th class="cursor-pointer hover:bg-base-300 w-24" data-sort="status">
                                        Status <span class="sort-indicator"></span>
                                    </th>
                                    <th class="cursor-pointer hover:bg-base-300 w-28" data-sort="startup_type">
                                        Startup <span class="sort-indicator"></span>
                                    </th>
                                    <th class="cursor-pointer hover:bg-base-300" data-sort="service_account">
                                        Service User <span class="sort-indicator"></span>
                                    </th>
                                </tr>
                            </thead>
                            <tbody id="edit-service-browser-tbody"></tbody>
                        </table>
                    </div>
                </div>

                <!-- Modal actions -->
                <div class="modal-action mt-3">
                    <button type="button" id="edit-service-browser-add" class="btn btn-primary" disabled>Add
                        Selected</button>
                    <button type="button" id="edit-service-browser-cancel" class="btn">Cancel</button>
                </div>
            </div>
            <form method="dialog"><button id="edit-service-browser-close"
                    class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">√ó</button></form>
        </dialog>

        <!-- Group Rename Dialog -->
        <dialog id="group-rename-modal" class="modal">
            <div class="modal-box">
                <h3 class="font-bold text-lg" id="group-rename-title">Rename group</h3>
                <p class="py-2 text-sm">Current: <span id="group-rename-current" class="font-semibold"></span></p>
                <form id="group-rename-form" autocomplete="off" class="mt-4">
                    <div class="form-control">
                        <label class="label" for="group-rename-input">
                            <span class="label-text">New name</span>
                        </label>
                        <input id="group-rename-input" name="group" type="text" class="input input-bordered"
                            autocomplete="off" spellcheck="false" required>
                    </div>
                    <div class="modal-action">
                        <button id="group-rename-cancel" type="button" class="btn">Cancel</button>
                        <button id="group-rename-save" type="submit" class="btn btn-primary">Save</button>
                    </div>
                </form>
                <button type="button" id="group-rename-close"
                    class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button>
            </div>
            <form method="dialog" class="modal-backdrop bg-black/30">
                <button type="submit">close</button>
            </form>
        </dialog>

        <!-- Error Dialog -->
        <dialog id="error-modal" class="modal">
            <div class="modal-box">
                <h3 class="font-bold text-lg text-error" id="error-title">Error</h3>
                <p class="py-2 text-sm">Server: <span id="error-server" class="font-semibold"></span></p>
                <div id="error-message" class="mockup-code bg-base-300 text-sm mt-4 max-h-64 overflow-y-auto">
                    <pre><code>No details available.</code></pre>
                </div>
                <div class="modal-action">
                    <button id="error-dismiss" type="button" class="btn">Close</button>
                </div>
                <form method="dialog">
                    <button id="error-close" class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button>
                </form>
            </div>
        </dialog>

        <!-- Details Dialog -->
        <dialog id="details-modal" class="modal">
            <div class="modal-box w-11/12 max-w-4xl max-h-[90vh]">
                <h3 class="font-bold text-lg" id="details-title">Details</h3>
                <div id="details-content" class="py-4 overflow-y-auto"></div>
                <div class="modal-action">
                    <button id="details-dismiss" type="button" class="btn">Close</button>
                </div>
                <form method="dialog">
                    <button id="details-close" class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button>
                </form>
            </div>
        </dialog>

        <!-- Host Preview Modal -->
        <dialog id="host-preview-modal" class="modal">
            <div class="modal-box w-11/12 max-w-4xl max-h-[90vh]">
                <h3 class="font-bold text-lg" id="host-preview-title">Host details</h3>
                <div id="host-preview-body" class="py-4 overflow-y-auto"></div>
                <form method="dialog">
                    <button id="host-preview-close"
                        class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button>
                </form>
            </div>
        </dialog>

        <!-- Generic Confirmation Modal -->
        <dialog id="confirm-modal" class="modal modal-bottom sm:modal-middle">
            <div class="modal-box">
                <h3 id="confirm-modal-title" class="font-bold text-lg">Confirm</h3>
                <p id="confirm-modal-message" class="py-4 text-base-content/80 whitespace-pre-wrap"></p>
                <div class="modal-action">
                    <button type="button" id="confirm-modal-cancel" class="btn">Cancel</button>
                    <button type="button" id="confirm-modal-ok" class="btn btn-primary">OK</button>
                </div>
            </div>
            <div class="modal-backdrop bg-black/50" id="confirm-modal-backdrop"></div>
        </dialog>

        <!-- Manage Services Modal -->
        <dialog id="manage-services-modal" class="modal">
            <div class="modal-box qp-manage-modal relative">
                <form method="dialog">
                    <button id="manage-services-close"
                        class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button>
                </form>
                <h3 class="font-bold text-lg mb-2">Manage Services on <span id="manage-services-host"
                        class="text-primary"></span></h3>
                <p class="text-sm text-base-content/70 mb-3">View and control services on this server. Use the action
                    buttons to start, stop, or restart services.</p>

                <!-- Error/Status message -->
                <div id="manage-services-message" class="alert hidden mb-3"></div>

                <!-- Loading indicator -->
                <div id="manage-services-loading" class="flex flex-col items-center justify-center py-8 hidden">
                    <span class="loading loading-spinner loading-lg text-primary"></span>
                    <p class="mt-3 text-base-content/70">Connecting and fetching services...</p>
                </div>

                <!-- Service list container (shown after loading) -->
                <div id="manage-services-content" class="flex flex-col flex-1 min-h-0 hidden">
                    <!-- Controls row -->
                    <div class="flex flex-wrap gap-2 items-center mb-3">
                        <div class="relative flex-1 min-w-[200px]">
                            <input id="manage-services-search" type="text" placeholder="Filter services..."
                                class="input input-bordered input-sm w-full pr-8" autocomplete="off" spellcheck="false">
                            <span
                                class="absolute right-2 top-1/2 -translate-y-1/2 text-base-content/50 text-sm">üîç</span>
                        </div>
                        <select id="manage-services-status-filter" class="select select-bordered select-sm">
                            <option value="">All statuses</option>
                            <option value="Running">Running</option>
                            <option value="Stopped">Stopped</option>
                        </select>
                        <select id="manage-services-monitored-filter" class="select select-bordered select-sm">
                            <option value="">All services</option>
                            <option value="monitored">Monitored only</option>
                        </select>
                        <button type="button" id="manage-services-refresh" class="btn btn-sm btn-outline gap-1">
                            üîÑ Refresh
                        </button>
                        <div class="text-sm text-base-content/60">
                            <span id="manage-services-count">0</span> services
                        </div>
                    </div>

                    <!-- Table container with scroll -->
                    <div class="overflow-auto flex-1 border border-base-300 rounded-lg">
                        <table class="table table-sm table-pin-rows">
                            <thead>
                                <tr class="bg-base-200">
                                    <th class="cursor-pointer hover:bg-base-300" data-sort="name">
                                        Name <span class="sort-indicator"></span>
                                    </th>
                                    <th class="cursor-pointer hover:bg-base-300" data-sort="display_name">
                                        Display Name <span class="sort-indicator"></span>
                                    </th>
                                    <th class="cursor-pointer hover:bg-base-300 w-24" data-sort="status">
                                        Status <span class="sort-indicator"></span>
                                    </th>
                                    <th class="cursor-pointer hover:bg-base-300 w-28" data-sort="startup_type">
                                        Startup <span class="sort-indicator"></span>
                                    </th>
                                    <th class="w-40 text-center">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="manage-services-tbody"></tbody>
                        </table>
                    </div>
                </div>
                <form method="dialog">
                    <button id="manage-services-close"
                        class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button>
                </form>
            </div>
        </dialog>

        <!-- Manage Processes Modal -->
        <dialog id="manage-processes-modal" class="modal">
            <div class="modal-box qp-manage-modal relative">
                <form method="dialog">
                    <button id="manage-processes-close"
                        class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button>
                </form>
                <h3 class="font-bold text-lg mb-2">Manage Processes on <span id="manage-processes-host"
                        class="text-primary"></span></h3>
                <p class="text-sm text-base-content/70 mb-3">View running processes on this server. Sort by columns to
                    find high resource usage. Use Kill to terminate processes.</p>

                <!-- Error/Status message -->
                <div id="manage-processes-message" class="alert hidden mb-3"></div>

                <!-- Loading indicator -->
                <div id="manage-processes-loading" class="flex flex-col items-center justify-center py-8 hidden">
                    <span class="loading loading-spinner loading-lg text-primary"></span>
                    <p class="mt-3 text-base-content/70">Connecting and fetching processes...</p>
                </div>

                <!-- Process list container (shown after loading) -->
                <div id="manage-processes-content" class="flex flex-col flex-1 min-h-0 hidden">
                    <!-- Controls row -->
                    <div class="flex flex-wrap gap-2 items-center mb-3">
                        <div class="relative flex-1 min-w-[200px]">
                            <input id="manage-processes-search" type="text" placeholder="Filter processes..."
                                class="input input-bordered input-sm w-full pr-8" autocomplete="off" spellcheck="false">
                            <span
                                class="absolute right-2 top-1/2 -translate-y-1/2 text-base-content/50 text-sm">üîç</span>
                        </div>
                        <button type="button" id="manage-processes-refresh" class="btn btn-sm btn-outline gap-1">
                            üîÑ Refresh
                        </button>
                        <div class="text-sm text-base-content/60">
                            <span id="manage-processes-count">0</span> processes
                        </div>
                    </div>

                    <!-- Table container with scroll -->
                    <div class="overflow-auto flex-1 border border-base-300 rounded-lg">
                        <table class="table table-sm table-pin-rows">
                            <thead>
                                <tr class="bg-base-200">
                                    <th class="cursor-pointer hover:bg-base-300" data-sort="name">
                                        Name <span class="sort-indicator"></span>
                                    </th>
                                    <th class="cursor-pointer hover:bg-base-300 w-20" data-sort="pid">
                                        PID <span class="sort-indicator"></span>
                                    </th>
                                    <th class="cursor-pointer hover:bg-base-300 w-24" data-sort="cpu">
                                        CPU % <span class="sort-indicator"></span>
                                    </th>
                                    <th class="cursor-pointer hover:bg-base-300 w-28" data-sort="memory">
                                        Memory (MB) <span class="sort-indicator"></span>
                                    </th>
                                    <th class="cursor-pointer hover:bg-base-300" data-sort="user">
                                        User <span class="sort-indicator"></span>
                                    </th>
                                    <th class="w-24 text-center">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="manage-processes-tbody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </dialog>

        <!-- Kill Process Confirmation Modal -->
        <dialog id="kill-process-confirm-modal" class="modal">
            <div class="modal-box">
                <h3 class="font-bold text-lg text-error">‚ö†Ô∏è Confirm Kill Process</h3>
                <p class="py-4">Are you sure you want to kill this process?</p>
                <div class="bg-base-200 p-3 rounded-lg mb-4">
                    <p><strong>Process:</strong> <span id="kill-process-name" class="text-primary"></span></p>
                    <p><strong>PID:</strong> <span id="kill-process-pid" class="text-primary"></span></p>
                    <p><strong>Host:</strong> <span id="kill-process-host" class="text-primary"></span></p>
                </div>
                <p class="text-sm text-warning">‚ö†Ô∏è Warning: Killing system processes may cause instability.</p>
                <div class="modal-action">
                    <form method="dialog">
                        <button class="btn btn-ghost">Cancel</button>
                    </form>
                    <button id="kill-process-confirm-btn" class="btn btn-error">Kill Process</button>
                </div>
            </div>
            <form method="dialog" class="modal-backdrop">
                <button>close</button>
            </form>
        </dialog>

        <!-- Remote PowerShell Modal -->
        <dialog id="remote-powershell-modal" class="modal">
            <div class="modal-box w-11/12 max-w-4xl h-[80vh] flex flex-col relative">
                <form method="dialog">
                    <button id="remote-powershell-close"
                        class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button>
                </form>
                <h3 class="font-bold text-lg mb-2">üíª Remote PowerShell on <span id="remote-powershell-host"
                        class="text-primary"></span></h3>
                <p class="text-sm text-base-content/70 mb-3">Execute PowerShell commands on this remote Windows server.
                    Use with caution.</p>

                <!-- Output console area -->
                <div id="remote-powershell-output"
                    class="remote-powershell-output flex-1 bg-base-300 rounded-lg p-3 font-mono text-sm overflow-auto mb-3 whitespace-pre-wrap border border-base-content/20">
                    <span class="text-base-content/50">Ready. Enter a command below and press Enter or click
                        Execute.</span>
                </div>

                <!-- Command input area -->
                <div class="flex gap-2">
                    <div class="flex-1 relative">
                        <span
                            class="absolute left-3 top-1/2 -translate-y-1/2 text-primary font-bold font-mono">PS&gt;</span>
                        <input type="text" id="remote-powershell-input"
                            class="remote-powershell-input input input-bordered w-full font-mono" placeholder=""
                            autocomplete="off" spellcheck="false">
                    </div>
                    <button type="button" id="remote-powershell-execute" class="btn btn-primary gap-1">
                        ‚ñ∂Ô∏è Execute
                    </button>
                    <button type="button" id="remote-powershell-upload" class="btn btn-secondary gap-1">
                        üìÅ Upload Script
                    </button>
                    <button type="button" id="remote-powershell-clear" class="btn btn-outline gap-1">
                        üóëÔ∏è Clear
                    </button>
                </div>

                <!-- Script upload preview area (hidden by default) -->
                <div id="remote-powershell-script-preview" class="hidden mt-3">
                    <div class="flex items-center justify-between mb-2">
                        <div class="flex items-center gap-2">
                            <span class="text-sm font-semibold">üìÑ Script:</span>
                            <span id="remote-powershell-script-name" class="text-sm text-primary"></span>
                            <span id="remote-powershell-script-size" class="text-sm text-base-content/60"></span>
                        </div>
                        <div class="flex gap-2">
                            <button type="button" id="remote-powershell-run-script"
                                class="btn btn-primary btn-sm gap-1">
                                ‚ñ∂Ô∏è Run Script
                            </button>
                            <button type="button" id="remote-powershell-cancel-script"
                                class="btn btn-ghost btn-sm gap-1">
                                ‚úï Cancel
                            </button>
                        </div>
                    </div>
                    <div id="remote-powershell-script-content"
                        class="bg-base-200 rounded-lg p-3 font-mono text-xs max-h-48 overflow-auto border border-base-content/10 whitespace-pre-wrap">
                    </div>
                </div>

                <!-- Status bar -->
                <div class="flex justify-between items-center mt-2 text-sm text-base-content/60">
                    <div id="remote-powershell-status">Ready</div>
                    <div class="flex gap-2">
                        <span id="remote-powershell-history-info" class="hidden">Use ‚Üë‚Üì for history</span>
                    </div>
                </div>
            </div>
            <form method="dialog" class="modal-backdrop">
                <button>close</button>
            </form>
        </dialog>

        <!-- Remote SSH Modal (for Linux hosts) -->
        <dialog id="remote-ssh-modal" class="modal">
            <div class="modal-box w-11/12 max-w-4xl h-[80vh] flex flex-col relative">
                <form method="dialog">
                    <button id="remote-ssh-close"
                        class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">‚úï</button>
                </form>
                <h3 class="font-bold text-lg mb-2">üêß Remote SSH on <span id="remote-ssh-host"
                        class="text-primary"></span></h3>
                <p class="text-sm text-base-content/70 mb-3">Execute shell commands on this remote Linux server via SSH.
                    Use with caution.</p>

                <!-- Output console area -->
                <div id="remote-ssh-output"
                    class="remote-powershell-output flex-1 bg-base-300 rounded-lg p-3 font-mono text-sm overflow-auto mb-3 whitespace-pre-wrap border border-base-content/20">
                    <span class="text-base-content/50">Ready. Enter a command below and press Enter or click
                        Execute.</span>
                </div>

                <!-- Command input area -->
                <div class="flex gap-2">
                    <div class="flex-1 relative">
                        <span class="absolute left-3 top-1/2 -translate-y-1/2 text-success font-bold font-mono">$</span>
                        <input type="text" id="remote-ssh-input"
                            class="remote-powershell-input input input-bordered w-full font-mono pl-8" placeholder=""
                            autocomplete="off" spellcheck="false">
                    </div>
                    <button type="button" id="remote-ssh-execute" class="btn btn-primary gap-1">
                        ‚ñ∂Ô∏è Execute
                    </button>
                    <button type="button" id="remote-ssh-clear" class="btn btn-outline gap-1">
                        üóëÔ∏è Clear
                    </button>
                </div>

                <!-- Status bar with PTY toggle -->
                <div class="flex justify-between items-center mt-2 text-sm text-base-content/60">
                    <div id="remote-ssh-status">Ready</div>
                    <div class="flex gap-4 items-center">
                        <label class="flex items-center gap-2 cursor-pointer"
                            title="Enable for curses/ncurses apps like top, htop, vim, nano">
                            <span class="text-xs">üñ•Ô∏è PTY Mode</span>
                            <input type="checkbox" id="remote-ssh-pty-toggle" class="toggle toggle-sm toggle-primary">
                        </label>
                        <span id="remote-ssh-history-info" class="hidden">Use ‚Üë‚Üì for history</span>
                    </div>
                </div>
            </div>
            <form method="dialog" class="modal-backdrop">
                <button>close</button>
            </form>
        </dialog>

    </div>

    <script src="dashboard-utils.js"></script>
    <script>
        let serversData = [];
        let hostsSignature = null;
        let searchTerm = '';
        let activeFilter = null;
        let probeTimeoutMs = 90000;
        let quickProbeTimeoutMs = 30000;
        let persistedHealthMap = new Map(); // Stores health snapshots from SQLite
        const CACHE_KEY = 'qp_dashboard_cache_v3';
        const HOSTS_CHANGED_KEY = 'qp_hosts_changed';
        const HOST_VIEW_KEY = 'qp_host_view_mode';
        let dashboardCache = null;
        const settingsDefaultBundle = () => ({
            qp_settings: defaultSettings(),
            qp_server_order: [],
            qp_group_order: [],
            qp_focused_group: null,
            qp_host_view_mode: 'cards',
            qp_hosts_changed: null,
        });
        let settingsBundle = settingsDefaultBundle();
        const MAX_CACHE_AGE_MS = 5 * 60 * 1000; // 5 minutes
        const MAX_CONCURRENT_PROBES = 10;
        const HEARTBEAT_INTERVAL_MS = 20000;
        const HEARTBEAT_TIMEOUT_MS = 60000; // fallback; actual timeout comes from settings
        const HEARTBEAT_JITTER_MS = 500;
        const HEARTBEAT_STALE_MS = 180000;
        const QUICK_PROBE_MIN_INTERVAL_MS = 30000;

        function disableAutocomplete() {
            const fields = document.querySelectorAll('input, textarea');
            fields.forEach((el) => {
                el.setAttribute('autocomplete', 'off');
                if (el.getAttribute('type') === 'text') {
                    el.setAttribute('spellcheck', 'false');
                }
            });
        }
        const SERVER_ORDER_KEY = 'qp_server_order';
        const SETTINGS_KEY = 'quickprobe_settings';
        const Utils = window.DashboardUtils;
        let openHostCredentialDialog = null;
        let openNotesDialog = null;
        let openGroupRenameDialog = null;
        let openErrorDialog = null;
        let openHostPreview = null;
        let hostViewMode = 'cards';
        let reorderMode = false;
        let focusedGroup = null;
        let settings = defaultSettings();
        let themeToggleBtn = null;
        let heartbeatTimer = null;
        let heartbeatInFlight = false;
        let heartbeatHosts = [];
        let notesDirty = false;
        let noteSaveBusy = false;
        let groupRenameBusy = false;
        let openEditHostDialog = null;
        let editHostBusy = false;
        let editHostDirty = false;
        let editHostServerName = null;  // Track which server is being edited

        // Service browser state (for edit host modal)
        let editServiceBrowserData = [];           // All services fetched from remote host
        let editServiceBrowserSelected = new Set(); // Selected service names (lowercased for comparison)
        let editServiceBrowserSortKey = 'name';     // Current sort column
        let editServiceBrowserSortAsc = true;       // Sort direction
        let editServiceBrowserBusy = false;         // Loading state

        const quickProbeMeta = new Map();
        const fullRefreshMeta = new Map();
        const hostStatuses = new Map();

        // Circuit breaker pattern: track consecutive failures and back off probes for failing servers
        const serverHealthState = new Map(); // { consecutiveFailures, lastFailureTime, circuitState, nextProbeTime }
        const CIRCUIT_BREAKER_THRESHOLD = 3; // Open circuit after 3 consecutive failures
        const CIRCUIT_BREAKER_MAX_BACKOFF = 180000; // Max 3 minutes backoff
        let locationMatchers = [];
        let hostsByName = new Map();
        let runtimeModeInfo = null;
        let lastRefreshStatus = null;
        let displayAllServersDebounceTimer = null;

        function defaultSettings() {
            return {
                probeTimeoutSeconds: 90,  // Changed default from 60 to 90 seconds
                quickProbeTimeoutSeconds: 30,
                infoTimeoutMs: 3500,
                warningTimeoutMs: 4500,
                errorTimeoutMs: 0, // 0 = persistent
                locationMappings: [],
                theme: 'system'
            };
        }

        function logDebug(message, obj) {
            try {
                const detail = obj ? `${message} | ${JSON.stringify(obj)}` : message;
                if (window.__TAURI__?.core?.invoke) {
                    window.__TAURI__.core.invoke('log_debug', { message: detail });
                } else {
                    console.debug(detail);
                }
            } catch (err) {
                console.debug('logDebug failed', err, message);
            }
        }

        function setLastRefreshStatus(status, detail) {
            lastRefreshStatus = status;
            const statusEl = document.getElementById('last-refresh-status');
            if (!statusEl) return;

            if (!status) {
                statusEl.textContent = '';
                statusEl.classList.add('hidden');
                return;
            }

            const prefix = status === 'ok'
                ? 'Last refresh: OK'
                : status === 'partial'
                    ? 'Last refresh: Partial (see cards)'
                    : 'Last refresh: Failed';

            statusEl.textContent = detail ? `${prefix} - ${detail}` : prefix;
            statusEl.classList.remove('hidden');
        }

        function revealApp() {
            if (window.__qpPreloadTimer) {
                clearTimeout(window.__qpPreloadTimer);
                window.__qpPreloadTimer = null;
            }
            if (typeof window.__qpRevealSettings === 'function') {
                window.__qpRevealSettings();
            } else {
                document.documentElement.classList.remove('qp-preload');
            }
        }

        function debounce(fn, wait) {
            let t;
            return (...args) => {
                clearTimeout(t);
                t = setTimeout(() => fn(...args), wait);
            };
        }

        // ========== Confirmation Dialog ==========
        let confirmResolve = null;

        function showConfirmDialog(message, options = {}) {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirm-modal');
                const titleEl = document.getElementById('confirm-modal-title');
                const messageEl = document.getElementById('confirm-modal-message');
                const okBtn = document.getElementById('confirm-modal-ok');
                const cancelBtn = document.getElementById('confirm-modal-cancel');
                const backdrop = document.getElementById('confirm-modal-backdrop');

                if (!modal) {
                    resolve(window.confirm(message));
                    return;
                }

                let resolved = false;

                titleEl.textContent = options.title || 'Confirm';
                messageEl.textContent = message;
                okBtn.textContent = options.okText || 'OK';
                okBtn.className = `btn ${options.okClass || 'btn-primary'}`;
                cancelBtn.textContent = options.cancelText || 'Cancel';

                const doResolve = (value) => {
                    if (resolved) return;
                    resolved = true;
                    cleanup();
                    modal.close();
                    resolve(value);
                };

                const handleOk = (e) => { e.preventDefault(); e.stopPropagation(); doResolve(true); };
                const handleCancel = (e) => { e.preventDefault(); e.stopPropagation(); doResolve(false); };
                const handleBackdropClick = (e) => { e.preventDefault(); e.stopPropagation(); doResolve(false); };
                const handleKeydown = (e) => { if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); doResolve(false); } };
                const handleClose = () => { doResolve(false); };

                const cleanup = () => {
                    okBtn.removeEventListener('click', handleOk);
                    cancelBtn.removeEventListener('click', handleCancel);
                    if (backdrop) backdrop.removeEventListener('click', handleBackdropClick);
                    modal.removeEventListener('keydown', handleKeydown);
                    modal.removeEventListener('close', handleClose);
                    confirmResolve = null;
                };

                confirmResolve = doResolve;
                okBtn.addEventListener('click', handleOk);
                cancelBtn.addEventListener('click', handleCancel);
                if (backdrop) backdrop.addEventListener('click', handleBackdropClick);
                modal.addEventListener('keydown', handleKeydown);
                modal.addEventListener('close', handleClose);

                modal.showModal();
                okBtn.focus();
            });
        }
        // ========== End Confirmation Dialog ==========

        function settingsPayload() {
            return {
                qp_settings: settingsBundle.qp_settings || defaultSettings(),
                qp_server_order: settingsBundle.qp_server_order || [],
                qp_group_order: settingsBundle.qp_group_order || [],
                qp_focused_group: settingsBundle.qp_focused_group || null,
                qp_host_view_mode: settingsBundle.qp_host_view_mode || 'cards',
                qp_hosts_changed: settingsBundle.qp_hosts_changed || null
            };
        }

        function readLocalSettingsSnapshot() {
            const snapshot = settingsDefaultBundle();
            try {
                const raw = localStorage.getItem(SETTINGS_KEY);
                if (raw) snapshot.qp_settings = JSON.parse(raw);
            } catch (e) {
                console.warn('Dashboard: failed to read fallback qp_settings', e);
            }
            try {
                const raw = localStorage.getItem(SERVER_ORDER_KEY);
                if (raw) snapshot.qp_server_order = JSON.parse(raw);
            } catch (e) {
                console.warn('Dashboard: failed to read fallback qp_server_order', e);
            }
            try {
                const raw = localStorage.getItem(HOST_VIEW_KEY);
                if (raw) snapshot.qp_host_view_mode = JSON.parse(raw);
            } catch (e) { /* ignore */ }
            try {
                const raw = localStorage.getItem(HOSTS_CHANGED_KEY);
                if (raw) snapshot.qp_hosts_changed = JSON.parse(raw);
            } catch (e) { /* ignore */ }
            return snapshot;
        }

        async function primeSettingsFromBackend() {
            const start = Date.now();
            logDebug('dashboard:init:settings_get_all START');

            const fallbackSnapshot = readLocalSettingsSnapshot();
            settingsBundle = { ...fallbackSnapshot };
            if (!window.__TAURI__?.core?.invoke) {
                console.warn('settings_get_all unavailable; using fallback snapshot');
                logDebug('dashboard:init:settings_get_all fallback (no Tauri)');
                return { usedFallback: true };
            }
            try {
                const { invoke } = window.__TAURI__.core;
                const bundle = await invoke('settings_get_all');
                const elapsed = Date.now() - start;

                settingsBundle = {
                    qp_settings: bundle?.qp_settings || fallbackSnapshot.qp_settings,
                    qp_server_order: bundle?.qp_server_order || fallbackSnapshot.qp_server_order,
                    qp_group_order: bundle?.qp_group_order || fallbackSnapshot.qp_group_order || [],
                    qp_focused_group: bundle?.qp_focused_group ?? fallbackSnapshot.qp_focused_group ?? null,
                    qp_host_view_mode: bundle?.qp_host_view_mode || fallbackSnapshot.qp_host_view_mode,
                    qp_hosts_changed: bundle?.qp_hosts_changed ?? fallbackSnapshot.qp_hosts_changed,
                };

                // Sync backend settings to localStorage so other windows see correct theme
                try {
                    if (settingsBundle.qp_settings) {
                        localStorage.setItem(SETTINGS_KEY, JSON.stringify(settingsBundle.qp_settings));
                    }
                } catch (e) {
                    console.warn('[Dashboard] Failed to sync settings to localStorage:', e);
                }

                const hasMode = !!bundle?.qp_mode;
                const hasApiBase = !!bundle?.qp_remote_api_base;
                logDebug(`dashboard:init:settings_get_all SUCCESS ${elapsed}ms mode=${hasMode} apiBase=${hasApiBase}`);

                return { usedFallback: false };
            } catch (err) {
                console.warn('settings_get_all failed; using fallback snapshot', err);
                return { usedFallback: true };
            }
        }

        async function primeDashboardCache() {
            dashboardCache = null;
            if (!window.__TAURI__?.core?.invoke) {
                try {
                    const raw = localStorage.getItem(CACHE_KEY);
                    dashboardCache = raw ? JSON.parse(raw) : null;
                    const count = dashboardCache?.serversData?.length || 0;
                    logDebug(`primeDashboardCache: fallback localStorage servers=${count}`);
                } catch (_) { /* ignore */ }
                return;
            }
            try {
                const { invoke } = window.__TAURI__.core;
                dashboardCache = await invoke('cache_get_dashboard');
                const count = dashboardCache?.serversData?.length || 0;
                const age = dashboardCache?.cachedAt || 'unknown';
                logDebug(`primeDashboardCache: SUCCESS servers=${count} cachedAt=${age}`, dashboardCache ? { hasData: true, count } : { hasData: false });
            } catch (err) {
                console.warn('cache_get_dashboard failed; no cache applied', err);
                logDebug('primeDashboardCache: FAILED', { error: err?.toString?.() || 'unknown' });
            }
        }

        async function primeHealthFromDatabase() {
            if (!window.__TAURI__?.core?.invoke) {
                console.warn('[Health] Tauri API not available - cannot load snapshots');
                logDebug('primeHealthFromDatabase: NO TAURI');
                return { loaded: false, healthMap: new Map() };
            }

            try {
                const { invoke } = window.__TAURI__.core;
                const snapshots = await invoke('load_health_snapshots');

                if (!Array.isArray(snapshots)) {
                    console.warn('[Health] load_health_snapshots did not return an array:', typeof snapshots);
                    logDebug('primeHealthFromDatabase: INVALID DATA TYPE');
                    return { loaded: false, count: 0, healthMap: new Map() };
                }

                if (snapshots.length === 0) {
                    console.warn('[Health] No health snapshots found in database');
                    logDebug('primeHealthFromDatabase: NO DATA');
                    return { loaded: false, count: 0, healthMap: new Map() };
                }

                // Convert to map for easy lookup
                const healthMap = new Map();
                snapshots.forEach((snap, idx) => {
                    if (!snap.server_name) {
                        console.warn('[Health] Snapshot', idx, 'missing server_name:', snap);
                        return;
                    }
                    if (!snap.data) {
                        console.warn('[Health] Snapshot', idx, 'for', snap.server_name, 'missing data');
                        return;
                    }
                    healthMap.set(snap.server_name.toLowerCase(), {
                        data: snap.data,
                        lastProbedAt: snap.last_probed_at
                    });
                });

                logDebug('primeHealthFromDatabase: SUCCESS', { count: healthMap.size });
                return { loaded: true, count: healthMap.size, healthMap };
            } catch (err) {
                console.error('[Health] load_health_snapshots failed:', err);
                logDebug('primeHealthFromDatabase: FAILED', { error: err?.toString?.() || 'unknown' });
                return { loaded: false, error: err, healthMap: new Map() };
            }
        }

        function queueSettingsSave(payload) {
            if (!window.__TAURI__?.core?.invoke) return;
            queueSettingsSave._fn = queueSettingsSave._fn || debounce((body) => {
                window.__TAURI__.core.invoke('settings_set_all', { payload: body }).catch((err) => {
                    console.error('[Dashboard] settings_set_all failed:', err);
                });
            }, 200);
            queueSettingsSave._fn(payload);
        }

        // Use ThemeModule for consistent theme handling
        const applyTheme = window.ThemeModule?.applyTheme || function (theme) {
            console.warn('[Dashboard] ThemeModule not loaded, using fallback');
            document.documentElement.setAttribute('data-theme', theme || 'dark');
        };

        function normalizeLocationMappings(raw) {
            if (!Array.isArray(raw)) return [];
            return raw.map(entry => {
                const cidr = typeof entry?.cidr === 'string' ? entry.cidr.trim() : '';
                const range = typeof entry?.range === 'string' ? entry.range.trim() : '';
                const start = typeof entry?.start === 'string' ? entry.start.trim() : '';
                const end = typeof entry?.end === 'string' ? entry.end.trim() : '';
                const label = typeof entry?.label === 'string' ? entry.label.trim() : '';
                const value = cidr || range || (start && end ? `${start}-${end}` : start || '');
                return { cidr: value, range: value, label };
            }).filter(entry => (entry.cidr || entry.range) && entry.label);
        }

        function ipToInt(ip) {
            const parts = (ip || '').trim().split('.');
            if (parts.length !== 4) return null;
            const bytes = parts.map(p => Number(p));
            if (bytes.some(b => !Number.isInteger(b) || b < 0 || b > 255)) return null;
            return ((bytes[0] << 24) >>> 0) + (bytes[1] << 16) + (bytes[2] << 8) + bytes[3];
        }

        function cleanIpForMatch(ip) {
            if (typeof ip !== 'string') return '';
            // Strip CIDR suffixes or whitespace to match plain IPv4
            const trimmed = ip.trim();
            const noCidr = trimmed.split(/[\\s/]/)[0];
            return noCidr;
        }

        function cidrToRange(value) {
            const raw = (value || '').trim();
            if (!raw) return null;
            if (!raw.includes('/')) {
                const single = ipToInt(raw);
                if (single === null) return null;
                return { start: single, end: single };
            }
            const [ipPart, prefixPart] = raw.split('/');
            const prefix = Number(prefixPart);
            const base = ipToInt(ipPart);
            if (base === null || !Number.isInteger(prefix) || prefix < 0 || prefix > 32) return null;
            const mask = prefix === 0 ? 0 : (~0 << (32 - prefix)) >>> 0;
            const start = base & mask;
            const end = start | (~mask >>> 0);
            return { start, end };
        }

        function rangeFromValue(value) {
            const trimmed = (value || '').trim();
            if (!trimmed) return null;
            if (trimmed.includes('-')) {
                const [startRaw, endRaw] = trimmed.split('-');
                const start = ipToInt(startRaw);
                const end = ipToInt(endRaw || startRaw);
                if (start === null || end === null) return null;
                return { start: Math.min(start, end), end: Math.max(start, end) };
            }
            return cidrToRange(trimmed);
        }

        function buildLocationMatchers(mappings) {
            const normalized = normalizeLocationMappings(mappings);
            const matchers = normalized.map((entry) => {
                const label = (entry.label || '').trim();
                const range = rangeFromValue(entry.cidr || entry.range);
                if (!range || !label) return null;
                const start = Math.min(range.start, range.end);
                const end = Math.max(range.start, range.end);
                const span = end - start;
                return { start, end, label, span };
            }).filter(Boolean);
            // Prioritize the most specific (smallest span) first
            return matchers.sort((a, b) => a.span - b.span);
        }

        function deriveLocationFromAdapters(adapters, fallbackLocation) {
            if (!locationMatchers.length) {
                if (settings?.locationMappings?.length > 0) {
                    console.warn('[Location] Matchers empty but settings has mappings - rebuilding');
                    locationMatchers = buildLocationMatchers(settings.locationMappings);
                }
                if (!locationMatchers.length) {
                    return fallbackLocation || null;
                }
            }
            const list = Array.isArray(adapters) ? adapters : [];
            const seen = new Set();
            const ipInts = [];

            list.forEach((adapter) => {
                const ipv4 = Array.isArray(adapter?.ipv4) ? adapter.ipv4 : [];
                const prefixes = Array.isArray(adapter?.ipv4_prefix) ? adapter.ipv4_prefix : [];
                ipv4.forEach((ip, idx) => {
                    const trimmed = cleanIpForMatch(ip);
                    if (!trimmed) return;
                    const ipVal = ipToInt(trimmed);
                    if (ipVal === null || seen.has(ipVal)) return;
                    seen.add(ipVal);
                    ipInts.push(ipVal);
                    const prefix = Number(prefixes[idx]);
                    if (Number.isInteger(prefix) && prefix >= 0 && prefix <= 32) {
                        const mask = prefix === 0 ? 0 : (~0 << (32 - prefix)) >>> 0;
                        const start = ipVal & mask;
                        const end = start | (~mask >>> 0);
                        ipInts.push(start);
                        ipInts.push(end);
                    }
                });
            });

            for (const matcher of locationMatchers) {
                for (const ipVal of ipInts) {
                    if (ipVal >= matcher.start && ipVal <= matcher.end) {
                        return matcher.label;
                    }
                }
            }
            if (ipInts.length > 0) {
            }
            return fallbackLocation || null;
        }

        function applyLocationToServer(server, forceRecalculate = false) {
            if (!server) return server;
            // If we have a cached location and not forcing recalculation, keep it
            if (!forceRecalculate && server.location) {
                return server;
            }
            const adapters = server?.data?.net_adapters;
            const hasAdapters = Array.isArray(adapters) && adapters.length > 0;
            const fallback = hasAdapters ? null : (locationMatchers.length ? server.location : null);
            const location = deriveLocationFromAdapters(adapters, fallback);
            return { ...server, location };
        }

        function refreshLocationsFromSettings() {
            if (!serversData.length) {
                return;
            }
            serversData = serversData.map((server) => applyLocationToServer(server, true));
            displayAllServers();
        }

        function mergeHealthIntoServers(servers, healthMap) {
            if (!healthMap || healthMap.size === 0) {
                return servers;
            }

            let mergedCount = 0;

            // Helper to check if server data has meaningful content
            const hasMeaningfulData = (data) => {
                if (!data || typeof data !== 'object') return false;
                // Check for key indicators of meaningful health data
                const hasAdapters = Array.isArray(data.net_adapters) && data.net_adapters.length > 0;
                const hasOsInfo = data.os_info && isMeaningfulString(data.os_info.os_version);
                const hasMemory = Number.isFinite(data.total_memory_mb) && data.total_memory_mb > 0;
                return hasAdapters || hasOsInfo || hasMemory;
            };

            const result = servers.map(server => {
                const key = server.name.toLowerCase();
                const persisted = healthMap.get(key);

                if (!persisted) {
                    return server;
                }

                // Don't overwrite if server already has meaningful data
                // This preserves live data from recent probes over stale persisted data
                if (hasMeaningfulData(server.data)) {
                    return server;
                }

                // Warn if persisted data has no adapters but we're using it anyway
                const persistedHasAdapters = persisted.data?.net_adapters?.length > 0;
                if (!persistedHasAdapters && server.data?.net_adapters?.length > 0) {
                    console.warn('[DATA-LOSS] mergeHealthIntoServers: overwriting adapters with empty persisted data for', server.name);
                }

                mergedCount++;
                const persistedLocation = persisted.data?._location || null;

                // Extract location from snapshot if present
                // Clean _location from data object to avoid storing it in visible data
                const cleanData = { ...persisted.data };
                delete cleanData._location;

                // Merge persisted health data and location
                return {
                    ...server,
                    data: cleanData,
                    location: persistedLocation || server.location,
                    lastRefreshed: persisted.lastProbedAt,
                    online: true // Assume online from persisted data
                };
            });

            return result;
        }

        /**
         * Update the in-memory persistedHealthMap after successfully persisting health data.
         * This ensures that subsequent calls to mergeHealthIntoServers have the latest data
         * rather than stale data from app startup.
         */
        function updatePersistedHealthMap(serverName, healthData) {
            if (!serverName || !healthData) return;
            const key = serverName.toLowerCase();
            persistedHealthMap.set(key, {
                server_name: serverName,
                data: healthData,
                lastProbedAt: new Date().toISOString()
            });
        }

        function testLocationMatching() {

            serversData.forEach(server => {
                const adapters = server?.data?.net_adapters;
                const derived = deriveLocationFromAdapters(adapters, null);
            });
        }
        // Expose for console testing
        window.testLocationMatching = testLocationMatching;

        function clampProbeTimeoutMs(seconds) {
            const s = Number(seconds);
            if (!Number.isFinite(s) || s <= 0) return 90000;
            const clamped = Math.min(Math.max(s, 10), 900) * 1000; // 10s-900s (15 minutes)
            return clamped;
        }

        function clampQuickProbeTimeoutMs(seconds) {
            const s = Number(seconds);
            if (!Number.isFinite(s) || s <= 0) return 30000;
            const clamped = Math.min(Math.max(s, 5), 120) * 1000; // 5s-120s (2 minutes)
            return clamped;
        }

        function getProbeTimeoutMs() {
            return probeTimeoutMs || 90000;
        }

        function getQuickProbeTimeoutMs() {
            return quickProbeTimeoutMs || 30000;
        }

        function hydrateSettings() {
            const parsed = settingsBundle?.qp_settings || defaultSettings();
            settings = {
                ...defaultSettings(),
                ...(typeof parsed === 'object' && parsed !== null ? parsed : {})
            };
            probeTimeoutMs = clampProbeTimeoutMs(settings.probeTimeoutSeconds);
            quickProbeTimeoutMs = clampQuickProbeTimeoutMs(settings.quickProbeTimeoutSeconds);

            locationMatchers = buildLocationMatchers(settings.locationMappings);

            // Note: UI updates removed - callers should handle displayAllServers() and cacheDashboardData()
            // This prevents premature rendering with stale location data when settings are updated
        }

        function renderRuntimeModePill(info) {
            const pill = document.getElementById('runtime-mode-pill');
            const subtext = document.getElementById('runtime-mode-subtext');
            runtimeModeInfo = info || null;
            if (!pill) return;
            // Only show pill in non-local modes
            if (!info || info.mode === 'local') {
                pill.style.display = 'none';
                if (subtext) subtext.style.display = 'none';
                return;
            }

            if (!info) {
                pill.classList.add('hidden');
                pill.removeAttribute('title');
                if (subtext) subtext.classList.add('hidden');
                return;
            }

            const isRemote = info.mode === 'remote';
            const apiBase = info.details?.apiBaseUrl || '';
            const dbPath = info.details?.dbPath || '';
            const label = isRemote ? 'Remote (API)' : 'Local (SQLite)';
            pill.textContent = label;

            const tooltip = [];
            const detailText = isRemote
                ? (apiBase || 'API base URL not set')
                : '';
            const tooltipDetail = isRemote
                ? (apiBase || 'API base URL not set')
                : dbPath;
            if (tooltipDetail) tooltip.push(tooltipDetail);
            if (info.configSource === 'env') {
                tooltip.push('Configured via environment variables');
            } else if (info.configSource === 'ui') {
                tooltip.push('Set in Options');
            }

            const hasWarning =
                info.configSource === 'env' ||
                (isRemote && !info.details?.apiBaseUrl);
            pill.classList.toggle('mode-pill-warning', !!hasWarning);
            pill.classList.remove('hidden');

            const tooltipText = tooltip.join('\n');
            if (tooltipText) {
                pill.title = tooltipText;
            } else {
                pill.removeAttribute('title');
            }

            if (subtext) {
                const summaryParts = [];
                if (detailText) summaryParts.push(detailText);
                if (info.configSource === 'env') {
                    summaryParts.push('Mode enforced by environment');
                } else if (hasWarning && !detailText) {
                    summaryParts.push('Remote API not set');
                }
                subtext.textContent = summaryParts.join(' ¬∑ ');
                subtext.classList.toggle('hidden', summaryParts.length === 0);
            }
        }

        async function hydrateRuntimeMode() {
            if (!window.__TAURI__?.core) {
                renderRuntimeModePill(null);
                return;
            }
            try {
                const info = await window.__TAURI__.core.invoke('get_runtime_mode_info');
                renderRuntimeModePill(info);
            } catch (err) {
                console.warn('Failed to load runtime mode info', err);
                renderRuntimeModePill(null);
            }
        }

        function hydrateHostViewMode() {
            const raw = settingsBundle?.qp_host_view_mode;
            if (raw === 'cards' || raw === 'groups') {
                hostViewMode = raw;
            }
            // Restore focused group state if in groups mode
            if (settingsBundle?.qp_focused_group) {
                focusedGroup = settingsBundle.qp_focused_group;
            }
            updateViewSwitcherButtons();
        }

        function wireDetailsButton(btn, server) {
            if (!btn) return;
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (typeof openDetailsDialog !== 'function') {
                    showError('Details dialog unavailable. Please reload the dashboard.');
                    return;
                }
                openDetailsDialog(server);
            });
            btn.addEventListener('dblclick', (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
        }

        function persistHostViewMode(mode) {
            settingsBundle.qp_host_view_mode = mode;
            queueSettingsSave(settingsPayload());
        }

        function normalizeHostName(raw) {
            return Utils?.normalizeHostName ? Utils.normalizeHostName(raw) : '';
        }

        function setHostStatus(serverName, status, tone = 'info') {
            const normalized = normalizeHostName(serverName);
            if (!normalized || !status) return;
            hostStatuses.set(normalized, { status, tone });
            // Use debounced version to avoid recreating cards during batch refresh
            // which would interrupt animations on cards still being refreshed
            displayAllServersDebounced();
        }

        function clearHostStatus(serverName) {
            const normalized = normalizeHostName(serverName);
            if (!normalized) return;
            hostStatuses.delete(normalized);
            displayAllServers();
        }

        function getHostStatus(serverName) {
            const normalized = normalizeHostName(serverName);
            if (!normalized) return null;
            return hostStatuses.get(normalized) || null;
        }

        function normalizeServerRecord(server) {
            return Utils?.normalizeServerRecord ? Utils.normalizeServerRecord(server) : null;
        }

        function setCardRefreshing(serverName, refreshing) {
            const target = normalizeHostName(serverName);
            if (!target) {
                console.warn('[setCardRefreshing] No target after normalization:', serverName);
                return;
            }

            let foundCard = false;
            document.querySelectorAll('.server-card').forEach(card => {
                const cardName = normalizeHostName(card.dataset.serverName || '');
                if (cardName === target) {
                    card.classList.toggle('refreshing', refreshing);
                    foundCard = true;
                    console.log(`[setCardRefreshing] ${refreshing ? 'STARTED' : 'STOPPED'} pulse for ${serverName}`, {
                        hasClass: card.classList.contains('refreshing'),
                        allClasses: card.className
                    });
                }
            });

            if (!foundCard) {
                console.warn('[setCardRefreshing] Card not found for:', serverName, 'normalized:', target);
            }
        }

        function consumeHostsChangedFlag() {
            const flag = settingsBundle?.qp_hosts_changed;
            settingsBundle.qp_hosts_changed = null;
            if (flag) {
                queueSettingsSave(settingsPayload());
                return true;
            }
            return false;
        }

        function normalizeServicesList(services) {
            if (!Array.isArray(services)) return [];
            return services
                .map((s) => (s || '').toString().trim().toUpperCase())
                .filter(Boolean)
                .sort();
        }

        function isMeaningfulString(value) {
            if (typeof value !== 'string') return false;
            const trimmed = value.trim();
            if (!trimmed) return false;
            const lower = trimmed.toLowerCase();
            return lower !== 'unknown' && trimmed !== '-';
        }

        function pickString(preferred, fallback) {
            if (isMeaningfulString(preferred)) return preferred.trim();
            if (isMeaningfulString(fallback)) return fallback.trim();
            return (preferred || fallback || '').toString();
        }

        function pickPositiveNumber(preferred, fallback) {
            const preferredOk = Number.isFinite(preferred) && preferred > 0;
            const fallbackOk = Number.isFinite(fallback) && fallback > 0;
            if (preferredOk) return preferred;
            if (fallbackOk) return fallback;
            return preferredOk ? preferred : (fallbackOk ? fallback : (preferred ?? fallback));
        }

        // Prefer incoming array if it has items, otherwise preserve existing array
        function pickArray(preferred, fallback) {
            if (Array.isArray(preferred) && preferred.length > 0) return preferred;
            if (Array.isArray(fallback) && fallback.length > 0) return fallback;
            return Array.isArray(preferred) ? preferred : (Array.isArray(fallback) ? fallback : []);
        }

        // Prefer incoming object if it has meaningful content, otherwise preserve existing
        function pickObject(preferred, fallback) {
            const preferredOk = preferred && typeof preferred === 'object' && Object.keys(preferred).length > 0;
            const fallbackOk = fallback && typeof fallback === 'object' && Object.keys(fallback).length > 0;
            if (preferredOk) return preferred;
            if (fallbackOk) return fallback;
            return preferred ?? fallback ?? null;
        }

        // Prefer incoming number if finite and non-negative, otherwise preserve existing
        function pickNonNegativeNumber(preferred, fallback) {
            const preferredOk = Number.isFinite(preferred) && preferred >= 0;
            const fallbackOk = Number.isFinite(fallback) && fallback >= 0;
            if (preferredOk) return preferred;
            if (fallbackOk) return fallback;
            return preferred ?? fallback ?? 0;
        }

        function mergeHealthData(existing = {}, incoming = {}) {
            const merged = { ...existing, ...incoming };
            const existingOs = existing.os_info || {};
            const incomingOs = incoming.os_info || {};
            merged.os_info = {
                hostname: pickString(incomingOs.hostname, existingOs.hostname),
                os_version: pickString(incomingOs.os_version, existingOs.os_version),
                build_number: pickString(incomingOs.build_number, existingOs.build_number),
                product_type: pickString(incomingOs.product_type, existingOs.product_type),
                install_date: pickString(incomingOs.install_date, existingOs.install_date)
            };

            // When probe returned degraded data (winrm_issue), be conservative about overwriting
            // existing valid data with zeros/empty values
            const isDegraded = !!incoming.winrm_issue;

            // Network adapters - preserve existing if incoming is empty
            merged.net_adapters = pickArray(incoming.net_adapters, existing.net_adapters);

            // Memory stats
            merged.total_memory_mb = pickPositiveNumber(incoming.total_memory_mb, existing.total_memory_mb);
            merged.used_memory_mb = pickPositiveNumber(incoming.used_memory_mb, existing.used_memory_mb);
            merged.memory_used_percent = pickPositiveNumber(incoming.memory_used_percent, existing.memory_used_percent);
            // process_count uses pickPositiveNumber - a running system always has processes > 0
            // This prevents degraded probes (returning 0) from overwriting valid existing data
            merged.process_count = pickPositiveNumber(incoming.process_count, existing.process_count);

            // Uptime info
            const existingUptime = existing.uptime || {};
            const incomingUptime = incoming.uptime || {};
            const mergedUptime = {
                ...existingUptime,
                ...incomingUptime,
                uptime_hours: pickPositiveNumber(incomingUptime.uptime_hours, existingUptime.uptime_hours),
                cpu_load_pct: pickNonNegativeNumber(incomingUptime.cpu_load_pct, existingUptime.cpu_load_pct),
                last_boot: pickString(incomingUptime.last_boot, existingUptime.last_boot)
            };
            merged.uptime = mergedUptime;

            // Disk information - preserve existing if incoming is empty
            merged.disks = pickArray(incoming.disks, existing.disks);
            merged.disk_alerts = pickArray(incoming.disk_alerts, existing.disk_alerts);
            // For total_disks: if degraded and incoming is 0 but we have existing disks data, preserve it
            const incomingTotalDisks = incoming.total_disks;
            const existingTotalDisks = existing.total_disks;
            if (isDegraded && incomingTotalDisks === 0 && existingTotalDisks > 0) {
                merged.total_disks = existingTotalDisks;
            } else {
                merged.total_disks = pickNonNegativeNumber(incomingTotalDisks, existingTotalDisks);
            }

            // Service information - preserve existing if incoming is empty
            merged.service_status = pickArray(incoming.service_status, existing.service_status);
            // For service_alerts: if degraded and incoming is 0 but we have existing service data, preserve it
            const incomingServiceAlerts = incoming.service_alerts;
            const existingServiceAlerts = existing.service_alerts;
            if (isDegraded && incomingServiceAlerts === 0 && Array.isArray(existing.service_status) && existing.service_status.length > 0) {
                merged.service_alerts = existingServiceAlerts;
            } else {
                merged.service_alerts = pickNonNegativeNumber(incomingServiceAlerts, existingServiceAlerts);
            }

            // Process information - preserve existing if incoming is empty
            merged.high_cpu_processes = pickArray(incoming.high_cpu_processes, existing.high_cpu_processes);
            merged.high_cpu_threshold = pickPositiveNumber(incoming.high_cpu_threshold, existing.high_cpu_threshold);

            // Optional objects - preserve existing if incoming is null/empty
            merged.pending_reboot = pickObject(incoming.pending_reboot, existing.pending_reboot);
            merged.winrm_listeners = pickArray(incoming.winrm_listeners, existing.winrm_listeners);
            merged.firewall_profiles = pickArray(incoming.firewall_profiles, existing.firewall_profiles);
            merged.recent_errors = pickArray(incoming.recent_errors, existing.recent_errors);
            merged.reachability = pickObject(incoming.reachability, existing.reachability);

            return merged;
        }

        function servicesEqualNormalized(a, b) {
            const left = normalizeServicesList(a);
            const right = normalizeServicesList(b);
            if (left.length !== right.length) return false;
            for (let i = 0; i < left.length; i += 1) {
                if (left[i] !== right[i]) return false;
            }
            return true;
        }

        function computeHostsSignature(hosts) {
            const canonical = (hosts || [])
                .map((host) => {
                    const name = normalizeHostName(host?.name || '');
                    if (!name) return null;
                    const osType = Utils?.normalizeOsType
                        ? Utils.normalizeOsType(host?.os_type || host?.os || host?.osType)
                        : 'Windows';
                    return {
                        name,
                        notes: (host?.notes || '').trim(),
                        group: (host?.group || host?.box || '').trim(),
                        services: normalizeServicesList(host?.services),
                        os: osType
                    };
                })
                .filter(Boolean)
                .sort((a, b) => a.name.localeCompare(b.name));
            return JSON.stringify(canonical);
        }

        function parseServerOrder() {
            const parsed = settingsBundle?.qp_server_order;
            return Array.isArray(parsed) ? parsed.filter(Boolean) : [];
        }

        function saveServerOrder(order) {
            settingsBundle.qp_server_order = Array.isArray(order) ? [...order] : [];
            queueSettingsSave(settingsPayload());
        }

        function applyOrder(list, order) {
            if (!Array.isArray(list) || list.length === 0) return [];
            if (!Array.isArray(order) || order.length === 0) return list;

            const remaining = [...list];
            const ordered = [];
            const lowerOrder = order.map((o) => (o || '').toString().toLowerCase());

            lowerOrder.forEach((name) => {
                const idx = remaining.findIndex((item) => (item?.name || '').toLowerCase() === name);
                if (idx >= 0) {
                    ordered.push(remaining.splice(idx, 1)[0]);
                }
            });

            return [...ordered, ...remaining];
        }

        function debugEnabled() {
            return window?.QP_DEBUG === 1
                || window?.QP_DEBUG === true
                || window?.QP_DEBUG === '1'
                || localStorage.getItem('QP_DEBUG') === '1'
                || (window?.process?.env?.QP_DEBUG === '1');
        }

        function logHostsSnapshot(hostsLoaded, orderCount, visibleCount) {
            if (!debugEnabled()) return;
            const cachePresent = Array.isArray(dashboardCache?.serversData) && dashboardCache.serversData.length > 0;
            console.info('[hosts]', {
                hosts_loaded_count: hostsLoaded,
                order_count: orderCount,
                visible_count: visibleCount,
                cache_present: cachePresent
            });
        }

        function persistOrderFromDom() {
            const grid = document.getElementById('servers-grid');
            if (!grid) return;
            const domOrder = Array.from(grid.querySelectorAll('.server-card'))
                .map(card => (card.dataset.serverName || '').trim())
                .filter(Boolean);
            const existingOrder = parseServerOrder();
            const merged = [...domOrder];

            existingOrder.forEach(name => {
                if (!merged.some(n => n.toLowerCase() === name.toLowerCase())) {
                    merged.push(name);
                }
            });

            serversData.forEach(server => {
                if (!merged.some(n => n.toLowerCase() === server.name.toLowerCase())) {
                    merged.push(server.name);
                }
            });

            saveServerOrder(merged);
            serversData = applyOrder(serversData, merged);
        }

        let selectedServerName = null;
        let groupRenameDialog = null;

        function clearSelection() {
            selectedServerName = null;
        }

        // Card click handler - trigger quick probe on click
        function handleCardClick(event, serverName) {
            const cardEl = event.currentTarget;
            if (cardEl && cardEl.dataset.preview === 'true') return;
            if (event.target.closest('button, a, input, textarea, select, option')) return;

            // Trigger quick probe on single-click
            selectedServerName = serverName;
            triggerQuickProbe(serverName, 'card-click');
        }

        // ==================== Drag and Drop System (Mouse-based) ====================
        const DragDropManager = {
            draggedElement: null,
            draggedClone: null,
            draggedType: null, // 'card' or 'group'
            placeholder: null,
            scrollInterval: null,
            scrollSpeed: 20,
            scrollEdgeThreshold: 80,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            offsetX: 0,
            offsetY: 0,
            isDragging: false,
            animationFrame: null,
            lastPlaceholderUpdate: 0,
            placeholderThrottle: 50, // ms between placeholder updates
            boundMouseMove: null,
            boundMouseUp: null,
            gridContainer: null,
            // Drag threshold - prevents drag from interfering with double-clicks
            dragThreshold: 5, // pixels to move before drag starts
            pendingDrag: false,
            mouseDownX: 0,
            mouseDownY: 0,
            pendingElement: null,
            pendingType: null,
            originalContainer: null, // Track original parent container for cards in groups

            // Initialize drag-and-drop for a card
            initCard(card) {
                if (!card || card.dataset.preview === 'true') return;
                if (card.dataset.dragInitialized === 'true') return;
                card.dataset.dragInitialized = 'true';
                card.style.cursor = 'grab';
                card.addEventListener('mousedown', (e) => this.handleMouseDown(e, card, 'card'));
            },

            // Initialize drag-and-drop for a group card
            initGroupCard(groupCard) {
                if (!groupCard) return;
                if (groupCard.dataset.dragInitialized === 'true') return;
                groupCard.dataset.dragInitialized = 'true';
                groupCard.style.cursor = 'grab';
                groupCard.addEventListener('mousedown', (e) => this.handleMouseDown(e, groupCard, 'group'));
            },

            handleMouseDown(e, element, type) {
                // Only handle left mouse button
                if (e.button !== 0) return;

                // Don't start drag if clicking on interactive elements
                const target = e.target;
                if (target.closest('button, input, select, textarea, a, [onclick]')) return;

                // Store initial mouse position for threshold check
                // Don't preventDefault yet - allow double-click to work
                this.mouseDownX = e.clientX;
                this.mouseDownY = e.clientY;
                this.pendingDrag = true;
                this.pendingElement = element;
                this.pendingType = type;

                // Add global listeners to detect movement
                this.boundMouseMove = (e) => this.handleMouseMove(e);
                this.boundMouseUp = (e) => this.handleMouseUp(e);
                document.addEventListener('mousemove', this.boundMouseMove, { passive: true });
                document.addEventListener('mouseup', this.boundMouseUp);
            },

            // Actually start the drag after threshold is exceeded
            startDrag(e) {
                const element = this.pendingElement;
                const type = this.pendingType;

                this.pendingDrag = false;
                this.draggedElement = element;
                this.draggedType = type;
                this.gridContainer = document.getElementById('servers-grid');
                // Store original container - for cards in expanded groups, this is .group-card-hosts
                this.originalContainer = element.parentNode;

                const rect = element.getBoundingClientRect();
                this.offsetX = e.clientX - rect.left;
                this.offsetY = e.clientY - rect.top;
                this.startX = rect.left;
                this.startY = rect.top;
                this.currentX = rect.left;
                this.currentY = rect.top;

                // Create a smaller clone for dragging (thumbnail-like)
                this.draggedClone = element.cloneNode(true);
                this.draggedClone.classList.add('drag-clone');
                this.draggedClone.style.cssText = `
                    position: fixed;
                    left: 0;
                    top: 0;
                    width: ${rect.width * 0.6}px;
                    z-index: 10000;
                    pointer-events: none;
                    opacity: 0.95;
                    transform: translate(${rect.left}px, ${rect.top}px) rotate(2deg);
                    box-shadow: 0 25px 50px rgba(0,0,0,0.4);
                    border-radius: 0.5rem;
                    overflow: hidden;
                    will-change: transform;
                    transition: box-shadow 0.2s ease;
                `;
                document.body.appendChild(this.draggedClone);

                // Create placeholder
                this.placeholder = document.createElement('div');
                this.placeholder.className = 'drag-placeholder';
                this.placeholder.style.cssText = `
                    height: ${rect.height}px;
                    box-sizing: border-box;
                    transition: all 0.15s ease;
                `;

                // Hide original (display:none so it doesn't take space) and insert placeholder
                element.parentNode.insertBefore(this.placeholder, element);
                element.style.display = 'none';

                // Zoom out the grid for overview
                if (this.gridContainer) {
                    this.gridContainer.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
                    this.gridContainer.style.transformOrigin = 'top center';
                    this.gridContainer.style.transform = 'scale(0.85)';
                    this.gridContainer.style.opacity = '0.9';
                }

                this.isDragging = true;
                document.body.classList.add('dragging-active');

                // Start animation loop
                this.startAnimationLoop();
            },

            handleMouseMove(e) {
                // Check if we need to start drag (threshold check)
                if (this.pendingDrag && !this.isDragging) {
                    const dx = e.clientX - this.mouseDownX;
                    const dy = e.clientY - this.mouseDownY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance >= this.dragThreshold) {
                        // Threshold exceeded - start actual drag
                        this.startDrag(e);
                    }
                    return;
                }

                if (!this.isDragging) return;

                // Store current position (will be applied in animation frame)
                this.currentX = e.clientX - this.offsetX;
                this.currentY = e.clientY - this.offsetY;

                // Auto-scroll
                this.updateAutoScroll(e.clientY, e.clientX);

                // Throttled placeholder update
                const now = Date.now();
                if (now - this.lastPlaceholderUpdate > this.placeholderThrottle) {
                    this.lastPlaceholderUpdate = now;
                    this.updatePlaceholder(e.clientX, e.clientY);
                }
            },

            startAnimationLoop() {
                const animate = () => {
                    if (!this.isDragging || !this.draggedClone) return;

                    // Apply position using transform (GPU accelerated)
                    this.draggedClone.style.transform = `translate(${this.currentX}px, ${this.currentY}px) rotate(2deg)`;

                    this.animationFrame = requestAnimationFrame(animate);
                };
                this.animationFrame = requestAnimationFrame(animate);
            },

            updatePlaceholder(x, y) {
                // Temporarily hide clone to get element underneath
                if (this.draggedClone) {
                    this.draggedClone.style.visibility = 'hidden';
                }

                // Adjust coordinates for scaled grid
                const gridRect = this.gridContainer?.getBoundingClientRect();
                const scale = 0.85;
                const adjustedX = gridRect ? gridRect.left + (x - gridRect.left) / scale : x;
                const adjustedY = gridRect ? gridRect.top + (y - gridRect.top) / scale : y;

                const dropTarget = this.findDropTarget(x, y);

                if (this.draggedClone) {
                    this.draggedClone.style.visibility = '';
                }

                if (dropTarget && dropTarget !== this.draggedElement && dropTarget !== this.placeholder) {
                    const container = dropTarget.parentElement;
                    const rect = dropTarget.getBoundingClientRect();
                    const midY = rect.top + rect.height / 2;

                    // Insert placeholder before or after target
                    if (y < midY) {
                        if (this.placeholder.nextSibling !== dropTarget) {
                            container.insertBefore(this.placeholder, dropTarget);
                        }
                    } else {
                        if (this.placeholder.previousSibling !== dropTarget) {
                            container.insertBefore(this.placeholder, dropTarget.nextSibling);
                        }
                    }
                }
            },

            handleMouseUp(e) {
                // If we were waiting for drag threshold but never started dragging,
                // just clean up listeners - this allows click/dblclick to work normally
                if (this.pendingDrag && !this.isDragging) {
                    this.pendingDrag = false;
                    this.pendingElement = null;
                    this.pendingType = null;
                    document.removeEventListener('mousemove', this.boundMouseMove);
                    document.removeEventListener('mouseup', this.boundMouseUp);
                    return;
                }

                if (!this.isDragging) return;

                // Cancel animation frame
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }

                // Remove global listeners
                document.removeEventListener('mousemove', this.boundMouseMove);
                document.removeEventListener('mouseup', this.boundMouseUp);

                // Stop auto-scroll
                this.stopAutoScroll();

                // Restore grid scale
                if (this.gridContainer) {
                    this.gridContainer.style.transform = '';
                    this.gridContainer.style.opacity = '';
                    // Clean up after transition
                    setTimeout(() => {
                        if (this.gridContainer) {
                            this.gridContainer.style.transition = '';
                            this.gridContainer.style.transformOrigin = '';
                        }
                    }, 300);
                }

                // Move the actual element to placeholder position
                if (this.placeholder && this.placeholder.parentNode) {
                    this.placeholder.parentNode.insertBefore(this.draggedElement, this.placeholder);
                    this.placeholder.remove();
                }

                // Restore original element
                if (this.draggedElement) {
                    this.draggedElement.style.display = '';
                }

                // Remove clone
                if (this.draggedClone) {
                    this.draggedClone.remove();
                }

                // Persist order
                this.persistOrder();

                // Reset state
                document.body.classList.remove('dragging-active');
                this.draggedElement = null;
                this.draggedClone = null;
                this.draggedType = null;
                this.placeholder = null;
                this.isDragging = false;
                this.gridContainer = null;
                this.originalContainer = null;
                this.pendingDrag = false;
                this.pendingElement = null;
                this.pendingType = null;
            },

            findDropTarget(x, y) {
                const elementsAtPoint = document.elementsFromPoint(x, y);
                let target = null;

                // Check if we're dragging a card from within an expanded group
                const isCardInGroup = this.draggedType === 'card' &&
                    this.originalContainer?.classList.contains('group-card-hosts');

                for (const el of elementsAtPoint) {
                    if (el.classList.contains('server-card') || el.classList.contains('group-card')) {
                        if (el !== this.draggedElement && el.dataset.preview !== 'true' && el !== this.placeholder) {
                            // If dragging within an expanded group, only allow dropping on cards in the same container
                            if (isCardInGroup) {
                                // Skip group cards - can't drop a card onto a group card when inside a group
                                if (el.classList.contains('group-card')) continue;
                                // Only accept cards in the same container
                                if (el.parentNode !== this.originalContainer) continue;
                            }
                            target = el;
                            break;
                        }
                    }
                }

                return target;
            },

            persistOrder() {
                if (this.draggedType === 'card') {
                    persistOrderFromDom();
                } else if (this.draggedType === 'group') {
                    this.persistGroupOrder();
                }
            },

            persistGroupOrder() {
                const container = document.getElementById('servers-grid');
                if (!container) return;

                const groupCards = Array.from(container.querySelectorAll('.group-card'));
                const groupOrder = groupCards
                    .map(card => card.dataset.group)
                    .filter(Boolean);

                settingsBundle.qp_group_order = groupOrder;
                queueSettingsSave(settingsPayload());
            },

            // Auto-scroll functionality
            stopAutoScroll() {
                if (this.scrollInterval) {
                    cancelAnimationFrame(this.scrollInterval);
                    this.scrollInterval = null;
                }
            },

            updateAutoScroll(clientY, clientX) {
                const viewportHeight = window.innerHeight;
                const viewportWidth = window.innerWidth;
                let scrollX = 0;
                let scrollY = 0;

                // Check vertical scroll
                if (clientY < this.scrollEdgeThreshold) {
                    scrollY = -this.scrollSpeed * (1 - clientY / this.scrollEdgeThreshold);
                } else if (clientY > viewportHeight - this.scrollEdgeThreshold) {
                    scrollY = this.scrollSpeed * (1 - (viewportHeight - clientY) / this.scrollEdgeThreshold);
                }

                // Check horizontal scroll
                if (clientX < this.scrollEdgeThreshold) {
                    scrollX = -this.scrollSpeed * (1 - clientX / this.scrollEdgeThreshold);
                } else if (clientX > viewportWidth - this.scrollEdgeThreshold) {
                    scrollX = this.scrollSpeed * (1 - (viewportWidth - clientX) / this.scrollEdgeThreshold);
                }

                // Apply scroll if needed
                if (scrollX !== 0 || scrollY !== 0) {
                    window.scrollBy(scrollX, scrollY);
                }
            }
        };

        // Initialize drag-and-drop for all existing cards (called after rendering)
        function initDragDropForCards() {
            const grid = document.getElementById('servers-grid');
            if (!grid) return;

            // Initialize server cards (both in main grid and within expanded groups)
            grid.querySelectorAll('.server-card').forEach(card => {
                if (card.dataset.preview !== 'true') {
                    DragDropManager.initCard(card);
                }
            });

            // Initialize group cards (only non-focused groups can be dragged)
            grid.querySelectorAll('.group-card').forEach(card => {
                if (!card.classList.contains('full-focus')) {
                    DragDropManager.initGroupCard(card);
                }
            });
        }

        document.addEventListener('DOMContentLoaded', async () => {
            const initStart = Date.now();
            logDebug('dashboard:init:start');
            // Ensure loading is hidden immediately on init
            hideLoading();
            try {
                if (!Utils) {
                    showError('Dashboard utilities failed to load. Please refresh.');
                    return;
                }
                disableAutocomplete();
                await primeSettingsFromBackend();
                await primeDashboardCache();
                const healthResult = await primeHealthFromDatabase();
                persistedHealthMap = healthResult.healthMap || new Map();
                hydrateSettings();
                await hydrateRuntimeMode();
                if (window.__TAURI__) {
                    try {
                        const status = await window.__TAURI__.core.invoke('debug_local_store_status');
                        console.info('[debug_local_store_status]', status);
                    } catch (dbgErr) {
                        console.warn('debug_local_store_status failed', dbgErr);
                    }
                }
                hydrateHostViewMode();

                // Set up unified theme update listeners
                console.log('[Dashboard] About to call ThemeModule.subscribeToThemeUpdates');
                if (window.ThemeModule?.subscribeToThemeUpdates) {
                    // Pass theme from settingsBundle (loaded from backend) for consistency
                    const themeFromSettings = settingsBundle?.qp_settings?.theme || 'system';
                    window.ThemeModule.subscribeToThemeUpdates(themeFromSettings);
                    console.log('[Dashboard] ThemeModule.subscribeToThemeUpdates called successfully');
                } else {
                    console.error('[Dashboard] ThemeModule not available!');
                }

                // Listen for storage events (cross-tab communication)
                window.addEventListener('storage', async (e) => {
                    if (e.key === SETTINGS_KEY) {
                        try {
                            // Theme is handled by ThemeModule, but we still need to:
                            // - Reload from backend for full sync
                            // - Reapply locations with new matchers
                            await primeSettingsFromBackend();
                            hydrateSettings();

                            // Check if hosts were changed in the CRUD window
                            const hostsChanged = consumeHostsChangedFlag();
                            if (hostsChanged) {
                                console.log('[Settings] Hosts changed detected via storage event, reloading dashboard...');
                                const latestHosts = await fetchNormalizedHosts();
                                const latestSignature = latestHosts.signature || computeHostsSignature(latestHosts.hosts);
                                hostsSignature = latestSignature;

                                // Build fresh server list from current hosts
                                const order = parseServerOrder();
                                const baseServers = latestHosts.hosts.map((h) => ({
                                    ...h,
                                    online: true,
                                    data: h.data || {},
                                    error: undefined,
                                    lastRefreshed: h.lastRefreshed || null
                                }));

                                // Merge with persisted health snapshots from database
                                if (persistedHealthMap?.size > 0) {
                                    serversData = mergeHealthIntoServers(baseServers, persistedHealthMap);
                                } else {
                                    serversData = baseServers;
                                }
                                serversData = applyOrder(serversData, order);
                                serversData = serversData.map(server => applyLocationToServer(server, false));

                                cacheDashboardData();
                                displayAllServers();

                                // Restart heartbeat with updated host list
                                stopHeartbeatLoop();
                                startHeartbeatLoop(latestHosts.hosts || []);
                                return;
                            }

                            // Reapply locations to all existing servers with new matchers
                            refreshLocationsFromSettings();
                            cacheDashboardData();
                        } catch (err) {
                            console.warn('[Settings] Failed to process storage event:', err);
                        }
                    }
                });

                // Listen for Tauri events from options window
                if (window.__TAURI__?.event?.listen) {
                    window.__TAURI__.event.listen('settings-updated', async (event) => {
                        try {
                            // Theme is handled by ThemeModule, but we still need to:
                            // - Reload from backend for full sync
                            // - Reapply locations with new matchers
                            await primeSettingsFromBackend();
                            hydrateSettings();

                            // Check if hosts were changed in the CRUD window
                            const hostsChanged = consumeHostsChangedFlag();
                            if (hostsChanged) {
                                console.log('[Settings] Hosts changed detected, reloading dashboard...');
                                const latestHosts = await fetchNormalizedHosts();
                                const latestSignature = latestHosts.signature || computeHostsSignature(latestHosts.hosts);
                                hostsSignature = latestSignature;

                                // Build fresh server list from current hosts
                                const order = parseServerOrder();
                                const baseServers = latestHosts.hosts.map((h) => ({
                                    ...h,
                                    online: true,
                                    data: h.data || {},
                                    error: undefined,
                                    lastRefreshed: h.lastRefreshed || null
                                }));

                                // Merge with persisted health snapshots from database
                                if (persistedHealthMap?.size > 0) {
                                    serversData = mergeHealthIntoServers(baseServers, persistedHealthMap);
                                } else {
                                    serversData = baseServers;
                                }
                                serversData = applyOrder(serversData, order);
                                serversData = serversData.map(server => applyLocationToServer(server, false));

                                cacheDashboardData();
                                displayAllServers();

                                // Restart heartbeat with updated host list
                                stopHeartbeatLoop();
                                startHeartbeatLoop(latestHosts.hosts || []);
                                return;
                            }

                            // Reapply locations to all existing servers with new matchers
                            refreshLocationsFromSettings();
                            cacheDashboardData();
                        } catch (err) {
                            console.warn('[Settings] Failed to process settings-updated event:', err);
                        }
                    }).catch(err => {
                        console.warn('Failed to setup settings-updated listener', err);
                    });
                }

                setupEventListeners();
                initHostCredentialDialog();
                initNotesDialog();
                initEditHostDialog();
                initEditServiceBrowser();
                initGroupRenameDialog();
                initErrorDialog();
                initDetailsDialog();
                initHostPreviewModal();

                const hostsChanged = consumeHostsChangedFlag();
                const cacheState = hydrateFromCache();
                const previousSignature = hostsSignature;

                // Hide loading immediately if we have cached data to display (and hosts haven't changed)
                if (cacheState.hydrated && serversData.length > 0 && !hostsChanged) {
                    hideLoading();
                }

                logDebug('dashboard:init:cache_state', {
                    hydrated: cacheState.hydrated,
                    stale: cacheState.stale,
                    serversCount: serversData.length,
                    hostsChanged: !!hostsChanged,
                    previousSignature: previousSignature || 'none'
                });

                const hasHosts = await ensureHostsPresent();
                if (!hasHosts) {
                    hideLoading();
                    return;
                }

                const latestHosts = await fetchNormalizedHosts();
                const latestSignature = latestHosts.signature || computeHostsSignature(latestHosts.hosts);
                const signatureMatches = previousSignature && latestSignature && latestSignature === previousSignature;

                // If hosts were changed in the CRUD window, we need to rebuild from latest host list
                // but preserve snapshot data for unchanged hosts
                if (hostsChanged) {
                    hostsSignature = latestSignature;

                    // Build fresh server list from current hosts
                    const order = parseServerOrder();
                    const baseServers = latestHosts.hosts.map((h) => ({
                        ...h,
                        online: true,
                        data: h.data || {},
                        error: undefined,
                        lastRefreshed: h.lastRefreshed || null
                    }));

                    // Merge with persisted health snapshots from database
                    if (persistedHealthMap?.size > 0) {
                        serversData = mergeHealthIntoServers(baseServers, persistedHealthMap);
                    } else {
                        console.warn('[Init] No health snapshots available - hosts will show as Unknown until probed');
                        serversData = baseServers;
                    }
                    serversData = applyOrder(serversData, order);
                    serversData = serversData.map(server => applyLocationToServer(server, false));

                    cacheDashboardData();
                    displayAllServers();
                    startHeartbeatLoop(latestHosts.hosts || []);
                    scheduleSelfHeal();
                    hideLoading();
                    return;
                }

                // Use cached/snapshot data and only refresh incomplete hosts
                hostsSignature = latestSignature || previousSignature || hostsSignature;
                logDebug('dashboard:init:using_snapshots', {
                    serversCount: serversData.length,
                    signature: hostsSignature,
                    cacheAge: cacheState.hydrated ? 'fresh' : 'none',
                    persistedHealthCount: persistedHealthMap?.size || 0
                });
                hideLoading();
                hideError();

                // If we have data from cache or snapshots, use it and skip full probe
                if (serversData.length > 0) {
                    // Ensure locations are applied with current matchers before re-rendering
                    serversData = serversData.map(server => applyLocationToServer(server, false));
                    // Re-display with updated locations (already hidden loading from hydrateFromCache)
                    displayAllServers();
                    startHeartbeatLoop(latestHosts.hosts || []);
                    // Schedule background healing for incomplete hosts using quick probes
                    scheduleSelfHeal();
                } else {
                    // No cached data at all, do a quick load to populate from database snapshots
                    loadAllServers({ preloadedHosts: { ...latestHosts, signature: latestSignature }, silent: true, quickOnly: true });
                }
            } catch (err) {
                const elapsed = Date.now() - initStart;
                console.error('Dashboard init failed', err);
                logDebug(`dashboard:init:FAILED ${elapsed}ms: ${err}`);
                hideLoading();
                showLoadError(err?.toString?.() || 'Unable to load hosts.');
            } finally {
                const elapsed = Date.now() - initStart;
                logDebug(`dashboard:init:complete ${elapsed}ms`);
                hideLoading();
                revealApp();
            }
        });

        function clearDashboardForNoHosts(message) {
            serversData = [];
            cacheDashboardData();
            hideLoadError();
            showEmptyState(message || 'No hosts available');
        }

        async function ensureHostsPresent() {
            if (!window.__TAURI__) {
                return true; // cannot verify; allow flow to proceed
            }
            try {
                const { invoke } = window.__TAURI__.core;
                const hostsRaw = await invoke('get_hosts');
                const hosts = Array.isArray(hostsRaw) ? hostsRaw : [];
                if (hosts.length === 0) {
                    clearDashboardForNoHosts('No Hosts Found');
                    return false;
                }
                return true;
            } catch (e) {
                console.error('Failed to check hosts list', e);
                return true; // fail open to avoid blocking the UI entirely
            }
        }

        function setupEventListeners() {
            document.getElementById('edit-hosts-btn').addEventListener('click', () => {
                navigateToHosts();
            });
            const emptyEdit = document.getElementById('empty-edit-hosts-btn');
            if (emptyEdit) {
                emptyEdit.addEventListener('click', () => {
                    navigateToHosts();
                });
            }
            const retryBtn = document.getElementById('load-retry-btn');
            if (retryBtn) {
                retryBtn.addEventListener('click', () => {
                    loadAllServers({ silent: false });
                });
            }
            const loadEditBtn = document.getElementById('load-edit-hosts-btn');
            if (loadEditBtn) {
                loadEditBtn.addEventListener('click', () => {
                    navigateToHosts();
                });
            }
            document.getElementById('refresh-visible-btn').addEventListener('click', (e) => {
                logDebug(`dashboard:action:refresh_hosts clicked view=${hostViewMode} search=${!!searchTerm}`);
                refreshVisibleHosts(e.currentTarget);
            });
            document.getElementById('back-to-login-btn').addEventListener('click', async () => {
                logDebug('dashboard:action:back_to_login');
                // Call logout to clear credential state, then go to login without auto-login
                if (window.__TAURI__) {
                    try {
                        await window.__TAURI__.core.invoke('logout');
                    } catch (e) {
                        console.error('Logout error:', e);
                    }
                }
                window.location.href = 'login.html?skipAutoLogin=true';
            });

            const searchInput = document.getElementById('server-search');
            const clearSearchBtn = document.getElementById('clear-search-btn');

            if (searchInput) {
                searchInput.addEventListener('input', (e) => {
                    searchTerm = e.target.value;
                    // Reset filter when user starts typing
                    if (searchTerm.trim()) {
                        activeFilter = null;
                    }
                    displayAllServers();
                });
            }

            if (clearSearchBtn) {
                clearSearchBtn.addEventListener('click', () => {
                    if (!searchInput) return;
                    searchTerm = '';
                    searchInput.value = '';
                    searchInput.focus();
                    // Preserve active filter when clearing search
                    displayAllServers();
                });
            }

            document.querySelectorAll('.stat[data-filter]').forEach(card => {
                card.addEventListener('click', () => toggleFilter(card.dataset.filter));
                card.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        toggleFilter(card.dataset.filter);
                    }
                });
            });

            document.querySelectorAll('.view-btn[data-view]').forEach(btn => {
                btn.addEventListener('click', () => setHostViewMode(btn.dataset.view));
            });

            const reorderBtn = document.getElementById('reorder-btn');
            if (reorderBtn) {
                reorderBtn.addEventListener('click', toggleReorderMode);
            }

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    clearSelection();
                    return;
                }
            });
        }

        function initHostCredentialDialog() {
            const modal = document.getElementById('rdp-credential-modal');
            const form = document.getElementById('rdp-credential-form');
            const usernameInput = document.getElementById('rdp-credential-username');
            const passwordInput = document.getElementById('rdp-credential-password');
            const serverLabel = document.getElementById('rdp-credential-server');
            const cancelBtn = document.getElementById('rdp-credential-cancel');
            const closeBtn = document.getElementById('rdp-credential-close');

            if (!modal || !form || !usernameInput || !passwordInput || !serverLabel || !cancelBtn || !closeBtn) {
                return;
            }

            let resolver = null;

            const closeDialog = (result = null) => {
                modal.close();
                const currentResolver = resolver;
                resolver = null;
                usernameInput.value = '';
                passwordInput.value = '';
                if (currentResolver) {
                    currentResolver(result);
                }
            };

            form.addEventListener('submit', (event) => {
                event.preventDefault();
                const username = usernameInput.value.trim();
                const password = passwordInput.value;
                if (!username) {
                    usernameInput.focus();
                    return;
                }
                closeDialog({ username, password });
            });

            cancelBtn.addEventListener('click', (event) => {
                event.preventDefault();
                closeDialog(null);
            });

            closeBtn.addEventListener('click', (event) => {
                event.preventDefault();
                closeDialog(null);
            });

            // DaisyUI dialog handles backdrop clicks and ESC key automatically
            modal.addEventListener('close', () => {
                if (resolver) closeDialog(null);
            });

            openHostCredentialDialog = (serverName) => {
                serverLabel.textContent = serverName;
                modal.showModal();
                return new Promise((resolve) => {
                    resolver = resolve;
                    usernameInput.focus();
                });
            };
        }

        function initNotesDialog() {
            const modal = document.getElementById('notes-modal');
            const form = document.getElementById('notes-modal-form');
            const textArea = document.getElementById('notes-modal-text');
            const serverLabel = document.getElementById('notes-modal-server');
            const cancelBtn = document.getElementById('notes-modal-cancel');
            const closeBtn = document.getElementById('notes-modal-close');

            if (!modal || !form || !textArea || !serverLabel || !cancelBtn || !closeBtn) {
                return;
            }

            let resolver = null;
            let initialValue = '';

            const captureSnapshot = () => textArea.value || '';

            const markDirty = () => {
                const current = captureSnapshot();
                notesDirty = current !== initialValue;
            };

            const clearDirty = () => {
                notesDirty = false;
                initialValue = captureSnapshot();
            };

            const closeDialog = async (result = null) => {
                // Check for unsaved changes before closing
                if (result === null && notesDirty) {
                    const confirmed = await showConfirmDialog(
                        'Discard unsaved changes to notes?',
                        { title: 'Unsaved Changes', okText: 'Discard', okClass: 'btn-warning' }
                    );
                    if (!confirmed) return;
                }

                modal.close();
                document.removeEventListener('keydown', onKeyDown);
                textArea.removeEventListener('input', markDirty);
                const currentResolver = resolver;
                resolver = null;
                textArea.value = '';
                notesDirty = false;
                initialValue = '';
                if (currentResolver) {
                    currentResolver(result);
                }
            };

            const onKeyDown = (event) => {
                if (event.key === 'Escape') {
                    event.preventDefault();
                    closeDialog(null);
                }
            };

            form.addEventListener('submit', (event) => {
                event.preventDefault();
                closeDialog({ notes: textArea.value });
            });

            cancelBtn.addEventListener('click', (event) => {
                event.preventDefault();
                closeDialog(null);
            });

            closeBtn.addEventListener('click', (event) => {
                event.preventDefault();
                closeDialog(null);
            });

            openNotesDialog = (serverName, notesValue = '') => {
                serverLabel.textContent = serverName;
                textArea.value = notesValue || '';
                initialValue = notesValue || '';
                notesDirty = false;
                modal.showModal();
                return new Promise((resolve) => {
                    resolver = resolve;
                    requestAnimationFrame(() => {
                        textArea.focus();
                        textArea.setSelectionRange(textArea.value.length, textArea.value.length);
                        textArea.addEventListener('input', markDirty);
                        document.addEventListener('keydown', onKeyDown);
                    });
                });
            };
        }

        function initEditHostDialog() {
            const modal = document.getElementById('edit-host-modal');
            const form = document.getElementById('edit-host-modal-form');
            const serverLabel = document.getElementById('edit-host-modal-server');
            const notesInput = document.getElementById('edit-host-notes');
            const groupSelect = document.getElementById('edit-host-group');
            const osSelect = document.getElementById('edit-host-os');
            const servicesTextarea = document.getElementById('edit-host-services');
            const cancelBtn = document.getElementById('edit-host-modal-cancel');
            const closeBtn = document.getElementById('edit-host-modal-close');
            const deleteBtn = document.getElementById('edit-host-modal-delete');
            const browseServicesBtn = document.getElementById('edit-host-browse-services');

            if (!modal || !form || !serverLabel || !notesInput || !groupSelect || !osSelect || !servicesTextarea || !cancelBtn || !closeBtn) {
                console.warn('[initEditHostDialog] Missing modal elements');
                return;
            }

            let resolver = null;
            let initialSnapshot = null;

            // Update browse services button state based on OS
            const updateBrowseServicesBtn = () => {
                if (!browseServicesBtn) return;
                const isWindows = osSelect.value === 'Windows';
                browseServicesBtn.disabled = !isWindows;
                browseServicesBtn.title = isWindows
                    ? 'Browse services on this host'
                    : 'Service browsing is only available for Windows hosts';
            };

            const captureSnapshot = () => ({
                notes: notesInput.value || '',
                group: groupSelect.value || '',
                os: osSelect.value || 'Windows',
                services: servicesTextarea.value || ''
            });

            const markDirty = () => {
                const current = captureSnapshot();
                editHostDirty = JSON.stringify(current) !== JSON.stringify(initialSnapshot);
            };

            const clearDirty = () => {
                editHostDirty = false;
                initialSnapshot = captureSnapshot();
            };

            const closeDialog = async (result = null) => {
                // Check for unsaved changes before closing
                if (result === null && editHostDirty) {
                    const confirmed = await showConfirmDialog(
                        'Discard unsaved changes?',
                        { title: 'Unsaved Changes', okText: 'Discard', okClass: 'btn-warning' }
                    );
                    if (!confirmed) return;
                }

                modal.close();
                document.removeEventListener('keydown', onKeyDown);
                notesInput.removeEventListener('input', markDirty);
                groupSelect.removeEventListener('change', markDirty);
                osSelect.removeEventListener('change', markDirty);
                servicesTextarea.removeEventListener('input', markDirty);
                const currentResolver = resolver;
                resolver = null;
                notesInput.value = '';
                groupSelect.value = '';
                osSelect.value = 'Windows';
                servicesTextarea.value = '';
                editHostDirty = false;
                initialSnapshot = null;
                if (currentResolver) {
                    currentResolver(result);
                }
            };

            const onKeyDown = (event) => {
                if (event.key === 'Escape') {
                    event.preventDefault();
                    closeDialog(null);
                }
            };

            form.addEventListener('submit', (event) => {
                event.preventDefault();
                const data = captureSnapshot();
                closeDialog(data);
            });

            cancelBtn.addEventListener('click', (event) => {
                event.preventDefault();
                closeDialog(null);
            });

            closeBtn.addEventListener('click', (event) => {
                event.preventDefault();
                closeDialog(null);
            });

            // Delete button handler
            if (deleteBtn) {
                deleteBtn.addEventListener('click', async (event) => {
                    event.preventDefault();
                    if (!editHostServerName) return;

                    const confirmed = await showConfirmDialog(
                        `Are you sure you want to delete host "${editHostServerName}"? This action cannot be undone.`,
                        { title: 'Delete Host', okText: 'Delete', okClass: 'btn-error' }
                    );
                    if (!confirmed) return;

                    // Close dialog and return delete action
                    closeDialog({ action: 'delete', serverName: editHostServerName });
                });
            }

            // Browse services button handler
            if (browseServicesBtn) {
                browseServicesBtn.addEventListener('click', (event) => {
                    event.preventDefault();
                    if (!editHostServerName || osSelect.value !== 'Windows') return;
                    openEditServiceBrowser(editHostServerName, servicesTextarea);
                });
            }

            // Update browse button when OS changes
            osSelect.addEventListener('change', updateBrowseServicesBtn);

            // Populate groups dropdown from current server data
            const populateGroups = () => {
                const existingGroups = new Set();
                serversData.forEach(s => {
                    const g = (s.group || s.box || '').trim();
                    if (g) existingGroups.add(g);
                });

                // Clear existing options except first "(No Group)"
                while (groupSelect.options.length > 1) {
                    groupSelect.remove(1);
                }

                // Add groups alphabetically
                Array.from(existingGroups).sort((a, b) => a.localeCompare(b)).forEach(g => {
                    const opt = document.createElement('option');
                    opt.value = g;
                    opt.textContent = g;
                    groupSelect.appendChild(opt);
                });
            };

            openEditHostDialog = (serverName, currentData = {}) => {
                // Track the server being edited
                editHostServerName = serverName;

                serverLabel.textContent = serverName;
                notesInput.value = currentData.notes || '';
                osSelect.value = currentData.os_type || currentData.os || 'Windows';
                servicesTextarea.value = Array.isArray(currentData.services)
                    ? currentData.services.join('; ')
                    : (currentData.services || '');

                // Update browse services button state
                updateBrowseServicesBtn();

                // Populate groups and select current
                populateGroups();
                const currentGroup = (currentData.group || currentData.box || '').trim();
                groupSelect.value = currentGroup;

                // If current group doesn't exist in dropdown, add it
                if (currentGroup && !Array.from(groupSelect.options).some(o => o.value === currentGroup)) {
                    const opt = document.createElement('option');
                    opt.value = currentGroup;
                    opt.textContent = currentGroup;
                    groupSelect.appendChild(opt);
                    groupSelect.value = currentGroup;
                }

                initialSnapshot = captureSnapshot();
                editHostDirty = false;

                modal.showModal();
                return new Promise((resolve) => {
                    resolver = resolve;
                    requestAnimationFrame(() => {
                        notesInput.focus();
                        notesInput.addEventListener('input', markDirty);
                        groupSelect.addEventListener('change', markDirty);
                        osSelect.addEventListener('change', markDirty);
                        servicesTextarea.addEventListener('input', markDirty);
                        document.addEventListener('keydown', onKeyDown);
                    });
                });
            };
        }

        // ========== Service Browser Functions (for Edit Host Modal) ==========

        function initEditServiceBrowser() {
            const modal = document.getElementById('edit-service-browser-modal');
            const closeBtn = document.getElementById('edit-service-browser-close');
            const cancelBtn = document.getElementById('edit-service-browser-cancel');
            const addBtn = document.getElementById('edit-service-browser-add');
            const searchInput = document.getElementById('edit-service-browser-search');
            const statusFilter = document.getElementById('edit-service-browser-status-filter');
            const selectVisibleBtn = document.getElementById('edit-service-browser-select-visible');
            const deselectAllBtn = document.getElementById('edit-service-browser-deselect-all');
            const thead = document.querySelector('#edit-service-browser-modal thead');

            if (!modal) return;

            if (closeBtn) {
                closeBtn.addEventListener('click', closeEditServiceBrowser);
            }
            if (cancelBtn) {
                cancelBtn.addEventListener('click', closeEditServiceBrowser);
            }
            if (addBtn) {
                addBtn.addEventListener('click', addEditSelectedServices);
            }
            if (searchInput) {
                searchInput.addEventListener('input', debounce(renderEditServiceBrowserTable, 150));
            }
            if (statusFilter) {
                statusFilter.addEventListener('change', renderEditServiceBrowserTable);
            }
            if (selectVisibleBtn) {
                selectVisibleBtn.addEventListener('click', selectEditVisibleServices);
            }
            if (deselectAllBtn) {
                deselectAllBtn.addEventListener('click', deselectEditAllServices);
            }
            if (thead) {
                thead.addEventListener('click', (e) => {
                    const th = e.target.closest('th[data-sort]');
                    if (!th) return;
                    const key = th.dataset.sort;
                    if (editServiceBrowserSortKey === key) {
                        editServiceBrowserSortAsc = !editServiceBrowserSortAsc;
                    } else {
                        editServiceBrowserSortKey = key;
                        editServiceBrowserSortAsc = true;
                    }
                    renderEditServiceBrowserTable();
                });
            }
        }

        // Reference to the services textarea in the edit modal
        let editServiceBrowserTextarea = null;

        async function openEditServiceBrowser(serverName, textarea) {
            if (editServiceBrowserBusy) return;

            if (!serverName) {
                showError('Server name is required to browse services');
                return;
            }

            editServiceBrowserTextarea = textarea;

            const modal = document.getElementById('edit-service-browser-modal');
            const hostSpan = document.getElementById('edit-service-browser-host');
            const loadingDiv = document.getElementById('edit-service-browser-loading');
            const contentDiv = document.getElementById('edit-service-browser-content');
            const messageDiv = document.getElementById('edit-service-browser-message');
            const addBtn = document.getElementById('edit-service-browser-add');

            if (!modal) return;

            // Reset state
            editServiceBrowserData = [];
            editServiceBrowserSelected = new Set();
            editServiceBrowserSortKey = 'name';
            editServiceBrowserSortAsc = true;

            // Pre-select currently configured services
            const currentServices = parseEditServicesText(textarea?.value || '');
            currentServices.forEach(svc => editServiceBrowserSelected.add(svc.toLowerCase()));

            // Reset UI
            hostSpan.textContent = serverName;
            messageDiv.className = 'alert hidden mb-3';
            messageDiv.textContent = '';
            loadingDiv.classList.remove('hidden');
            contentDiv.classList.add('hidden');
            addBtn.disabled = true;

            // Reset filters
            const searchInput = document.getElementById('edit-service-browser-search');
            const statusFilterEl = document.getElementById('edit-service-browser-status-filter');
            if (searchInput) searchInput.value = '';
            if (statusFilterEl) statusFilterEl.value = '';

            // Show modal
            modal.showModal();
            editServiceBrowserBusy = true;

            try {
                if (!window.__TAURI__) {
                    throw new Error('Tauri API not available');
                }
                const { invoke } = window.__TAURI__.core;
                const services = await invoke('get_remote_services', { serverName });
                editServiceBrowserData = services || [];

                loadingDiv.classList.add('hidden');
                contentDiv.classList.remove('hidden');

                renderEditServiceBrowserTable();
                updateEditServiceBrowserCounts();

                if (editServiceBrowserData.length === 0) {
                    showEditServiceBrowserMessage('warning', 'No services found on this host');
                }
            } catch (err) {
                loadingDiv.classList.add('hidden');
                showEditServiceBrowserMessage('error', `Failed to retrieve services: ${err}`);
            } finally {
                editServiceBrowserBusy = false;
            }
        }

        function closeEditServiceBrowser() {
            const modal = document.getElementById('edit-service-browser-modal');
            if (modal) {
                modal.close();
            }
            editServiceBrowserBusy = false;
            editServiceBrowserTextarea = null;
        }

        function showEditServiceBrowserMessage(type, message) {
            const messageDiv = document.getElementById('edit-service-browser-message');
            if (!messageDiv) return;

            messageDiv.className = `alert mb-3 alert-${type === 'error' ? 'error' : type === 'warning' ? 'warning' : 'info'}`;
            messageDiv.textContent = message;
        }

        function getEditFilteredSortedServices() {
            const searchInput = document.getElementById('edit-service-browser-search');
            const statusFilterEl = document.getElementById('edit-service-browser-status-filter');
            const searchTermVal = (searchInput?.value || '').toLowerCase().trim();
            const statusFilterValue = statusFilterEl?.value || '';

            let filtered = editServiceBrowserData;

            // Apply search filter
            if (searchTermVal) {
                filtered = filtered.filter(svc =>
                    svc.name.toLowerCase().includes(searchTermVal) ||
                    svc.display_name.toLowerCase().includes(searchTermVal)
                );
            }

            // Apply status filter
            if (statusFilterValue) {
                filtered = filtered.filter(svc => svc.status === statusFilterValue);
            }

            // Sort
            filtered.sort((a, b) => {
                let aVal = a[editServiceBrowserSortKey] || '';
                let bVal = b[editServiceBrowserSortKey] || '';
                if (typeof aVal === 'string') aVal = aVal.toLowerCase();
                if (typeof bVal === 'string') bVal = bVal.toLowerCase();

                if (aVal < bVal) return editServiceBrowserSortAsc ? -1 : 1;
                if (aVal > bVal) return editServiceBrowserSortAsc ? 1 : -1;
                return 0;
            });

            return filtered;
        }

        function renderEditServiceBrowserTable() {
            const tbody = document.getElementById('edit-service-browser-tbody');
            if (!tbody) return;

            const filtered = getEditFilteredSortedServices();

            // Update sort indicators
            document.querySelectorAll('#edit-service-browser-modal th[data-sort]').forEach(th => {
                const indicator = th.querySelector('.sort-indicator');
                if (th.dataset.sort === editServiceBrowserSortKey) {
                    indicator.textContent = editServiceBrowserSortAsc ? ' ‚ñ≤' : ' ‚ñº';
                } else {
                    indicator.textContent = '';
                }
            });

            // Update count display
            document.getElementById('edit-service-browser-count').textContent = filtered.length;

            if (filtered.length === 0) {
                tbody.innerHTML = `<tr><td colspan="6" class="text-center text-base-content/60 py-8">No services match your filters</td></tr>`;
                return;
            }

            tbody.innerHTML = filtered.map(svc => {
                const isSelected = editServiceBrowserSelected.has(svc.name.toLowerCase());
                const statusClass = svc.status === 'Running' ? 'badge-success' : 'badge-error';
                const startupClass = svc.startup_type === 'Automatic' ? 'text-success' : '';

                return `
                    <tr class="hover cursor-pointer ${isSelected ? 'bg-primary/10' : ''}" data-service="${escapeHtml(svc.name)}">
                        <td class="text-center">
                            <input type="checkbox" class="checkbox checkbox-sm checkbox-primary edit-service-checkbox"
                                   ${isSelected ? 'checked' : ''} data-service="${escapeHtml(svc.name)}">
                        </td>
                        <td class="font-mono text-sm">${escapeHtml(svc.name)}</td>
                        <td>${escapeHtml(svc.display_name)}</td>
                        <td><span class="badge badge-sm ${statusClass}">${escapeHtml(svc.status)}</span></td>
                        <td class="${startupClass}">${escapeHtml(svc.startup_type)}</td>
                        <td class="text-sm text-base-content/80">${escapeHtml(svc.service_account || 'Unknown')}</td>
                    </tr>
                `;
            }).join('');

            // Add click handlers for rows and checkboxes
            tbody.querySelectorAll('tr[data-service]').forEach(row => {
                row.addEventListener('click', (e) => {
                    if (e.target.type === 'checkbox') return;
                    const serviceName = row.dataset.service;
                    toggleEditServiceSelection(serviceName);
                });
            });

            tbody.querySelectorAll('.edit-service-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', (e) => {
                    e.stopPropagation();
                    const serviceName = checkbox.dataset.service;
                    toggleEditServiceSelection(serviceName);
                });
            });

            updateEditServiceBrowserCounts();
        }

        function toggleEditServiceSelection(serviceName) {
            const key = serviceName.toLowerCase();
            if (editServiceBrowserSelected.has(key)) {
                editServiceBrowserSelected.delete(key);
            } else {
                editServiceBrowserSelected.add(key);
            }
            renderEditServiceBrowserTable();
            updateEditServiceBrowserCounts();
        }

        function selectEditVisibleServices() {
            const filtered = getEditFilteredSortedServices();
            filtered.forEach(svc => editServiceBrowserSelected.add(svc.name.toLowerCase()));
            renderEditServiceBrowserTable();
            updateEditServiceBrowserCounts();
        }

        function deselectEditAllServices() {
            editServiceBrowserSelected.clear();
            renderEditServiceBrowserTable();
            updateEditServiceBrowserCounts();
        }

        function updateEditServiceBrowserCounts() {
            const selectedCount = editServiceBrowserSelected.size;
            document.getElementById('edit-service-browser-selected-count').textContent = selectedCount;

            const addBtn = document.getElementById('edit-service-browser-add');
            if (addBtn) {
                addBtn.disabled = selectedCount === 0;
                addBtn.textContent = selectedCount > 0 ? `Add Selected (${selectedCount})` : 'Add Selected';
            }
        }

        function addEditSelectedServices() {
            if (editServiceBrowserSelected.size === 0) return;

            // Get the original service names (preserve case from data)
            const selectedNames = [];
            editServiceBrowserData.forEach(svc => {
                if (editServiceBrowserSelected.has(svc.name.toLowerCase())) {
                    selectedNames.push(svc.name);
                }
            });

            // Merge with existing services
            if (editServiceBrowserTextarea) {
                const current = parseEditServicesText(editServiceBrowserTextarea.value);
                const merged = mergeEditServices(current, selectedNames);
                editServiceBrowserTextarea.value = merged.join('; ');
                // Trigger input event to mark form as dirty
                editServiceBrowserTextarea.dispatchEvent(new Event('input', { bubbles: true }));
            }

            closeEditServiceBrowser();
            showInfo(`Added ${selectedNames.length} service(s) to monitoring list`);
        }

        function parseEditServicesText(value) {
            const seen = new Set();
            const items = [];
            (value || '').split(/;|,/).map(s => s.trim()).filter(Boolean).forEach(svc => {
                const key = svc.toLowerCase();
                if (!seen.has(key)) {
                    seen.add(key);
                    items.push(svc);
                }
            });
            return items;
        }

        function mergeEditServices(existing, incoming) {
            const seen = new Set(existing.map(s => s.toLowerCase()));
            const merged = [...existing];
            incoming.forEach(svc => {
                const key = (svc || '').toLowerCase();
                if (key && !seen.has(key)) {
                    seen.add(key);
                    merged.push(svc);
                }
            });
            return merged;
        }

        // ========== End Service Browser Functions ==========

        function initGroupRenameDialog() {
            const modal = document.getElementById('group-rename-modal');
            const form = document.getElementById('group-rename-form');
            const input = document.getElementById('group-rename-input');
            const currentLabel = document.getElementById('group-rename-current');
            const cancelBtn = document.getElementById('group-rename-cancel');
            const closeBtn = document.getElementById('group-rename-close');

            if (!modal || !form || !input || !currentLabel || !cancelBtn || !closeBtn) {
                return;
            }

            let resolver = null;
            let originalGroupName = '';

            const closeDialog = (result = null) => {
                // Clear resolver BEFORE closing to prevent close event from interfering
                const currentResolver = resolver;
                resolver = null;
                document.removeEventListener('keydown', onKeyDown);
                modal.close();
                modal.setAttribute('data-open', 'false');
                if (currentResolver) {
                    currentResolver(result);
                }
            };

            const onKeyDown = (event) => {
                if (event.key === 'Escape') {
                    event.preventDefault();
                    closeDialog(null);
                }
            };

            const wireClose = (el) => {
                el.addEventListener('click', (event) => {
                    event.preventDefault();
                    closeDialog(null);
                });
            };

            wireClose(cancelBtn);
            wireClose(closeBtn);

            // Handle native dialog cancel (Escape key fallback)
            modal.addEventListener('cancel', (event) => {
                event.preventDefault();
                closeDialog(null);
            });

            // Handle dialog close event as safety net
            modal.addEventListener('close', () => {
                if (resolver) {
                    const currentResolver = resolver;
                    resolver = null;
                    currentResolver(null);
                }
                document.removeEventListener('keydown', onKeyDown);
            });

            form.addEventListener('submit', (event) => {
                event.preventDefault();
                const value = input.value.trim();
                if (!value) {
                    input.focus();
                    return;
                }
                // Validate not renaming to same name (case-insensitive)
                if (value.toLowerCase() === originalGroupName.toLowerCase()) {
                    closeDialog(null);
                    return;
                }
                // Validate not using reserved names
                if (value.toLowerCase() === 'no group') {
                    showError('Cannot use "No Group" as a group name');
                    input.focus();
                    return;
                }
                closeDialog(value);
            });

            groupRenameDialog = {
                open: (groupName) => {
                    originalGroupName = groupName || '';
                    currentLabel.textContent = groupName || 'No Group';
                    input.value = groupName || '';
                    modal.showModal();
                    modal.setAttribute('data-open', 'true');
                    return new Promise((resolve) => {
                        resolver = resolve;
                        requestAnimationFrame(() => {
                            input.focus();
                            input.select();
                            document.addEventListener('keydown', onKeyDown);
                        });
                    });
                },
                close: closeDialog
            };

            openGroupRenameDialog = (groupName) => groupRenameDialog.open(groupName);
        }

        function initErrorDialog() {
            const modal = document.getElementById('error-modal');
            const serverLabel = document.getElementById('error-server');
            const messageBox = document.getElementById('error-message');
            const closeBtn = document.getElementById('error-close');
            const dismissBtn = document.getElementById('error-dismiss');

            if (!modal || !serverLabel || !messageBox || !closeBtn || !dismissBtn) {
                return;
            }

            let resolver = null;

            const closeDialog = () => {
                modal.close();
                document.removeEventListener('keydown', onKeyDown);
                const currentResolver = resolver;
                resolver = null;
                if (currentResolver) {
                    currentResolver();
                }
            };

            const onKeyDown = (event) => {
                if (event.key === 'Escape') {
                    event.preventDefault();
                    closeDialog();
                }
            };

            const wireClose = (el) => {
                el.addEventListener('click', (event) => {
                    event.preventDefault();
                    closeDialog();
                });
            };

            wireClose(closeBtn);
            wireClose(dismissBtn);

            openErrorDialog = (serverName, message) => {
                serverLabel.textContent = serverName || 'Unknown';
                const detail = (message && message.toString().trim()) ? message.toString() : 'No details available.';
                // Update the message inside code/pre tags
                const codeElement = messageBox.querySelector('code');
                if (codeElement) {
                    codeElement.textContent = detail;
                } else {
                    messageBox.textContent = detail;
                }
                modal.showModal();
                return new Promise((resolve) => {
                    resolver = resolve;
                    requestAnimationFrame(() => {
                        closeBtn.focus();
                        document.addEventListener('keydown', onKeyDown);
                    });
                });
            };
        }

        function renderDetailsSection(title, lines) {
            if (!lines || !lines.length) return '';
            return `
                <div class="details-section">
                    <h4>${escapeHtml(title)}</h4>
                    ${lines.map(l => `<div class="line">${highlightMatch(l, searchTerm)}</div>`).join('')}
                </div>
            `;
        }

        function initDetailsDialog() {
            const modal = document.getElementById('details-modal');
            const content = document.getElementById('details-content');
            const closeBtn = document.getElementById('details-close');
            const dismissBtn = document.getElementById('details-dismiss');

            if (!modal || !content || !closeBtn || !dismissBtn) {
                openDetailsDialog = null;
                return;
            }

            let resolver = null;

            const closeDialog = () => {
                modal.close();
                document.removeEventListener('keydown', onKeyDown);
                content.innerHTML = '';
                if (resolver) {
                    resolver();
                    resolver = null;
                }
            };

            const onKeyDown = (event) => {
                if (event.key === 'Escape') {
                    event.preventDefault();
                    closeDialog();
                }
            };

            const wireClose = (el) => {
                el.addEventListener('click', (event) => {
                    event.preventDefault();
                    closeDialog();
                });
            };

            wireClose(closeBtn);
            wireClose(dismissBtn);

            openDetailsDialog = (server) => {
                const data = server?.data || {};
                const heartbeat = server?.heartbeat || {};
                const listeners = Array.isArray(data.winrm_listeners) ? data.winrm_listeners : [];
                const firewall = Array.isArray(data.firewall_profiles) ? data.firewall_profiles : [];
                const adapters = Array.isArray(data.net_adapters) ? data.net_adapters : [];
                const errors = Array.isArray(data.recent_errors) ? data.recent_errors.slice(0, 8) : [];
                const pendingSignals = Array.isArray(data.pending_reboot?.signals) ? data.pending_reboot.signals : [];

                const listenerLines = listeners.length ? listeners.map(l => {
                    const host = l.hostname ? ` (${l.hostname})` : '';
                    return `${l.transport || ''} ${l.address || ''}:${l.port || ''}${host}`.trim();
                }) : ['No WinRM listeners returned'];

                const firewallLines = firewall.length ? firewall.map(p => {
                    const enabled = String(p.enabled).toLowerCase() === 'true' ? 'Enabled' : 'Disabled';
                    return `${p.name}: In ${p.default_inbound_action} / Out ${p.default_outbound_action} (${enabled})`;
                }) : ['No firewall profiles returned'];

                const adapterLines = adapters.length ? adapters.map(a => {
                    const ips = [...(a.ipv4 || []), ...(a.ipv6 || [])].filter(Boolean).join(', ');
                    const dns = (a.dns || []).filter(Boolean).join(', ');
                    const parts = [];
                    parts.push(a.alias || a.description || 'Adapter');
                    if (ips) parts.push(`IPs: ${ips}`);
                    if (dns) parts.push(`DNS: ${dns}`);
                    return parts.join(' ‚Ä¢ ');
                }) : ['No network adapters returned'];

                const serviceList = Array.isArray(data.service_status)
                    ? data.service_status
                    : (data.service_status ? [data.service_status] : []);
                const serviceLines = serviceList.length
                    ? serviceList.map(s => `${s.name || 'Service'}: ${s.status || 'Unknown'}`)
                    : ['No service status returned'];

                const errorLines = errors.length ? errors.map(e => {
                    const when = formatTimestamp(e.time_created);
                    return `${e.log || 'Log'} ${e.id || ''} ${e.provider || ''} @ ${when} ‚Äî ${e.message || ''}`;
                }) : ['No recent errors'];

                const pendingLines = pendingSignals.length ? pendingSignals : (data.pending_reboot?.pending ? ['Reboot signals detected'] : ['No reboot signals']);

                const diskLines = Array.isArray(data.disks) && data.disks.length ? data.disks.map(d => {
                    const pct = d.percent_free ? Math.round(d.percent_free * 10) / 10 : 0;
                    return `${d.drive || ''} - ${d.free_gb?.toFixed ? d.free_gb.toFixed(1) : d.free_gb || ''} GB free of ${d.total_gb?.toFixed ? d.total_gb.toFixed(1) : d.total_gb || ''} GB (${pct}% free)`;
                }) : ['No disk data returned'];

                const osInfo = data.os_info || {};
                const systemLines = [
                    osInfo.os_version ? `OS: ${osInfo.os_version}` : null,
                    osInfo.product_type ? `Product: ${osInfo.product_type}` : null,
                    osInfo.computer_name ? `Computer Name: ${osInfo.computer_name}` : null,
                ].filter(Boolean);

                const uptimeValue = typeof data.uptime?.uptime_hours === 'number' ? data.uptime.uptime_hours
                    : (typeof heartbeat.uptime_hours === 'number' ? heartbeat.uptime_hours : null);
                const cpuValue = typeof data.uptime?.cpu_load_pct === 'number' ? data.uptime.cpu_load_pct
                    : (typeof heartbeat.cpu_load_pct === 'number' ? heartbeat.cpu_load_pct : null);
                const memPercent = typeof data.memory_used_percent === 'number' ? data.memory_used_percent
                    : (typeof heartbeat.memory_used_percent === 'number' ? heartbeat.memory_used_percent : null);
                const processCount = typeof data.process_count === 'number' ? data.process_count : null;
                const totalMemMb = typeof data.total_memory_mb === 'number' ? data.total_memory_mb : null;
                const usedMemMb = typeof data.used_memory_mb === 'number' ? data.used_memory_mb : null;
                const totalMemGb = Number.isFinite(totalMemMb) ? Math.round((totalMemMb / 1024) * 10) / 10 : null;
                const usedMemGb = Number.isFinite(usedMemMb) ? Math.round((usedMemMb / 1024) * 10) / 10 : null;

                const uptimeCpuLines = [];
                if (Number.isFinite(uptimeValue)) uptimeCpuLines.push(`Uptime: ${humanizeUptime(uptimeValue)}`);
                if (Number.isFinite(cpuValue)) uptimeCpuLines.push(`CPU Load: ${Math.round(cpuValue)}%`);
                if (Number.isFinite(memPercent)) {
                    const memLine = Number.isFinite(usedMemGb) && Number.isFinite(totalMemGb)
                        ? `Memory Used: ${Math.round(memPercent)}% (${usedMemGb} GB of ${totalMemGb} GB)`
                        : `Memory Used: ${Math.round(memPercent)}%`;
                    uptimeCpuLines.push(memLine);
                }
                if (Number.isFinite(processCount)) uptimeCpuLines.push(`Processes: ${processCount}`);
                if (Array.isArray(data.high_cpu_processes) && data.high_cpu_processes.length) {
                    uptimeCpuLines.push('High CPU Processes:');
                    data.high_cpu_processes.forEach(p => {
                        const pct = typeof p.cpu_percent === 'number' ? `${p.cpu_percent}%` : 'n/a';
                        uptimeCpuLines.push(` ‚Ä¢ ${p.name || 'Process'} (${pct})`);
                    });
                }

                const winrmErrorRaw = heartbeat?.winrm_error?.toString?.() || (data.winrm_error ? data.winrm_error.toString() : '');
                const winrmErrorLine = winrmErrorRaw ? [`WinRM Error: ${winrmErrorRaw}`] : ['No WinRM errors reported'];

                content.innerHTML = [
                    renderDetailsSection('System', systemLines.length ? systemLines : ['No OS info returned']),
                    renderDetailsSection('Uptime / CPU / Memory', uptimeCpuLines.length ? uptimeCpuLines : ['No uptime/CPU data']),
                    renderDetailsSection('WinRM Listeners', listenerLines),
                    renderDetailsSection('Firewall Profiles', firewallLines),
                    renderDetailsSection('Network Adapters', adapterLines),
                    renderDetailsSection('Services', serviceLines),
                    renderDetailsSection('Disks', diskLines),
                    renderDetailsSection('Pending Reboot Signals', pendingLines),
                    renderDetailsSection('Recent Errors (last 30m)', errorLines),
                    renderDetailsSection('WinRM Errors', winrmErrorLine),
                ].filter(Boolean).join('') || '<div class="details-section"><div class="line">No additional details available.</div></div>';

                const titleEl = document.getElementById('details-title');
                if (titleEl) {
                    titleEl.textContent = `Details ‚Äì ${server.name}`;
                }

                modal.showModal();
                return new Promise((resolve) => {
                    resolver = resolve;
                    requestAnimationFrame(() => {
                        closeBtn.focus();
                        document.addEventListener('keydown', onKeyDown);
                    });
                });
            };
        }

        function initHostPreviewModal() {
            const modal = document.getElementById('host-preview-modal');
            const body = document.getElementById('host-preview-body');
            const closeBtn = document.getElementById('host-preview-close');
            const titleEl = document.getElementById('host-preview-title');

            if (!modal || !body || !closeBtn) {
                openHostPreview = null;
                return;
            }

            const closeDialog = () => {
                modal.close();
                body.innerHTML = '';
                document.removeEventListener('keydown', onKeyDown);
            };

            const onKeyDown = (event) => {
                if (event.key === 'Escape') {
                    event.preventDefault();
                    closeDialog();
                }
            };

            closeBtn.addEventListener('click', (event) => {
                event.preventDefault();
                closeDialog();
            });

            openHostPreview = (serverName) => {
                const server = serversData.find(s => s.name === serverName);
                if (!server) {
                    showError(`Server ${serverName} not found in current view.`);
                    return;
                }

                body.innerHTML = '';
                const card = createServerCard(server, { preview: false });
                body.appendChild(card);
                if (titleEl) {
                    titleEl.textContent = serverName;
                }

                modal.showModal();
                requestAnimationFrame(() => {
                    closeBtn.focus();
                    document.addEventListener('keydown', onKeyDown);
                });
            };
        }

        async function fetchNormalizedHosts() {
            const start = Date.now();
            logDebug('dashboard:fetchNormalizedHosts START');

            if (!window.__TAURI__ || !window.__TAURI__.core) {
                return { hosts: [], signature: null };
            }
            const { invoke } = window.__TAURI__.core;
            const hostsRaw = await invoke('get_hosts');
            const hosts = Utils.dedupeNormalizedServers(
                (hostsRaw || []).map(normalizeServerRecord).filter(Boolean)
            );
            hostsByName = new Map(hosts.map(h => [h.name, h]));

            const elapsed = Date.now() - start;
            const groupsCount = new Set(hosts.filter(h => h.group).map(h => h.group)).size;
            logDebug(`dashboard:fetchNormalizedHosts SUCCESS ${elapsed}ms hosts=${hosts.length} groups=${groupsCount}`);

            return {
                hosts,
                signature: computeHostsSignature(hosts)
            };
        }

        async function hydrateServerWithHealth(serverInfo, invoke) {
            const groupValue = serverInfo.group || serverInfo.box || '';
            // Look up existing data from both serversData AND persistedHealthMap
            // This ensures we preserve valid data even when WinRM fails and returns "Unknown" values
            const existingFromServers = serversData.find((s) => s.name === serverInfo.name);
            const persistedKey = serverInfo.name.toLowerCase();
            const persistedSnapshot = persistedHealthMap?.get(persistedKey);
            // Merge: prefer serversData (more recent), but fall back to persisted data
            const existingData = existingFromServers?.data && Object.keys(existingFromServers.data).length > 0
                ? existingFromServers.data
                : persistedSnapshot?.data;
            const existing = existingFromServers || (persistedSnapshot ? { data: persistedSnapshot.data, location: persistedSnapshot.data?._location } : null);
            const osType = Utils?.normalizeOsType
                ? Utils.normalizeOsType(serverInfo.os_type || serverInfo.os || serverInfo.osType)
                : 'Windows';
            const fetchAdapters = async () => {
                try {
                    const debugAdapters = await withTimeout(
                        invoke('fetch_net_adapters', { serverName: serverInfo.name }),
                        15000,
                        `fetch_net_adapters ${serverInfo.name}`
                    );
                    if (debugAdapters && Array.isArray(debugAdapters.adapters) && debugAdapters.adapters.length > 0) {
                        return debugAdapters.adapters;
                    }
                } catch (dbgErr) {
                    // Swallow; we‚Äôll fall back to existing adapters if present.
                }
                return null;
            };
            try {
                const criticalServices = Array.isArray(serverInfo.services) && serverInfo.services.length > 0
                    ? serverInfo.services
                    : null;

                const healthData = await withTimeout(
                    invoke('get_system_health', {
                        serverName: serverInfo.name,
                        diskThreshold: 10.0,
                        criticalServices,
                        tcpPorts: settings?.tcpPorts || null
                    }),
                    getProbeTimeoutMs(),
                    `get_system_health ${serverInfo.name}`
                );
                if (!healthData.net_adapters || (Array.isArray(healthData.net_adapters) && healthData.net_adapters.length === 0)) {
                    const adapters = await fetchAdapters();
                    if (adapters) {
                        healthData.net_adapters = adapters;
                    }
                }
                let normalizedAdapters = Array.isArray(healthData.net_adapters) ? healthData.net_adapters : [];
                if ((!normalizedAdapters || normalizedAdapters.length === 0) && existingData?.net_adapters?.length) {
                    normalizedAdapters = existingData.net_adapters;
                }
                if ((!normalizedAdapters || normalizedAdapters.length === 0)) {
                    const adapters = await fetchAdapters();
                    if (adapters) {
                        normalizedAdapters = adapters;
                    }
                }
                let mergedData = mergeHealthData(existingData, { ...healthData, net_adapters: normalizedAdapters });
                const needsOsInfo = !isMeaningfulString(mergedData?.os_info?.os_version) || !isMeaningfulString(mergedData?.os_info?.hostname);
                if (needsOsInfo) {
                    try {
                        const osInfo = await withTimeout(
                            invoke('fetch_os_info', { serverName: serverInfo.name }),
                            getProbeTimeoutMs(),
                            `fetch_os_info ${serverInfo.name}`
                        );
                        mergedData = mergeHealthData(mergedData, { os_info: osInfo });
                    } catch (osErr) {
                        if (console?.warn) {
                            console.warn(`[os-info] failed for ${serverInfo.name}`, osErr);
                        }
                    }
                }

                const hasAdapters = Array.isArray(mergedData.net_adapters) && mergedData.net_adapters.length > 0;
                const fallbackLocation = hasAdapters ? null : (locationMatchers.length ? existing?.location : null);
                const location = deriveLocationFromAdapters(mergedData.net_adapters, fallbackLocation);

                // Persist to database - AWAIT to ensure cache/DB sync
                if (window.__TAURI__?.core?.invoke) {
                    const snapshotData = {
                        ...mergedData,
                        _location: location  // Store computed location in snapshot
                    };
                    try {
                        await window.__TAURI__.core.invoke('persist_health_snapshot', {
                            serverName: serverInfo.name,
                            healthData: snapshotData
                        });
                        // Update in-memory map so subsequent mergeHealthIntoServers calls use latest data
                        updatePersistedHealthMap(serverInfo.name, snapshotData);
                    } catch (err) {
                        console.error(`[FullRefresh] ${serverInfo.name}: Failed to persist to database:`, err);
                        // Continue despite DB error - cache will still be updated
                    }
                }

                return {
                    name: serverInfo.name,
                    notes: serverInfo.notes,
                    group: groupValue,
                    box: groupValue,
                    services: serverInfo.services,
                    os_type: osType,
                    online: true,
                    data: mergedData,
                    location,
                    lastRefreshed: new Date().toISOString()
                };
            } catch (error) {
                if (window.__TAURI__?.core?.invoke && error?.message?.includes('Timeout')) {
                    window.__TAURI__.core.invoke('log_warn', {
                        message: `Probe timeout: ${serverInfo.name} (full_refresh) after ${getProbeTimeoutMs()}ms - ${error.message || error}`
                    }).catch(() => { }); // Silent fail if logging unavailable
                }
                const fallbackLocation = locationMatchers.length ? existing?.location : null;
                // Use existingData which includes persisted health as fallback
                const preservedData = existingData ? { ...existingData } : undefined;
                return {
                    name: serverInfo.name,
                    notes: serverInfo.notes,
                    group: groupValue,
                    box: groupValue,
                    services: serverInfo.services,
                    os_type: osType,
                    online: false,
                    error: error.toString(),
                    lastRefreshed: new Date().toISOString(),
                    location: fallbackLocation,
                    data: preservedData
                };
            }
        }

        function diffHostsAgainstCache(hosts) {
            const currentMap = new Map(
                serversData.map((server) => [server.name.toLowerCase(), server])
            );
            const unchanged = [];
            const changed = [];

            (hosts || []).forEach((host) => {
                const name = (host?.name || '').toLowerCase();
                if (!name) return;
                const existing = currentMap.get(name);
                if (
                    existing &&
                    servicesEqualNormalized(existing.services, host.services) &&
                    ((existing.notes || '').trim() === (host?.notes || '').trim()) &&
                    (((existing.group || existing.box || '').trim()) === ((host?.group || host?.box || '').trim()))
                ) {
                    unchanged.push(existing);
                } else {
                    changed.push({
                        ...host,
                        location: existing?.location
                    });
                }
                currentMap.delete(name);
            });

            const removed = Array.from(currentMap.keys());
            return { unchanged, changed, removed };
        }

        async function refreshHostsDiff(hostsPayload) {
            const { hosts, signature } = hostsPayload || {};
            hostsSignature = signature || computeHostsSignature(hosts || []);
            if (!Array.isArray(hosts) || hosts.length === 0) {
                cacheDashboardData();
                clearDashboardForNoHosts('No Hosts Found');
                return;
            }

            const hostDiff = diffHostsAgainstCache(hosts);
            const needsAdapterRefresh = (server) =>
                !server?.data ||
                !Array.isArray(server.data.net_adapters) ||
                server.data.net_adapters.length === 0;

            const refreshList = [
                ...hostDiff.changed,
                ...hostDiff.unchanged.filter(needsAdapterRefresh)
            ];
            const refreshCount = refreshList.length;

            let refreshed = [];
            if (refreshCount > 0) {
                const { invoke } = window.__TAURI__.core;
                refreshed = await mapWithConcurrency(
                    refreshList,
                    Math.min(MAX_CONCURRENT_PROBES, Math.max(1, refreshCount)),
                    (serverInfo) => hydrateServerWithHealth(serverInfo, invoke)
                );
            }

            const removedSet = new Set((hostDiff.removed || []).map((n) => n.toLowerCase()));
            const refreshedNames = new Set(refreshed.map((s) => (s.name || '').toLowerCase()));
            const merged = [
                ...hostDiff.unchanged
                    .filter((server) => !removedSet.has((server.name || '').toLowerCase()))
                    .filter((server) => !refreshedNames.has((server.name || '').toLowerCase())),
                ...refreshed
            ];

            serversData = applyOrder(merged, parseServerOrder());
            // Ensure all servers have locations applied (preserve existing, calculate for new)
            serversData = serversData.map(server => applyLocationToServer(server, false));
            heartbeatHosts = hosts;
            hostsSignature = signature || computeHostsSignature(hosts);
            cacheDashboardData();
            displayAllServers();
            startHeartbeatLoop(heartbeatHosts);
        }

        async function loadAllServers(options = {}) {
            const start = Date.now();
            const silent = options.silent === true;
            const preloadedHosts = options.preloadedHosts;
            const quickOnly = options.quickOnly === true;

            logDebug(`dashboard:loadAllServers START silent=${silent} quickOnly=${quickOnly}`);

            if (!window.__TAURI__) {
                showError('Tauri API not available. Run with "cargo tauri dev"');
                return;
            }

            const { invoke } = window.__TAURI__.core;

            // Don't show loading spinner for quick-only loads (they use snapshots and should be instant)
            if (!silent && !quickOnly) {
                showLoading();
            }
            hideError();
            hideLoadError();
            hideEmptyState();

            try {
                // Get list of hosts from CSV and normalize names
                const hostsResult = preloadedHosts && Array.isArray(preloadedHosts.hosts)
                    ? preloadedHosts
                    : await fetchNormalizedHosts();
                const hosts = hostsResult.hosts || [];
                hostsSignature = hostsResult.signature || computeHostsSignature(hosts);
                const order = parseServerOrder();

                // Create lookup map for existing server data to preserve it during reload
                // Use normalizeHostName for consistent key matching
                const existingServersMap = new Map(
                    serversData.map(s => [normalizeHostName(s.name), s])
                );

                const baseServers = applyOrder(
                    hosts.map((h) => {
                        // Preserve existing data from current serversData if available
                        const normalizedName = normalizeHostName(h.name);
                        const existing = existingServersMap.get(normalizedName);
                        const existingData = existing?.data;
                        const hasExistingData = existingData && Object.keys(existingData).length > 0;

                        // Warn only if we had meaningful data but it's not being preserved
                        const hadAdapters = existing?.data?.net_adapters?.length > 0;
                        if (hadAdapters && !hasExistingData) {
                            console.warn('[DATA-LOSS] loadAllServers: had adapters but hasExistingData=false for', h.name);
                        }

                        return {
                            ...h,
                            online: hasExistingData ? existing.online : true,
                            data: hasExistingData ? existingData : (h.data || {}),
                            error: hasExistingData ? existing.error : undefined,
                            lastRefreshed: hasExistingData ? existing.lastRefreshed : (h.lastRefreshed || null),
                            location: hasExistingData ? existing.location : undefined
                        };
                    }),
                    order
                ).map(server => applyLocationToServer(server, false));
                // Apply persisted health from database only for servers without existing data
                const serversWithHealth = mergeHealthIntoServers(baseServers, persistedHealthMap);
                serversData = serversWithHealth;
                cacheDashboardData();
                displayAllServers();

                if (!hosts || hosts.length === 0) {
                    stopHeartbeatLoop();
                    clearDashboardForNoHosts('No hosts configured yet.');
                    if (!silent) {
                        hideLoading();
                    }
                    return;
                }
                heartbeatHosts = hosts;

                // If quickOnly mode, skip full probes and just start heartbeat
                if (quickOnly) {
                    logDebug(`dashboard:loadAllServers QUICK_ONLY mode - skipping full probe`);
                    serversData = applyOrder(serversData, order);
                    cacheDashboardData();
                    displayAllServers();
                    startHeartbeatLoop(heartbeatHosts);
                    if (!silent) {
                        hideLoading();
                    }
                    return;
                }

                logDebug(`dashboard:loadAllServers PROBING ${hosts.length} hosts concurrency=${MAX_CONCURRENT_PROBES}`);

                // Query each server with bounded concurrency to avoid WinRM connection storms
                serversData = await mapWithConcurrency(
                    hosts,
                    MAX_CONCURRENT_PROBES,
                    (serverInfo) => hydrateServerWithHealth(serverInfo, invoke)
                );
                serversData = applyOrder(serversData, order);
                cacheDashboardData();
                displayAllServers();
                startHeartbeatLoop(heartbeatHosts);

                const elapsed = Date.now() - start;
                const online = serversData.filter(s => s.online).length;
                const offline = serversData.length - online;
                logDebug(`dashboard:loadAllServers SUCCESS ${elapsed}ms hosts=${serversData.length} online=${online} offline=${offline}`);

                if (!silent) {
                    setLastRefreshStatus('ok', 'Hosts refreshed');
                }
            } catch (error) {
                const elapsed = Date.now() - start;
                console.error('Failed to load servers', error);
                logDebug(`dashboard:loadAllServers FAILED ${elapsed}ms: ${error}`);
                const detail = error?.toString?.() || 'Unable to load hosts.';
                showLoadError(detail);
                cacheDashboardData();
            } finally {
                if (!silent) {
                    hideLoading();
                }
            }
        }

        function computeHeartbeatConcurrency(count) {
            if (!Number.isFinite(count) || count <= 0) return 5;
            return Math.min(20, Math.max(5, Math.ceil(count / 8)));
        }

        function stopHeartbeatLoop() {
            if (heartbeatTimer) {
                clearTimeout(heartbeatTimer);
                heartbeatTimer = null;
            }
        }

        function cleanupBeforeNavigate() {
            // Stop heartbeat loop
            stopHeartbeatLoop();
            // Reset flags to prevent any scheduled operations from running
            heartbeatInFlight = false;
            selfHealScheduled = false;
        }

        async function navigateToHosts() {
            cleanupBeforeNavigate();
            // Wait briefly for any in-flight operations to abort
            await new Promise(resolve => setTimeout(resolve, 100));
            window.location.href = 'hosts.html';
        }

        // Circuit breaker helper functions
        function getCircuitBreakerBackoff(consecutiveFailures) {
            if (consecutiveFailures < CIRCUIT_BREAKER_THRESHOLD) return 0;
            // Exponential backoff: 20s, 40s, 80s, 160s, max 180s
            const multiplier = Math.pow(2, consecutiveFailures - CIRCUIT_BREAKER_THRESHOLD);
            return Math.min(HEARTBEAT_INTERVAL_MS * multiplier, CIRCUIT_BREAKER_MAX_BACKOFF);
        }

        function updateCircuitBreakerOnSuccess(serverName) {
            const normalized = normalizeHostName(serverName);
            if (!normalized) return;

            const state = serverHealthState.get(normalized);
            if (state && state.consecutiveFailures > 0) {
                logDebug('Circuit breaker: server recovered', {
                    server: serverName,
                    previousFailures: state.consecutiveFailures
                });
            }
            // Reset on success
            serverHealthState.set(normalized, {
                consecutiveFailures: 0,
                lastFailureTime: null,
                circuitState: 'closed',
                nextProbeTime: Date.now()
            });
        }

        function updateCircuitBreakerOnFailure(serverName) {
            const normalized = normalizeHostName(serverName);
            if (!normalized) return;

            const now = Date.now();
            const state = serverHealthState.get(normalized) || { consecutiveFailures: 0 };
            const newFailureCount = state.consecutiveFailures + 1;
            const backoff = getCircuitBreakerBackoff(newFailureCount);

            const newState = {
                consecutiveFailures: newFailureCount,
                lastFailureTime: now,
                circuitState: newFailureCount >= CIRCUIT_BREAKER_THRESHOLD ? 'open' : 'closed',
                nextProbeTime: now + backoff
            };

            serverHealthState.set(normalized, newState);

            if (newState.circuitState === 'open') {
                logDebug('Circuit breaker: opened', {
                    server: serverName,
                    failures: newFailureCount,
                    backoffMs: backoff
                });
            }
        }

        function shouldSkipHeartbeat(serverName) {
            const normalized = normalizeHostName(serverName);
            if (!normalized) return false;

            const state = serverHealthState.get(normalized);
            if (!state || state.circuitState !== 'open') return false;

            const now = Date.now();
            if (now >= state.nextProbeTime) {
                // Time to retry - move to half-open state
                state.circuitState = 'half-open';
                serverHealthState.set(normalized, state);
                logDebug('Circuit breaker: half-open (attempting recovery)', { server: serverName });
                return false;
            }

            return true; // Skip this heartbeat
        }

        async function runHeartbeatOnce() {
            if (heartbeatInFlight) return;
            if (!window.__TAURI__) return;
            const hosts = Array.isArray(heartbeatHosts) ? heartbeatHosts : [];
            if (!hosts.length) return;

            heartbeatInFlight = true;
            const { invoke } = window.__TAURI__.core;
            try {
                await mapWithConcurrency(hosts, computeHeartbeatConcurrency(hosts.length), async (serverInfo) => {
                    const jitter = Math.random() * HEARTBEAT_JITTER_MS;
                    if (jitter > 0) {
                        await new Promise(resolve => setTimeout(resolve, jitter));
                    }

                    // Skip if server is being fully refreshed
                    const normalized = normalizeHostName(serverInfo.name);
                    if (normalized && fullRefreshMeta.get(normalized)?.inFlight) {
                        logDebug('Heartbeat skipped (full refresh in progress)', { server: serverInfo.name });
                        return;
                    }

                    // Circuit breaker: skip if server is in open circuit state
                    if (shouldSkipHeartbeat(serverInfo.name)) {
                        logDebug('Heartbeat skipped (circuit breaker open)', { server: serverInfo.name });
                        return;
                    }

                    const timeoutMs = getProbeTimeoutMs();
                    try {
                        const result = await withTimeout(
                            invoke('get_quick_status', {
                                serverName: serverInfo.name,
                                services: serverInfo.services || null,
                                tcpPorts: settings?.tcpPorts || null
                            }),
                            timeoutMs,
                            `get_quick_status ${serverInfo.name}`
                        );
                        applyHeartbeatUpdate(result);
                        // Circuit breaker: reset on success
                        updateCircuitBreakerOnSuccess(serverInfo.name);
                    } catch (err) {
                        if (window.__TAURI__?.core?.invoke && err?.message?.includes('Timeout')) {
                            window.__TAURI__.core.invoke('log_warn', {
                                message: `Probe timeout: ${serverInfo.name} (heartbeat) after ${timeoutMs}ms - ${err.message || err}`
                            }).catch(() => { }); // Silent fail if logging unavailable
                        }
                        applyHeartbeatUpdate({
                            server_name: serverInfo.name,
                            ping_ok: false,
                            winrm_ok: false,
                            winrm_error: err.toString()
                        });
                        // Circuit breaker: track consecutive failures
                        updateCircuitBreakerOnFailure(serverInfo.name);
                    }
                });
                cacheDashboardData();
                // Use debounced version to prevent DOM thrashing during background updates
                displayAllServersDebounced();
            } finally {
                heartbeatInFlight = false;
            }
        }

        function startHeartbeatLoop(hosts) {
            stopHeartbeatLoop();
            heartbeatHosts = Array.isArray(hosts) ? hosts : [];
            if (!heartbeatHosts.length) return;

            const tick = async () => {
                try {
                    await runHeartbeatOnce();
                } finally {
                    // Always schedule next tick, even if runHeartbeatOnce throws
                    heartbeatTimer = setTimeout(tick, HEARTBEAT_INTERVAL_MS);
                }
            };
            heartbeatTimer = setTimeout(tick, 0);
        }

        async function triggerQuickProbe(serverName, reason = 'interaction') {
            if (!serverName || !window.__TAURI__) return;
            const normalized = normalizeHostName(serverName);
            if (!normalized) return;

            const now = Date.now();
            const meta = quickProbeMeta.get(normalized) || { last: 0, inFlight: false };

            // Prevent concurrent probes for same server
            if (meta.inFlight) {
                console.debug(`[quick-probe] skipped ${serverName} (${reason}): probe already in flight`);
                return;
            }

            // Skip if full refresh is in progress for this server
            const fullRefreshState = fullRefreshMeta.get(normalized) || { last: 0, inFlight: false };
            if (fullRefreshState.inFlight) {
                console.debug(`[quick-probe] skipped ${serverName} (${reason}): full refresh in progress`);
                return;
            }

            // Rate limiting: prevent probes within minimum interval
            if (now - meta.last < QUICK_PROBE_MIN_INTERVAL_MS) {
                console.debug(`[quick-probe] skipped ${serverName} (${reason}): within rate limit (${now - meta.last}ms < ${QUICK_PROBE_MIN_INTERVAL_MS}ms)`);
                return;
            }

            const serverInfo = serversData.find(s => normalizeHostName(s.name) === normalized);
            const services = Array.isArray(serverInfo?.services) ? serverInfo.services : null;

            quickProbeMeta.set(normalized, { last: now, inFlight: true });
            const { invoke } = window.__TAURI__.core;
            const timeoutMs = getProbeTimeoutMs();
            try {
                const result = await withTimeout(
                    invoke('get_quick_status', {
                        serverName,
                        services,
                        tcpPorts: settings?.tcpPorts || null
                    }),
                    timeoutMs,
                    `quick_probe ${serverName}`
                );
                applyHeartbeatUpdate(result);

                // Persist quick probe data to database so it survives app restarts
                // Find the updated server data after applyHeartbeatUpdate modified it
                const updatedServer = serversData.find(s => normalizeHostName(s.name) === normalized);
                if (updatedServer?.data && window.__TAURI__?.core?.invoke) {
                    const snapshotData = {
                        ...updatedServer.data,
                        _location: updatedServer.location  // Preserve computed location
                    };
                    invoke('persist_health_snapshot', {
                        serverName: serverName,
                        healthData: snapshotData
                    }).then(() => {
                        updatePersistedHealthMap(serverName, snapshotData);
                    }).catch(err => {
                        console.warn(`[quick-probe] ${serverName}: Failed to persist to database:`, err);
                    });
                }

                cacheDashboardData();
                // Use debounced version to prevent DOM thrashing during background updates
                displayAllServersDebounced();
                quickProbeMeta.set(normalized, { last: Date.now(), inFlight: false });
            } catch (err) {
                console.warn(`[quick-probe] failed for ${serverName} (${reason})`, err);
                if (window.__TAURI__?.core?.invoke && err?.message?.includes('Timeout')) {
                    window.__TAURI__.core.invoke('log_warn', {
                        message: `Probe timeout: ${serverName} (quick_probe/${reason}) after ${timeoutMs}ms - ${err.message || err}`
                    }).catch(() => { }); // Silent fail if logging unavailable
                }
                quickProbeMeta.set(normalized, { last: Date.now(), inFlight: false });
            }
        }

        function applyHeartbeatUpdate(status) {
            if (!status || !status.server_name) return;
            const normalized = normalizeHostName(status.server_name);
            if (!normalized) return;
            const winrmOkNormalized = status.winrm_ok === true
                ? true
                : (status.winrm_ok === false
                    ? false
                    : (status.winrm_error ? false : true));
            const heartbeat = {
                ...status,
                // Avoid marking WinRM as failed on transient parse/timeouts; only treat explicit true/false as signal.
                winrm_ok: winrmOkNormalized,
                updated_at: new Date().toISOString()
            };

            serversData = serversData.map(server => {
                if (normalizeHostName(server.name) !== normalized) {
                    return server;
                }

                const isOnline = !!(winrmOkNormalized || status.ping_ok);
                const mergedData = { ...(server.data || {}) };

                // Warn if adapters are being lost (should never happen in applyHeartbeatUpdate)
                const hadAdapters = server.data?.net_adapters?.length > 0;
                const hasAdapters = mergedData.net_adapters?.length > 0;
                if (hadAdapters && !hasAdapters) {
                    console.warn('[DATA-LOSS] applyHeartbeatUpdate: adapters lost for', server.name);
                }

                // Clear prior WinRM degradation flags once a heartbeat succeeds.
                if (winrmOkNormalized === true) {
                    delete mergedData.winrm_issue;
                    delete mergedData.winrm_error;
                } else if (status.winrm_error) {
                    mergedData.winrm_issue = true;
                    mergedData.winrm_error = status.winrm_error;
                }

                // Debug log uptime values for troubleshooting
                const prevUptime = mergedData.uptime?.uptime_hours;
                const newUptime = status.uptime_hours;
                if (typeof newUptime !== 'number' && prevUptime !== undefined) {
                    console.warn(`[UPTIME-DEBUG] ${server.name}: heartbeat returned non-numeric uptime (${typeof newUptime}: ${newUptime}), keeping previous value: ${prevUptime}h`);
                }

                if (typeof status.uptime_hours === 'number' || typeof status.cpu_load_pct === 'number') {
                    mergedData.uptime = mergedData.uptime || {};
                    if (typeof status.uptime_hours === 'number') {
                        mergedData.uptime.uptime_hours = status.uptime_hours;
                        if (Math.abs(status.uptime_hours - (prevUptime || 0)) > 0.5) {
                            console.log(`[UPTIME-DEBUG] ${server.name}: uptime updated from ${prevUptime?.toFixed(2) || 'none'}h to ${status.uptime_hours.toFixed(2)}h`);
                        }
                    }
                    if (typeof status.cpu_load_pct === 'number') {
                        mergedData.uptime.cpu_load_pct = status.cpu_load_pct;
                    }
                }

                if (typeof status.memory_used_percent === 'number') {
                    mergedData.memory_used_percent = status.memory_used_percent;
                }
                if (typeof status.total_memory_mb === 'number') {
                    mergedData.total_memory_mb = status.total_memory_mb;
                }
                if (typeof status.used_memory_mb === 'number') {
                    mergedData.used_memory_mb = status.used_memory_mb;
                }
                if (typeof status.process_count === 'number') {
                    mergedData.process_count = status.process_count;
                }
                if (status.reachability) {
                    mergedData.reachability = status.reachability;
                }
                if (status.pending_reboot) {
                    mergedData.pending_reboot = status.pending_reboot;
                }

                if (Array.isArray(status.service_status) && status.service_status.length > 0) {
                    mergedData.service_status = status.service_status;
                }

                if (Array.isArray(status.top_cpu_processes) && status.top_cpu_processes.length > 0) {
                    mergedData.high_cpu_processes = status.top_cpu_processes;
                    mergedData.high_cpu_threshold = mergedData.high_cpu_threshold || 50;
                }

                return {
                    ...server,
                    heartbeat,
                    lastHeartbeat: heartbeat.updated_at,
                    online: isOnline,
                    data: mergedData,
                    error: status.winrm_ok === true ? null : (status.winrm_error || server.error)
                };
            });
        }

        function updateViewSwitcherButtons() {
            document.querySelectorAll('.view-btn[data-view]').forEach(btn => {
                const isActive = btn.dataset.view === hostViewMode;
                btn.classList.toggle('btn-active', isActive);
            });
            // Update reorder button state
            const reorderBtn = document.getElementById('reorder-btn');
            if (reorderBtn) {
                reorderBtn.classList.toggle('active', reorderMode);
            }
        }

        function toggleReorderMode() {
            reorderMode = !reorderMode;
            updateViewSwitcherButtons();
            displayAllServers();
        }

        function setHostViewMode(mode) {
            if (mode !== 'cards' && mode !== 'groups') return;
            if (hostViewMode === mode) return;
            hostViewMode = mode;
            if (hostViewMode !== 'groups') {
                focusedGroup = null;
                settingsBundle.qp_focused_group = null;
            }
            persistHostViewMode(mode);
            updateViewSwitcherButtons();
            displayAllServers();
        }

        async function handleGroupRename(oldName, newName) {
            const trimmedOld = (oldName || '').trim();
            const trimmedNew = (newName || '').trim();

            // Validation
            if (!trimmedNew) {
                showError('Group name cannot be empty');
                return;
            }
            if (trimmedNew.toLowerCase() === trimmedOld.toLowerCase()) {
                return; // Same name, nothing to do
            }
            if (!trimmedOld || trimmedOld.toLowerCase() === 'no group') {
                showError('Cannot rename reserved group name');
                return;
            }
            if (trimmedNew.toLowerCase() === 'no group') {
                showError('Cannot use "No Group" as a group name');
                return;
            }
            if (groupRenameBusy) {
                showError('Group rename already in progress');
                return;
            }

            groupRenameBusy = true;
            const previousData = serversData.map(s => ({ ...s }));

            try {
                if (window.__TAURI__ && window.__TAURI__.core) {
                    const { invoke } = window.__TAURI__.core;
                    await invoke('rename_group', { oldGroup: trimmedOld, newGroup: trimmedNew });
                }

                serversData = serversData.map((server) => {
                    const currentGroup = (server.group || server.box || '').trim();
                    if (currentGroup.toLowerCase() === trimmedOld.toLowerCase()) {
                        return { ...server, group: trimmedNew, box: trimmedNew };
                    }
                    return server;
                });

                focusedGroup = trimmedNew;
                settingsBundle.qp_focused_group = focusedGroup;
                queueSettingsSave(settingsPayload());
                cacheDashboardData();
                displayAllServers();
                if (typeof showInfo === 'function') {
                    showInfo(`Group renamed to ${trimmedNew}`);
                }
            } catch (err) {
                console.error('Failed to rename group', err);
                showError(`Failed to rename group: ${err}`);
                // Rollback on error
                serversData = previousData;
                cacheDashboardData();
                displayAllServers();
            } finally {
                groupRenameBusy = false;
            }
        }

        function cacheDashboardData() {
            const payload = {
                serversData,
                cachedAt: new Date().toISOString(),
                hostsSignature
            };
            dashboardCache = payload;
            // Reduced logging - don't log every cache update (happens frequently during heartbeat)
            if (window.__TAURI__?.core?.invoke) {
                window.__TAURI__.core
                    .invoke('cache_set_dashboard', { payload })
                    .catch((err) => {
                        console.warn('Failed to persist dashboard cache', err);
                    });
            }
        }

        async function withTimeout(promise, timeoutMs, label) {
            let timeoutId;
            const timeoutPromise = new Promise((_, reject) => {
                timeoutId = setTimeout(() => reject(new Error(`Timeout after ${timeoutMs}ms (${label})`)), timeoutMs);
            });

            try {
                return await Promise.race([promise, timeoutPromise]);
            } finally {
                clearTimeout(timeoutId);
            }
        }

        async function mapWithConcurrency(items, limit, mapper) {
            const results = new Array(items.length);
            let index = 0;

            const worker = async () => {
                while (index < items.length) {
                    const current = index;
                    index += 1;
                    results[current] = await mapper(items[current], current);
                }
            };

            const poolSize = Math.min(limit, items.length);
            const workers = Array.from({ length: poolSize }, () => worker());
            await Promise.all(workers);
            return results;
        }

        function needsHealthRepair(server) {
            if (!server) return false;
            const data = server.data || {};
            const os = data.os_info || {};
            const osUnknown = !isMeaningfulString(os.os_version) || !isMeaningfulString(os.hostname);
            const adaptersMissing = !Array.isArray(data.net_adapters) || data.net_adapters.length === 0;
            const memoryMissing = !(Number.isFinite(data.total_memory_mb) && data.total_memory_mb > 0);
            return osUnknown || adaptersMissing || memoryMissing;
        }

        let selfHealScheduled = false;
        async function healIncompleteHosts() {
            if (!window.__TAURI__ || !window.__TAURI__.core) return;
            const targets = (serversData || []).filter(needsHealthRepair);
            if (!targets.length) return;
            const limit = Math.min(4, computeHeartbeatConcurrency(targets.length));
            try {
                await mapWithConcurrency(targets, limit, async (server) => {
                    try {
                        // Use quick probe instead of full refresh for background healing
                        await triggerQuickProbe(server.name, 'heal');
                    } catch (err) {
                        console.warn(`[heal] failed for ${server.name}`, err);
                    }
                });
            } catch (err) {
                console.warn('[heal] self-heal batch failed', err);
            }
        }

        function scheduleSelfHeal() {
            if (selfHealScheduled) return;
            selfHealScheduled = true;
            setTimeout(() => healIncompleteHosts(), 0);
        }

        function hydrateFromCache() {
            const parsed = dashboardCache;
            if (!parsed || !Array.isArray(parsed.serversData)) {
                logDebug('hydrateFromCache: NO CACHE', { hasCache: !!parsed, hasServersData: !!parsed?.serversData, isArray: Array.isArray(parsed?.serversData) });
                return { hydrated: false, stale: true };
            }
            const cachedAt = parsed.cachedAt ? Date.parse(parsed.cachedAt) : 0;
            const ageMs = Date.now() - cachedAt;
            const stale = Number.isFinite(ageMs) ? ageMs > MAX_CACHE_AGE_MS : true;
            hostsSignature = parsed.hostsSignature || null;
            serversData = Utils.dedupeNormalizedServers(
                (parsed.serversData || [])
                    .map(normalizeServerRecord)
                    .filter(Boolean)
            );
            serversData = applyOrder(serversData, parseServerOrder());
            // Merge persisted health from SQLite for servers without cache data
            serversData = mergeHealthIntoServers(serversData, persistedHealthMap);
            const serversWithAdapters = serversData.filter(s => s?.data?.net_adapters?.length > 0).length;
            const serversWithLocation = serversData.filter(s => s?.location).length;
            // Don't force recalculate - preserve cached locations
            serversData = serversData.map(server => applyLocationToServer(server, false));
            const serversWithLocationAfter = serversData.filter(s => s?.location).length;
            if (serversData.length > 0) {
            }
            heartbeatHosts = serversData;
            // Don't start heartbeat here - let initialization code control when probing starts
            hideLoading();
            displayAllServers();
            logDebug('hydrateFromCache: HYDRATED', {
                servers: serversData.length,
                ageMs,
                stale,
                maxAge: MAX_CACHE_AGE_MS,
                cachedAt: parsed.cachedAt,
                online: serversData.filter(s => s.online).length
            });
            return { hydrated: true, stale };
        }

        function hostPillStatus(server) {
            if (!server?.online) return 'status-offline';
            const heartbeat = server?.heartbeat;
            const heartbeatWinrmIssue = heartbeat && heartbeat.winrm_ok === false && heartbeat.ping_ok;
            const isWinrmIssue = !!server?.data?.winrm_issue || !!heartbeatWinrmIssue;
            if (isWinrmIssue) return 'status-warning';
            return 'status-online';
        }

        function renderGroupView(servers, container) {
            container.classList.add('group-grid');
            container.classList.remove('group-focus-active');
            const groups = new Map();
            servers.forEach((server) => {
                const label = (server.group || '').trim();
                const key = label || 'No Group';
                if (!groups.has(key)) {
                    groups.set(key, []);
                }
                groups.get(key).push(server);
            });

            if (focusedGroup && !groups.has(focusedGroup)) {
                focusedGroup = null;
                settingsBundle.qp_focused_group = null;
                queueSettingsSave(settingsPayload());
            }

            // Apply saved group order, falling back to alphabetical for unsaved groups
            const savedGroupOrder = settingsBundle.qp_group_order || [];
            const entries = Array.from(groups.entries()).sort((a, b) => {
                const aKey = a[0].toLowerCase();
                const bKey = b[0].toLowerCase();
                // "No Group" always goes last
                if (aKey === 'no group') return 1;
                if (bKey === 'no group') return -1;
                // Check saved order
                const aIdx = savedGroupOrder.findIndex(g => (g || '').toLowerCase() === aKey);
                const bIdx = savedGroupOrder.findIndex(g => (g || '').toLowerCase() === bKey);
                // Both in saved order - use that order
                if (aIdx !== -1 && bIdx !== -1) return aIdx - bIdx;
                // Only one in saved order - it comes first
                if (aIdx !== -1) return -1;
                if (bIdx !== -1) return 1;
                // Neither in saved order - alphabetical
                return aKey.localeCompare(bKey);
            });

            entries.forEach(([groupName, hosts]) => {
                const card = document.createElement('div');
                const canonicalName = groupName || 'No Group';
                card.dataset.group = canonicalName;
                const isFocused = !!focusedGroup && focusedGroup === canonicalName;

                // Compact reorder mode for non-focused groups: simple group card showing name and count
                if (reorderMode && !isFocused) {
                    card.className = 'group-card card bg-base-200 shadow compact-reorder';
                    card.style.cursor = 'grab';
                    const cardBody = document.createElement('div');
                    cardBody.className = 'card-body';
                    cardBody.innerHTML = `
                        <div class="compact-content">
                            <span class="group-icon">üìÅ</span>
                            <span class="group-name">${escapeHtml(canonicalName)}</span>
                            <span class="host-count">${hosts.length}</span>
                        </div>
                    `;
                    card.appendChild(cardBody);
                    // Allow clicking to expand even in reorder mode
                    card.addEventListener('click', () => {
                        focusedGroup = canonicalName;
                        settingsBundle.qp_focused_group = focusedGroup;
                        queueSettingsSave(settingsPayload());
                        displayAllServers();
                    });
                    container.appendChild(card);
                    return;
                }

                card.className = 'group-card card bg-base-200 shadow-xl';

                const cardBody = document.createElement('div');
                cardBody.className = 'card-body p-4';

                const header = document.createElement('div');
                header.className = 'flex justify-between items-center mb-3 cursor-pointer';
                const infoWrap = document.createElement('div');
                infoWrap.className = 'flex flex-col gap-1';
                const nameBtn = document.createElement('button');
                nameBtn.type = 'button';
                nameBtn.className = 'text-xl font-bold text-secondary hover:text-secondary-focus text-left flex items-center gap-2';
                nameBtn.innerHTML = `<span class="text-2xl">üìÅ</span> ${escapeHtml(canonicalName)}`;
                nameBtn.title = canonicalName === 'No Group' ? 'Ungrouped hosts' : 'Rename group';
                nameBtn.disabled = canonicalName.toLowerCase() === 'no group';
                nameBtn.addEventListener('click', async (event) => {
                    event.stopPropagation();
                    if (!openGroupRenameDialog || nameBtn.disabled) return;
                    const newName = await openGroupRenameDialog(canonicalName);
                    if (!newName || newName === canonicalName) return;
                    await handleGroupRename(canonicalName, newName);
                });

                const sub = document.createElement('div');
                sub.className = 'text-sm text-base-content/60';
                sub.textContent = `${hosts.length} host${hosts.length === 1 ? '' : 's'} ‚Ä¢ click to expand`;

                infoWrap.appendChild(nameBtn);
                infoWrap.appendChild(sub);
                header.appendChild(infoWrap);

                cardBody.appendChild(header);

                const pillWrap = document.createElement('div');
                pillWrap.className = 'flex flex-wrap gap-2 mt-2';

                const hostCardsWrap = document.createElement('div');
                hostCardsWrap.className = 'group-card-hosts';

                hosts.forEach(host => {
                    const pill = document.createElement('button');
                    pill.type = 'button';
                    const statusClass = hostPillStatus(host);
                    // Map status classes to DaisyUI badge classes
                    const badgeClass = statusClass === 'status-offline' ? 'badge-error' :
                        statusClass === 'status-warning' ? 'badge-warning' :
                            'badge-success';
                    pill.className = `badge ${badgeClass} badge-lg gap-1 cursor-pointer hover:scale-105 transition-transform`;
                    pill.textContent = host.name;
                    const note = host.notes ? `Notes: ${host.notes}` : '';
                    pill.title = note || 'Open host details';
                    pill.addEventListener('click', (event) => {
                        event.stopPropagation();
                        if (typeof openHostPreview === 'function') {
                            openHostPreview(host.name);
                        } else {
                            showError('Preview unavailable; please refresh the page.');
                        }
                    });
                    pillWrap.appendChild(pill);

                    // Cards in expanded groups should be draggable (preview: false when focused)
                    // Use compact cards in reorder mode
                    const hostCard = createServerCard(host, {
                        preview: !isFocused,
                        compact: reorderMode && isFocused
                    });
                    hostCardsWrap.appendChild(hostCard);
                });

                cardBody.appendChild(pillWrap);
                cardBody.appendChild(hostCardsWrap);
                card.appendChild(cardBody);

                const toggleExpanded = () => {
                    focusedGroup = isFocused ? null : canonicalName;
                    settingsBundle.qp_focused_group = focusedGroup;
                    queueSettingsSave(settingsPayload());
                    displayAllServers();
                };

                header.addEventListener('click', toggleExpanded);
                card.addEventListener('dblclick', toggleExpanded);

                if (isFocused) {
                    card.classList.add('expanded', 'full-focus');
                    hostCardsWrap.classList.add('grid-mode');
                    if (reorderMode) {
                        hostCardsWrap.classList.add('reorder-mode');
                    }
                    hostCardsWrap.style.display = 'grid';
                    container.classList.add('group-focus-active');
                } else {
                    hostCardsWrap.style.display = 'none';
                }

                if (focusedGroup && !isFocused) {
                    card.style.display = 'none';
                }

                container.appendChild(card);
            });
        }

        function displayAllServersDebounced() {
            // Skip entirely if any hosts are being refreshed to prevent animation interruption
            const hasActiveRefresh = Array.from(fullRefreshMeta.values()).some(meta => meta.inFlight);
            if (hasActiveRefresh) {
                console.log('[displayAllServersDebounced] Skipping update - refresh in progress');
                return;
            }

            // Debounce to prevent excessive DOM recreation during background updates
            clearTimeout(displayAllServersDebounceTimer);
            displayAllServersDebounceTimer = setTimeout(() => {
                displayAllServers();
            }, 100); // 100ms debounce
        }

        function displayAllServers() {
            const loadErrorState = document.getElementById('load-error-state');
            if (loadErrorState && !loadErrorState.classList.contains('hidden')) {
                return;
            }

            // Debug: Log active refreshes when displayAllServers is called
            const activeRefreshes = Array.from(fullRefreshMeta.entries())
                .filter(([name, meta]) => meta.inFlight)
                .map(([name]) => name);
            if (activeRefreshes.length > 0) {
                console.log(`[displayAllServers] Called while refreshing:`, activeRefreshes);
            }

            clearSelection();

            // Always calculate summary from ALL servers so users see total infrastructure health
            const summary = Utils.summarize(serversData);
            updateSummaryCards(summary);
            document.getElementById('summary-stats').classList.remove('hidden');

            const grid = document.getElementById('servers-grid');
            if (!Array.isArray(serversData) || serversData.length === 0) {
                showEmptyState('No hosts configured yet.');
                grid.innerHTML = '';
                updateSearchMeta(0);
                return;
            }
            hideEmptyState();

            const filteredServers = computeVisibleHosts();

            // Display server cards
            grid.innerHTML = '';
            grid.classList.remove('group-grid', 'reorder-mode');

            // Add reorder mode banner if active
            const existingBanner = document.querySelector('.reorder-mode-banner');
            if (existingBanner) existingBanner.remove();

            if (reorderMode) {
                grid.classList.add('reorder-mode');
                const banner = document.createElement('div');
                banner.className = 'reorder-mode-banner';
                banner.innerHTML = `
                    <div class="banner-text">
                        <span>‚ÜïÔ∏è</span>
                        <span>Reorder Mode ‚Äî Drag cards to rearrange</span>
                    </div>
                    <button class="done-btn" type="button">‚úì Done</button>
                `;
                banner.querySelector('.done-btn').addEventListener('click', toggleReorderMode);
                grid.parentNode.insertBefore(banner, grid);
            }

            if (filteredServers.length === 0) {
                grid.innerHTML = '<div class="empty-state">No servers match your search.</div>';
                grid.classList.remove('hidden');
                updateSearchMeta(0);
                return;
            }

            if (hostViewMode === 'groups') {
                renderGroupView(filteredServers, grid);
            } else {
                filteredServers.forEach(server => {
                    const card = createServerCard(server, { compact: reorderMode });
                    grid.appendChild(card);
                });

                // Cards are now always expanded - no state to restore
            }

            if (hostViewMode === 'groups') {
                grid.classList.add('group-grid');
                if (reorderMode) grid.classList.add('reorder-mode');
            }
            grid.classList.remove('hidden');
            updateSearchMeta(filteredServers.length);

            // Restore refreshing animation state for cards that are still being refreshed
            // This is needed because displayAllServers recreates all cards, losing the CSS class
            const inFlightServers = [];
            fullRefreshMeta.forEach((meta, serverKey) => {
                if (meta.inFlight) {
                    inFlightServers.push(serverKey);
                }
            });
            if (inFlightServers.length > 0) {
                document.querySelectorAll('.server-card').forEach(card => {
                    const cardKey = normalizeHostName(card.dataset.serverName || '');
                    if (inFlightServers.includes(cardKey)) {
                        card.classList.add('refreshing');
                    }
                });
            }

            // Initialize drag-and-drop for all cards
            initDragDropForCards();
        }

        function getRefreshTargets() {
            const savedOrder = parseServerOrder();
            const orderedServers = applyOrder(serversData, savedOrder);
            const filteredServers = Utils.filterServers(orderedServers, searchTerm, activeFilter);
            return filteredServers.length > 0 ? filteredServers : [];
        }

        function computeVisibleHosts() {
            const savedOrder = parseServerOrder();
            const orderedServers = applyOrder(serversData, savedOrder);
            const filteredServers = Utils.filterServers(orderedServers, searchTerm, activeFilter);

            if (hostViewMode === 'groups' && focusedGroup) {
                const target = focusedGroup.toLowerCase();
                return filteredServers.filter((s) => {
                    const label = ((s.group || s.box || '').trim() || 'No Group').toLowerCase();
                    return label === target;
                });
            }

            if (!filteredServers.length && orderedServers.length) {
                logHostsSnapshot(orderedServers.length, savedOrder.length, filteredServers.length);
                return orderedServers;
            }

            logHostsSnapshot(orderedServers.length, savedOrder.length, filteredServers.length);
            return filteredServers;
        }

        async function refreshVisibleHosts(buttonEl) {
            const targets = getRefreshTargets();
            const total = targets.length;

            if (total === 0) {
                showWarning('No hosts match current filter');
                return;
            }

            const originalLabel = buttonEl ? buttonEl.textContent : null;
            if (buttonEl) {
                buttonEl.disabled = true;
                buttonEl.textContent = `üîÑ Refreshing (0/${total})...`;
            }

            const limit = computeHeartbeatConcurrency(total);
            logDebug('RefreshHosts start', { count: total, filter: searchTerm || '', view: hostViewMode, concurrency: limit, activeFilter: activeFilter?.type || 'none' });

            let completed = 0;
            const bumpProgress = () => {
                completed += 1;
                if (buttonEl) {
                    buttonEl.textContent = `üîÑ Refreshing (${completed}/${total})...`;
                }
            };

            try {
                await mapWithConcurrency(targets, limit, async (server) => {
                    await refreshServer(server.name);
                    bumpProgress();
                });
                setLastRefreshStatus('ok', 'Hosts refreshed');
                logDebug('RefreshHosts complete', { count: total, completed, view: hostViewMode, filter: searchTerm || '', activeFilter: activeFilter?.type || 'none' });
            } catch (err) {
                console.error('Refresh failed', err);
                targets.forEach((s) => setHostStatus(s.name, 'Failed', 'error'));
                setLastRefreshStatus('partial', 'Some hosts failed to refresh');
                showWarning('Some hosts failed to refresh; see cards for details');
                logDebug('RefreshHosts failed', { count: total, completed, error: err?.toString?.() || 'unknown' });
            } finally {
                if (buttonEl) {
                    buttonEl.disabled = false;
                    buttonEl.textContent = originalLabel || 'Refresh Visible';
                }
            }
        }

        async function refreshServer(serverName, buttonEl) {
            if (!serverName) return;
            // Look up existing data from both serversData AND persistedHealthMap
            // This ensures we preserve valid data even when WinRM fails and returns "Unknown" values
            const existingFromServers = serversData.find(s => s.name === serverName);
            const persistedKey = serverName.toLowerCase();
            const persistedSnapshot = persistedHealthMap?.get(persistedKey);
            // Build existing object: prefer serversData, fall back to persisted
            const existingData = existingFromServers?.data && Object.keys(existingFromServers.data).length > 0
                ? existingFromServers.data
                : persistedSnapshot?.data;
            const existing = existingFromServers || (persistedSnapshot ? {
                name: serverName,
                data: persistedSnapshot.data,
                location: persistedSnapshot.data?._location,
                notes: '',
                group: '',
                services: []
            } : null);
            if (!existing) {
                setHostStatus(serverName, 'Missing', 'error');
                return;
            }

            if (!window.__TAURI__) {
                setHostStatus(serverName, 'Failed', 'error');
                return;
            }

            const normalized = normalizeHostName(serverName);
            if (!normalized) return;

            // Prevent concurrent operations on same server
            const fullRefreshState = fullRefreshMeta.get(normalized) || { last: 0, inFlight: false };
            const quickProbeState = quickProbeMeta.get(normalized) || { last: 0, inFlight: false };

            if (fullRefreshState.inFlight) {
                logDebug('Full refresh skipped (already in progress)', { server: serverName });
                showWarning(`Refresh already in progress for ${serverName}`);
                return;
            }

            if (quickProbeState.inFlight) {
                logDebug('Full refresh skipped (quick probe in progress)', { server: serverName });
                showWarning(`Quick probe in progress for ${serverName}, please wait`);
                return;
            }

            // Note: Removed global heartbeatInFlight check - per-server tracking is sufficient
            // and allows manual refreshes while background heartbeats run on other servers

            const { invoke } = window.__TAURI__.core;
            let latestServices = Array.isArray(existing.services) ? existing.services : [];
            let latestNotes = existing.notes;
            let latestGroup = existing.box || existing.group || '';

            // Mark full refresh as in-flight
            fullRefreshMeta.set(normalized, { last: Date.now(), inFlight: true });
            logDebug('Full refresh started', { server: serverName });

            setHostStatus(serverName, 'Refreshing', 'info');

            try {
                const hostList = await invoke('get_hosts');
                const normalizedTarget = normalizeHostName(serverName);
                const normalizedHosts = Utils.dedupeNormalizedServers(
                    (hostList || []).map(normalizeServerRecord).filter(Boolean)
                );
                const match = normalizedHosts.find(h => h.name === normalizedTarget);
                if (match) {
                    latestServices = Array.isArray(match.services) ? match.services : [];
                    latestNotes = match.notes || latestNotes;
                    latestGroup = match.box || match.group || latestGroup;
                }
            } catch (metaErr) {
                setHostStatus(serverName, 'Cached', 'warn');
            }

            const criticalServices = latestServices.length > 0 ? latestServices : null;

            if (buttonEl) {
                buttonEl.disabled = true;
                buttonEl.textContent = '‚è≥ Refreshing';
            }
            setCardRefreshing(serverName, true);

            try {
                // First, try a quick WinRM connectivity test
                const quickTestStart = Date.now();
                const quickTestTimeout = getQuickProbeTimeoutMs(); // Use configured quick probe timeout
                try {
                    const quickResult = await withTimeout(
                        invoke('get_quick_status', {
                            serverName: serverName,
                            services: null,
                            tcpPorts: settings?.tcpPorts || null
                        }),
                        quickTestTimeout,
                        `quick_status ${serverName}`
                    );
                    const quickTestElapsed = Date.now() - quickTestStart;
                } catch (quickErr) {
                    const quickTestElapsed = Date.now() - quickTestStart;
                    console.error(`[RefreshServer] ${serverName}: WinRM connectivity test FAILED (${quickTestElapsed}ms):`, quickErr);
                    // Don't throw here - allow the full health check to try anyway
                }

                const healthStart = Date.now();
                let healthData;
                try {
                    healthData = await withTimeout(
                        invoke('get_system_health', {
                            serverName: serverName,
                            diskThreshold: 10.0,
                            criticalServices,
                            tcpPorts: settings?.tcpPorts || null
                        }),
                        getProbeTimeoutMs(),
                        `get_system_health ${serverName}`
                    );
                } catch (healthErr) {
                    // If full health check times out, try a minimal probe
                    console.warn(`[RefreshServer] ${serverName}: get_system_health failed (${Date.now() - healthStart}ms), trying minimal probe...`);
                    if (window.__TAURI__?.core?.invoke && healthErr?.message?.includes('Timeout')) {
                        window.__TAURI__.core.invoke('log_warn', {
                            message: `Probe timeout: ${serverName} (get_system_health) after ${getProbeTimeoutMs()}ms - ${healthErr.message || healthErr}`
                        }).catch(() => { }); // Silent fail if logging unavailable
                    }
                    try {
                        const minimalData = await withTimeout(
                            invoke('get_quick_status', {
                                serverName: serverName,
                                services: criticalServices,
                                tcpPorts: settings?.tcpPorts || null
                            }),
                            getQuickProbeTimeoutMs(),
                            `quick_status_fallback ${serverName}`
                        );
                        // Convert quick status to minimal health data format
                        healthData = {
                            reachability: {
                                ping_ok: minimalData.ping_ok,
                                tcp_ports: minimalData.tcp_ports
                            },
                            service_status: minimalData.service_status || [],
                            winrm_error: minimalData.winrm_error,
                            uptime: minimalData.uptime_hours ? { uptime_hours: minimalData.uptime_hours } : null
                        };
                    } catch (minimalErr) {
                        // If even minimal probe fails, throw the original error
                        console.error(`[RefreshServer] ${serverName}: Minimal probe also failed:`, minimalErr);
                        throw healthErr;
                    }
                }
                const healthElapsed = Date.now() - healthStart;
                if (!healthData.net_adapters || (Array.isArray(healthData.net_adapters) && healthData.net_adapters.length === 0)) {
                    try {
                        const debugAdapters = await withTimeout(
                            invoke('fetch_net_adapters', { serverName }),
                            15000,
                            `fetch_net_adapters ${serverName}`
                        );
                        if (debugAdapters && Array.isArray(debugAdapters.adapters) && debugAdapters.adapters.length > 0) {
                            healthData.net_adapters = debugAdapters.adapters;
                        }
                    } catch (dbgErr) {
                        console.warn(`[RefreshServer] ${serverName}: Failed to fetch adapters:`, dbgErr);
                    }
                }
                let normalizedAdapters = Array.isArray(healthData.net_adapters) ? healthData.net_adapters : [];
                if ((!normalizedAdapters || normalizedAdapters.length === 0) && existingData?.net_adapters?.length) {
                    normalizedAdapters = existingData.net_adapters;
                }
                let mergedData = mergeHealthData(existingData, { ...healthData, net_adapters: normalizedAdapters });
                const needsOsInfo = !isMeaningfulString(mergedData?.os_info?.os_version) || !isMeaningfulString(mergedData?.os_info?.hostname);
                if (needsOsInfo) {
                    try {
                        const osInfo = await withTimeout(
                            invoke('fetch_os_info', { serverName }),
                            getProbeTimeoutMs(),
                            `fetch_os_info ${serverName}`
                        );
                        mergedData = mergeHealthData(mergedData, { os_info: osInfo });
                    } catch (osErr) {
                        if (console?.warn) {
                            console.warn(`[os-info] failed for ${serverName}`, osErr);
                        }
                    }
                }

                const hasAdapters = Array.isArray(mergedData.net_adapters) && mergedData.net_adapters.length > 0;
                const fallbackLocation = hasAdapters ? null : (locationMatchers.length ? existing.location : null);
                const location = deriveLocationFromAdapters(mergedData.net_adapters, fallbackLocation);

                // Persist to database - AWAIT to ensure cache/DB sync
                if (window.__TAURI__?.core?.invoke) {
                    const snapshotData = {
                        ...mergedData,
                        _location: location  // Store computed location in snapshot
                    };
                    try {
                        await window.__TAURI__.core.invoke('persist_health_snapshot', {
                            serverName: serverName,
                            healthData: snapshotData
                        });
                        // Update in-memory map so subsequent mergeHealthIntoServers calls use latest data
                        updatePersistedHealthMap(serverName, snapshotData);
                    } catch (err) {
                        console.error(`[RefreshServer] ${serverName}: Failed to persist to database:`, err);
                        // Continue despite DB error - cache will still be updated
                    }
                }

                const updated = {
                    ...existing,
                    online: true,
                    data: mergedData,
                    services: latestServices,
                    notes: latestNotes,
                    group: latestGroup,
                    error: undefined,
                    lastRefreshed: new Date().toISOString(),
                    location
                };

                serversData = serversData.map(s => s.name === serverName ? updated : s);
                cacheDashboardData();
                // Use debounced version to avoid recreating cards during batch refresh
                // which would interrupt animations on cards still being refreshed
                displayAllServersDebounced();
                if (buttonEl) {
                    setLastRefreshStatus('ok', 'Host refreshed');
                }
                setHostStatus(serverName, 'Updated', 'success');
            } catch (error) {
                console.error(`[RefreshServer] ${serverName}: ERROR during refresh:`, error);
                console.error(`[RefreshServer] ${serverName}: Error type: ${error?.constructor?.name}`);
                console.error(`[RefreshServer] ${serverName}: Error message: ${error?.message || error?.toString()}`);
                console.error(`[RefreshServer] ${serverName}: Error stack:`, error?.stack);
                // Use existingData which includes persisted health as fallback
                const preservedData = existingData ? { ...existingData } : (existing?.data ? { ...existing.data } : undefined);
                const fallbackLocation = locationMatchers.length
                    ? (existing?.location || deriveLocationFromAdapters(existingData?.net_adapters, null))
                    : existing?.location;
                const updated = {
                    ...existing,
                    online: false,
                    data: preservedData,
                    services: latestServices,
                    notes: latestNotes,
                    group: latestGroup,
                    error: error.toString(),
                    lastRefreshed: new Date().toISOString(),
                    location: fallbackLocation
                };
                serversData = serversData.map(s => s.name === serverName ? updated : s);
                cacheDashboardData();
                // Use debounced version to avoid recreating cards during batch refresh
                displayAllServersDebounced();
                setLastRefreshStatus('partial', 'Host refresh failed');
                setHostStatus(serverName, 'Failed', 'error');
            } finally {
                // Clear full refresh in-flight flag
                fullRefreshMeta.set(normalized, { last: Date.now(), inFlight: false });
                logDebug('Full refresh completed', { server: serverName });

                setCardRefreshing(serverName, false);
                if (buttonEl) {
                    buttonEl.disabled = false;
                    buttonEl.textContent = 'üîÑ Refresh';
                }
            }
        }

        function createServerCard(server, options = {}) {
            const isPreview = options.preview === true;
            const isCompact = options.compact === true;

            // Compact mode: simple pill-style card for reordering
            if (isCompact) {
                const card = document.createElement('div');
                card.className = 'server-card card bg-base-200 shadow compact-reorder';
                card.dataset.serverName = server.name;
                card.dataset.preview = 'false'; // Always allow drag in compact mode
                card.style.cursor = 'grab';

                const rawOs = server.os_type || server.os || server.osType || 'Windows';
                const osType = Utils?.normalizeOsType ? Utils.normalizeOsType(rawOs) : rawOs;
                const isLinux = osType.toLowerCase() === 'linux';
                const osIcon = isLinux ? 'üêß' : 'üñ•Ô∏è';
                const statusDot = server.online ? 'üü¢' : 'üî¥';

                const cardBody = document.createElement('div');
                cardBody.className = 'card-body';
                cardBody.innerHTML = `
                    <div class="compact-content">
                        <span class="status-dot">${statusDot}</span>
                        <span class="os-icon">${osIcon}</span>
                        <span class="server-name">${escapeHtml(server.name)}</span>
                    </div>
                `;
                card.appendChild(cardBody);

                // Double-click launches RDP for Windows, SSH for Linux
                if (isLinux) {
                    card.addEventListener('dblclick', () => launchSsh(server.name));
                } else {
                    card.addEventListener('dblclick', () => launchRdp(server.name));
                }

                return card;
            }

            const card = document.createElement('div');
            card.className = 'server-card card bg-base-200 shadow-lg hover:shadow-xl';
            card.dataset.serverName = server.name;
            card.dataset.preview = isPreview ? 'true' : 'false';

            // Preserve refreshing state if card is recreated during active refresh
            const normalized = normalizeHostName(server.name);
            const refreshState = fullRefreshMeta.get(normalized);
            if (normalized && refreshState?.inFlight) {
                card.classList.add('refreshing');
                console.log(`[createServerCard] ‚úì Preserving refreshing animation for ${server.name}`, {
                    inFlight: refreshState.inFlight,
                    hasClass: card.classList.contains('refreshing')
                });
            } else if (normalized && refreshState) {
                console.log(`[createServerCard] ‚úó NOT preserving for ${server.name}`, {
                    inFlight: refreshState.inFlight,
                    hasRefreshState: !!refreshState
                });
            }
            const highlightedName = highlightMatch(server.name, searchTerm);
            const heartbeat = server.heartbeat;
            const groupValue = server.group || '';
            const hostMeta = hostsByName.get(server.name);
            const hostStatus = getHostStatus(server.name);
            // Map tone to DaisyUI badge class
            const toneToBadge = {
                'success': 'badge-success',
                'warn': 'badge-warning',
                'error': 'badge-error',
                'info': 'badge-info'
            };
            const badgeClass = toneToBadge[hostStatus?.tone] || 'badge-info';
            const statusBadge = hostStatus ? `<span class="badge ${badgeClass} gap-1">${escapeHtml(hostStatus.status)}</span>` : '';
            const rawOs = hostMeta
                ? (hostMeta.os_type || hostMeta.os || hostMeta.osType || 'Windows')
                : (server.os_type || server.os || server.osType || 'Windows');
            const osType = Utils?.normalizeOsType ? Utils.normalizeOsType(rawOs) : rawOs;
            const osMarkup = `<span class="badge badge-info badge-outline">${escapeHtml(osType)}</span>`;
            const groupMarkup = `<div class="flex gap-2 flex-wrap mb-1">${osMarkup}${groupValue ? `<span class="badge badge-secondary font-semibold gap-1">üìÅ ${escapeHtml(groupValue)}</span>` : ''}</div>`;
            // Show location if available, or helpful message based on whether mappings are configured
            const hasLocationMappings = settings?.locationMappings?.length > 0;
            const locationDisplay = server.location
                ? highlightMatch(server.location, searchTerm)
                : (hasLocationMappings ? 'Unknown' : 'Not configured');
            const locationLine = `
                <div class="card-details flex items-center gap-2 flex-wrap my-2">
                    <span class="text-warning font-bold">üìç Location:</span>
                    <span class="text-warning/80 font-bold tracking-wide">${locationDisplay}</span>
                </div>
            `;
            const isLinux = osType.toLowerCase() === 'linux';
            if (!isPreview) {
                card.addEventListener('dblclick', () => {
                    if (isLinux) {
                        launchSsh(server.name);
                    } else {
                        launchRdp(server.name);
                    }
                });
                card.addEventListener('click', (e) => handleCardClick(e, server.name));
            } else {
                card.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    if (isLinux) {
                        launchSsh(server.name);
                    } else {
                        launchRdp(server.name);
                    }
                });
            }
            card.classList.toggle('refreshing', false);

            if (!server.online) {
                // OFFLINE card: show stale data from last successful probe with OFFLINE badge
                const lastRefreshLabel = formatTimestamp(server.lastRefreshed || server.lastHeartbeat);
                const quickLabel = heartbeat?.updated_at ? formatTimestamp(heartbeat.updated_at) : 'No quick probe';
                const quickStale = heartbeat?.updated_at ? (Date.now() - Date.parse(heartbeat.updated_at) > HEARTBEAT_STALE_MS) : true;
                const quickLabelWithStale = quickStale && heartbeat?.updated_at ? `${quickLabel} (stale)` : quickLabel;
                const noteMarkup = server.notes ? `<div class="text-base-content/60 text-sm mb-3 italic">üìù ${highlightMatch(server.notes, searchTerm)}</div>` : '';
                const reachabilityMarkup = renderReachabilityRow(server);

                // Use preserved data from last successful probe
                const data = server.data || {};
                const diskAlertCount = data.disk_alerts ? data.disk_alerts.length : 0;
                const totalDisks = data.disks ? data.disks.length : (data.total_disks || 0);
                const rawServiceStatus = Array.isArray(data.service_status)
                    ? data.service_status
                    : (data.service_status ? [data.service_status] : []);
                // Filter out "NotFound" services - these are platform-specific services that don't exist on this host
                const serviceStatus = rawServiceStatus.filter(s => s?.status && s.status.toLowerCase() !== 'notfound');
                const stoppedServices = serviceStatus.filter(s => {
                    if (!s?.status) return true;
                    const status = s.status.toLowerCase();
                    return status !== 'running';
                });
                const runningServices = serviceStatus.filter(s => s?.status && s.status.toLowerCase() === 'running');
                const highCpuThreshold = typeof data.high_cpu_threshold === 'number' ? data.high_cpu_threshold : 50;
                const highCpuProcesses = Array.isArray(data.high_cpu_processes)
                    ? data.high_cpu_processes
                        .filter(p => typeof p.cpu_percent === 'number' && p.cpu_percent > highCpuThreshold)
                        .sort((a, b) => (b.cpu_percent || 0) - (a.cpu_percent || 0))
                        .slice(0, 3)
                    : [];
                const highCpuCount = highCpuProcesses.length;
                const highCpuNames = highCpuProcesses.length > 0
                    ? highCpuProcesses.map(p => `${p.name || 'Unknown'} (${Math.round(p.cpu_percent)}%)`).join(', ')
                    : '';
                const processCount = typeof data.process_count === 'number' ? data.process_count : 0;
                const totalMemMb = typeof data.total_memory_mb === 'number' ? data.total_memory_mb : 0;
                const heartbeatMemPercent = typeof heartbeat?.memory_used_percent === 'number' ? heartbeat.memory_used_percent : null;
                const usedMemMb = typeof data.used_memory_mb === 'number' ? data.used_memory_mb : 0;
                let memPercent = typeof data.memory_used_percent === 'number' ? data.memory_used_percent : (heartbeatMemPercent ?? 0);
                let adjustedUsedMemMb = usedMemMb;
                if (!adjustedUsedMemMb && totalMemMb > 0 && memPercent > 0) {
                    adjustedUsedMemMb = (memPercent / 100) * totalMemMb;
                }
                const totalMemGb = Math.round((totalMemMb / 1024) * 10) / 10;
                const usedMemGb = Math.round((adjustedUsedMemMb / 1024) * 10) / 10;
                const heartbeatUptime = typeof heartbeat?.uptime_hours === 'number' ? heartbeat.uptime_hours : null;
                const heartbeatCpu = typeof heartbeat?.cpu_load_pct === 'number' ? heartbeat.cpu_load_pct : null;
                const dataUptime = typeof data.uptime?.uptime_hours === 'number' ? data.uptime.uptime_hours : null;
                const uptimeValue = dataUptime !== null ? dataUptime : heartbeatUptime;
                // Debug log uptime source (uncomment to troubleshoot)
                // console.log(`[UPTIME-RENDER] ${server.name}: dataUptime=${dataUptime}, heartbeatUptime=${heartbeatUptime}, using=${uptimeValue}`);
                const uptimeLabel = Number.isFinite(uptimeValue) ? humanizeUptime(uptimeValue) : 'Unknown';
                const cpuValue = typeof data.uptime?.cpu_load_pct === 'number' ? data.uptime.cpu_load_pct : heartbeatCpu;
                const cpuLoadLabel = Number.isFinite(cpuValue) ? `${Math.round(cpuValue)}% CPU` : 'Unknown CPU';
                const pendingSignals = Array.isArray(data.pending_reboot?.signals) ? data.pending_reboot.signals : [];
                const pendingTooltip = pendingSignals.length > 0 ? pendingSignals.join(', ') : 'Reboot signals detected';
                const pendingBadge = data.pending_reboot?.pending ? `<span class="badge badge-warning gap-1" title="${escapeHtml(pendingTooltip)}">üîÑ Reboot Pending</span>` : '';

                const errorsMarkup = Array.isArray(data.recent_errors) && data.recent_errors.length > 0 ? `
                    <div class="card-details mt-2">
                        <div class="metric-label text-error font-semibold">‚ö†Ô∏è Recent Critical/Errors (last 30m)</div>
                        <div class="text-sm text-base-content/90 leading-relaxed max-h-40 overflow-auto">
                            ${data.recent_errors.slice(0, 5).map(e => {
                    const label = `${e.log} ${e.id} ${formatTimestamp(e.time_created)} ${e.provider}`;
                    const msg = e.message || '';
                    return `<div class="mb-2">${highlightMatch(label, searchTerm)}<br><span class="text-base-content/60">${highlightMatch(msg, searchTerm)}</span></div>`;
                }).join('')}
                        </div>
                    </div>` : '';

                const rawAdapters = Array.isArray(data.net_adapters) ? data.net_adapters : [];
                const adapters = rawAdapters.map((a) => {
                    const trimList = (arr) =>
                        Array.isArray(arr)
                            ? arr.map((v) => (typeof v === 'string' ? v.trim() : v)).filter((v) => v)
                            : [];
                    return {
                        alias: typeof a.alias === 'string' ? a.alias.trim() : a.alias,
                        description: typeof a.description === 'string' ? a.description.trim() : a.description,
                        ipv4: trimList(a.ipv4),
                        ipv4_prefix: trimList(a.ipv4_prefix),
                        ipv6: trimList(a.ipv6),
                        dns: trimList(a.dns),
                        gateway: trimList(a.gateway),
                    };
                });
                const prefixToMask = (prefix) => {
                    const n = Number(prefix);
                    if (!Number.isFinite(n) || n < 0 || n > 32) return '';
                    const mask = (0xffffffff << (32 - n)) >>> 0;
                    return `${(mask >>> 24) & 255}.${(mask >>> 16) & 255}.${(mask >>> 8) & 255}.${mask & 255}`;
                };
                const selectPrimaryNetwork = (list) => {
                    if (!Array.isArray(list) || list.length === 0) return null;
                    const scored = list.map((a, idx) => {
                        const ipv4 = Array.isArray(a.ipv4) ? a.ipv4 : [];
                        const prefixes = Array.isArray(a.ipv4_prefix) ? a.ipv4_prefix : [];
                        const ipv6 = Array.isArray(a.ipv6) ? a.ipv6 : [];
                        const gateway = Array.isArray(a.gateway) ? a.gateway : [];
                        const dns = Array.isArray(a.dns) ? a.dns : [];
                        const ipv4Entries = ipv4.map((addr, i) => ({
                            addr,
                            prefix: Number(prefixes[i])
                        })).filter(e => e.addr);
                        const score = (ipv4Entries.length ? 10 : 0) + (gateway.length ? 5 : 0) + (dns.length ? 1 : 0);
                        return { adapter: a, ipv4Entries, ipv6, gateway, dns, score, order: idx };
                    }).sort((a, b) => {
                        if (b.score === a.score) return a.order - b.order;
                        return b.score - a.score;
                    });
                    return scored[0] || null;
                };

                const primary = selectPrimaryNetwork(adapters);
                let primaryIp = 'Unknown';
                let primarySubnet = 'Unknown';
                let primaryGateway = 'Unknown';
                let primaryDns = 'Unknown';

                if (primary) {
                    const ipv4Entry = primary.ipv4Entries.find(e => typeof e.addr === 'string' && e.addr.trim().length > 0);
                    const ipv6Entry = Array.isArray(primary.ipv6) && primary.ipv6.length > 0
                        ? primary.ipv6.find(ip => typeof ip === 'string' && ip.trim().length > 0)
                        : null;
                    const chosen = ipv4Entry || (ipv6Entry ? { addr: ipv6Entry, prefix: undefined } : null);
                    if (chosen && typeof chosen.addr === 'string') {
                        primaryIp = chosen.addr.trim();
                        if (ipv4Entry && Number.isFinite(ipv4Entry.prefix) && ipv4Entry.prefix > 0) {
                            const mask = prefixToMask(ipv4Entry.prefix);
                            primarySubnet = mask ? `${mask} (/${ipv4Entry.prefix})` : `/${ipv4Entry.prefix}`;
                        }
                    }
                    const gw = Array.isArray(primary.gateway) ? primary.gateway.find(g => g && g.trim().length > 0) : null;
                    if (gw) primaryGateway = gw;
                    const dnsList = Array.isArray(primary.dns)
                        ? primary.dns
                            .map(d => (typeof d === 'string' ? d.trim() : d))
                            .filter(d => d && d !== '::1')
                        : [];
                    if (dnsList.length > 0) primaryDns = dnsList.join(', ');
                }

                card.innerHTML = `
                    <div class="card-body">
                    <div class="server-card-header flex justify-between items-center gap-2 flex-wrap">
                        <div class="flex items-center gap-2 flex-nowrap min-w-0">
                            <div class="server-name whitespace-nowrap">${highlightedName}</div>
                        </div>
                        <div class="flex gap-2 items-center flex-wrap">
                            ${statusBadge}
                            ${pendingBadge}
                            <span class="badge badge-error gap-1">‚úó OFFLINE</span>
                        </div>
                    </div>
                    ${groupMarkup}
                    ${noteMarkup}
                    <div class="last-refresh flex gap-2 flex-wrap items-center">
                        <span class="badge ${quickStale ? 'badge-warning' : 'badge-success'} gap-1" title="Full refresh: ${escapeHtml(lastRefreshLabel)}">‚è±Ô∏è Quick: ${escapeHtml(quickLabelWithStale)}</span>
                    </div>
                    ${reachabilityMarkup}
                    ${locationLine}
                    <!-- Always visible: Basic system info -->
                    <div class="flex gap-4 flex-wrap mb-1">
                        <div><span class="text-xs text-info font-semibold">‚è±Ô∏è Uptime:</span> <span class="font-bold text-sm text-primary">${highlightMatch(uptimeLabel, searchTerm)}</span></div>
                        <div><span class="text-xs text-info font-semibold">üñ•Ô∏è CPU Load:</span> <span class="font-bold text-sm ${cpuValue >= 90 ? 'text-error' : cpuValue >= 70 ? 'text-warning' : 'text-success'}">${highlightMatch(cpuLoadLabel, searchTerm)}</span></div>
                    </div>
                    <div class="flex gap-4 flex-wrap mb-1">
                        <div><span class="text-xs text-secondary font-semibold">üíø OS Version:</span> <span class="font-bold text-sm text-accent">${highlightMatch(data.os_info?.os_version || 'Unknown', searchTerm)}</span></div>
                    </div>
                    <div class="flex gap-4 flex-wrap mb-1">
                        <div><span class="text-xs text-info font-semibold">üß† Total RAM:</span> <span class="font-bold text-sm text-primary">${totalMemGb > 0 ? `${totalMemGb} GB` : 'Unknown'}</span></div>
                        <div><span class="text-xs text-info font-semibold">üìä RAM Usage:</span> <span class="font-bold text-sm ${memPercent >= 80 ? 'text-error' : memPercent >= 65 ? 'text-warning' : 'text-success'}">${usedMemGb > 0 ? `${usedMemGb} GB` : 'Unknown'} (${Math.round(memPercent)}%)</span></div>
                    </div>
                    <!-- Hidden until expanded: Detailed info -->
                    <div class="card-details flex gap-4 flex-wrap mb-1">
                        <div><span class="text-xs text-accent font-semibold">‚öôÔ∏è Processes:</span> <span class="font-bold text-sm text-primary">${processCount}</span></div>
                        <div><span class="text-xs text-accent font-semibold">üî• High CPU (&gt; ${highCpuThreshold}%):</span> <span class="font-bold text-sm ${highCpuCount > 0 ? 'text-warning' : 'text-success'}">${highCpuCount > 0 ? highCpuNames : 'None'}</span></div>
                    </div>
                    <div class="card-details flex flex-col gap-1 mb-2">
                        <div><span class="text-xs text-secondary font-semibold">üåê IP:</span> <span class="font-bold text-sm text-info">${highlightMatch(primaryIp, searchTerm)}</span></div>
                        <div><span class="text-xs text-secondary font-semibold">üì° Subnet:</span> <span class="font-bold text-sm text-info">${highlightMatch(primarySubnet, searchTerm)}</span></div>
                        <div><span class="text-xs text-secondary font-semibold">üö™ Gateway:</span> <span class="font-bold text-sm text-info">${highlightMatch(primaryGateway, searchTerm)}</span></div>
                        <div><span class="text-xs text-secondary font-semibold">üîç DNS:</span> <span class="font-bold text-sm text-info">${highlightMatch(primaryDns, searchTerm)}</span></div>
                    </div>
                    <div class="server-services card-details">
                        <div class="metric-label text-primary font-semibold">üîß Services Status:</div>
                        <div class="services-summary">
                            <span class="text-success font-semibold">‚úì ${runningServices.length} Running</span>
                            ${stoppedServices.length > 0 ?
                        `<span class="text-error font-semibold">‚úó ${stoppedServices.length} Stopped</span>` :
                        '<span class="text-success font-semibold">All OK</span>'}
                        </div>
                        ${serviceStatus.length > 0 ? `
                        <div class="mt-2 text-sm text-base-content/60 leading-relaxed">
                            ${serviceStatus.map(s => {
                            const status = (s.status || '').toLowerCase();
                            const colorClass = status === 'running' ? 'text-success' : 'text-error';
                            const label = `${s.name || 'Unknown'}: ${s.status || 'Unknown'}`;
                            return `<div class="${colorClass}">${highlightMatch(label, searchTerm)}</div>`;
                        }).join('')}
                        </div>` : ''}
                    </div>
                    ${data.disks && data.disks.length > 0 ? `
                    <div class="card-details mt-3">
                        <div class="metric-label text-primary font-semibold">üíæ Disk Space:</div>
                        <div class="text-sm text-base-content/90 leading-relaxed">
                            ${data.disks.map(d => {
                            const pct = d.percent_free ? Math.round(d.percent_free * 10) / 10 : 0;
                            const colorClass = pct < 10 ? 'text-error' : pct < 20 ? 'text-warning' : 'text-success';
                            const free = typeof d.free_gb === 'number' ? d.free_gb.toFixed(1) : '0';
                            const total = typeof d.total_gb === 'number' ? d.total_gb.toFixed(1) : '0';
                            const diskLabel = `${d.drive || ''} - ${free} GB free of ${total} GB (${pct}% free)`;
                            return `<div>${highlightMatch(diskLabel, searchTerm)} <span class="${colorClass}">‚óè</span></div>`;
                        }).join('')}
                        </div>
                    </div>` : ''}
                    ${errorsMarkup}
                    <div class="qp-card-actions">
                        <div class="qp-card-actions-row">
                            <button class="refresh-btn">üîÑ Refresh</button>
                            <button class="edit-host-btn">‚úèÔ∏è Edit</button>
                            <button class="rdp-creds-btn">üîë Host Creds</button>
                        </div>
                        <div class="qp-card-actions-row">
                            <div class="dropdown dropdown-end">
                                <button tabindex="0" class="manage-btn">‚öôÔ∏è Manage</button>
                                <ul tabindex="0" class="dropdown-content menu bg-base-200 rounded-box z-50 w-52 p-2 shadow-lg border border-base-300">
                                    <li><a class="manage-services-btn">${isLinux ? 'üêß Manage Services (systemd)' : 'üîß Manage Services'}</a></li>
                                    <li><a class="manage-processes-btn">${isLinux ? 'üêß Manage Processes (top)' : 'üìä Manage Processes'}</a></li>
                                    <li><a class="remote-shell-btn">${isLinux ? 'üêß Remote SSH' : 'üíª Remote PowerShell'}</a></li>
                                    ${!isLinux ? '<li><a class="explore-share-btn">üìÅ Explore C$</a></li>' : ''}
                                </ul>
                            </div>
                        </div>
                    </div>
                    </div>
                `;

                const refreshBtn = card.querySelector('.refresh-btn');
                if (refreshBtn) {
                    refreshBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        // Disable button IMMEDIATELY to prevent double-submit (Issue #5)
                        if (refreshBtn.disabled) return;
                        refreshBtn.disabled = true;
                        refreshBtn.textContent = '‚è≥ Refreshing';
                        refreshServer(server.name, refreshBtn);
                    });
                }

                const editBtn = card.querySelector('.edit-host-btn');
                if (editBtn) {
                    editBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        editHost(server.name);
                    });
                }

                const credsBtn = card.querySelector('.rdp-creds-btn');
                if (credsBtn) {
                    credsBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        setHostCredentials(server.name);
                    });
                }

                // Manage Services button handler
                const manageServicesBtn = card.querySelector('.manage-services-btn');
                if (manageServicesBtn) {
                    manageServicesBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        openManageServicesModal(server.name);
                    });
                }

                // Manage Processes button handler
                const manageProcessesBtn = card.querySelector('.manage-processes-btn');
                if (manageProcessesBtn) {
                    manageProcessesBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        openManageProcessesModal(server.name);
                    });
                }

                // Remote Shell button handler (PowerShell for Windows, SSH for Linux)
                const remoteShellBtn = card.querySelector('.remote-shell-btn');
                if (remoteShellBtn) {
                    remoteShellBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        if (isLinux) {
                            openRemoteSshModal(server.name);
                        } else {
                            openRemotePowerShellModal(server.name);
                        }
                    });
                }

                // Explore C$ share button handler (Windows only)
                const exploreShareBtn = card.querySelector('.explore-share-btn');
                if (exploreShareBtn) {
                    exploreShareBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        try {
                            await window.__TAURI__.core.invoke('open_explorer_share', { server: server.name });
                            showNotification(`Opening Explorer to \\\\${server.name}\\C$`, 'success');
                        } catch (err) {
                            showNotification(`Failed to open Explorer: ${err}`, 'error');
                            logDebug(`open_explorer_share failed for ${server.name}: ${err}`);
                        }
                    });
                }

                return card;
            }

            const data = server.data || {};
            const heartbeatWinrmIssue = heartbeat && heartbeat.winrm_ok === false && heartbeat.ping_ok;
            const isWinrmIssue = !!data.winrm_issue || !!heartbeatWinrmIssue;
            // Only show WinRM badge for Windows hosts - Linux uses SSH
            const winrmBadge = (!isLinux && isWinrmIssue) ? '<span class="badge badge-warning gap-1">‚ö†Ô∏è WINRM ISSUE</span>' : '';
            const onlineBadge = '<span class="badge badge-success gap-1">‚úì ONLINE</span>';
            const lastRefreshLabel = formatTimestamp(server.lastRefreshed || server.lastHeartbeat || heartbeat?.updated_at);
            const quickLabelRaw = heartbeat?.updated_at
                ? formatTimestamp(heartbeat.updated_at)
                : (server.lastRefreshed ? formatTimestamp(server.lastRefreshed) : 'No quick probe');
            const quickStale = heartbeat?.updated_at ? (Date.now() - Date.parse(heartbeat.updated_at) > HEARTBEAT_STALE_MS) : true;
            const quickLabel = quickStale ? `${quickLabelRaw} (stale)` : quickLabelRaw;
            const winrmErrorRaw = heartbeat?.winrm_error?.toString?.() || (data.winrm_error ? data.winrm_error.toString() : '');
            const diskAlertCount = data.disk_alerts ? data.disk_alerts.length : 0;
            const totalDisks = data.disks ? data.disks.length : (data.total_disks || 0);
            const rawServiceStatus = Array.isArray(data.service_status)
                ? data.service_status
                : (data.service_status ? [data.service_status] : []);
            // Filter out "NotFound" services - these are platform-specific services that don't exist on this host
            const serviceStatus = rawServiceStatus.filter(s => s?.status && s.status.toLowerCase() !== 'notfound');
            const stoppedServices = serviceStatus.filter(s => {
                if (!s?.status) return true;
                const status = s.status.toLowerCase();
                return status !== 'running';
            });
            const runningServices = serviceStatus.filter(s => s?.status && s.status.toLowerCase() === 'running');

            const highCpuThreshold = typeof data.high_cpu_threshold === 'number'
                ? data.high_cpu_threshold
                : 50;
            const highCpuProcesses = Array.isArray(data.high_cpu_processes)
                ? data.high_cpu_processes
                    .filter(p => typeof p.cpu_percent === 'number' && p.cpu_percent > highCpuThreshold)
                    .sort((a, b) => (b.cpu_percent || 0) - (a.cpu_percent || 0))
                    .slice(0, 3)
                : [];
            const highCpuCount = highCpuProcesses.length;
            const highCpuNames = highCpuProcesses.length > 0
                ? highCpuProcesses.map(p => `${p.name || 'Unknown'} (${Math.round(p.cpu_percent)}%)`).join(', ')
                : '';
            const processCount = typeof data.process_count === 'number' ? data.process_count : 0;
            const totalMemMb = typeof data.total_memory_mb === 'number' ? data.total_memory_mb : 0;
            const heartbeatMemPercent = typeof heartbeat?.memory_used_percent === 'number' ? heartbeat.memory_used_percent : null;
            const usedMemMb = typeof data.used_memory_mb === 'number' ? data.used_memory_mb : 0;
            let memPercent = typeof data.memory_used_percent === 'number' ? data.memory_used_percent : (heartbeatMemPercent ?? 0);
            let adjustedUsedMemMb = usedMemMb;
            if (!adjustedUsedMemMb && totalMemMb > 0 && memPercent > 0) {
                adjustedUsedMemMb = (memPercent / 100) * totalMemMb;
            }
            const totalMemGb = Math.round((totalMemMb / 1024) * 10) / 10;
            const usedMemGb = Math.round((adjustedUsedMemMb / 1024) * 10) / 10;

            const heartbeatUptime = typeof heartbeat?.uptime_hours === 'number' ? heartbeat.uptime_hours : null;
            const heartbeatCpu = typeof heartbeat?.cpu_load_pct === 'number' ? heartbeat.cpu_load_pct : null;
            const dataUptime = typeof data.uptime?.uptime_hours === 'number' ? data.uptime.uptime_hours : null;
            const uptimeValue = dataUptime !== null ? dataUptime : heartbeatUptime;
            // Debug log uptime source (uncomment to troubleshoot)
            // console.log(`[UPTIME-RENDER] ${server.name}: dataUptime=${dataUptime}, heartbeatUptime=${heartbeatUptime}, using=${uptimeValue}`);
            const uptimeLabel = Number.isFinite(uptimeValue) ? humanizeUptime(uptimeValue) : 'Unknown';
            const cpuValue = typeof data.uptime?.cpu_load_pct === 'number' ? data.uptime.cpu_load_pct : heartbeatCpu;
            const cpuLoadLabel = Number.isFinite(cpuValue) ? `${Math.round(cpuValue)}% CPU` : 'Unknown CPU';
            const pendingSignals = Array.isArray(data.pending_reboot?.signals) ? data.pending_reboot.signals : [];
            const pendingTooltip = pendingSignals.length > 0 ? pendingSignals.join(', ') : 'Reboot signals detected';
            const pendingBadge = data.pending_reboot?.pending ? `<span class="badge badge-warning gap-1" title="${escapeHtml(pendingTooltip)}">üîÑ Reboot Pending</span>` : '';

            const errorsMarkup = Array.isArray(data.recent_errors) && data.recent_errors.length > 0 ? `
                <div class="card-details mt-2">
                    <div class="metric-label text-error font-semibold">‚ö†Ô∏è Recent Critical/Errors (last 30m)</div>
                    <div class="text-sm text-base-content/90 leading-relaxed max-h-40 overflow-auto">
                        ${data.recent_errors.slice(0, 5).map(e => {
                const label = `${e.log} ${e.id} ${formatTimestamp(e.time_created)} ${e.provider}`;
                const msg = e.message || '';
                return `<div class="mb-2">${highlightMatch(label, searchTerm)}<br><span class="text-base-content/60">${highlightMatch(msg, searchTerm)}</span></div>`;
            }).join('')}
                    </div>
                </div>` : '';

            const rawAdapters = Array.isArray(data.net_adapters) ? data.net_adapters : [];
            const adapters = rawAdapters.map((a) => {
                const trimList = (arr) =>
                    Array.isArray(arr)
                        ? arr.map((v) => (typeof v === 'string' ? v.trim() : v)).filter((v) => v)
                        : [];
                return {
                    alias: typeof a.alias === 'string' ? a.alias.trim() : a.alias,
                    description: typeof a.description === 'string' ? a.description.trim() : a.description,
                    ipv4: trimList(a.ipv4),
                    ipv4_prefix: trimList(a.ipv4_prefix),
                    ipv6: trimList(a.ipv6),
                    dns: trimList(a.dns),
                    gateway: trimList(a.gateway),
                };
            });
            const prefixToMask = (prefix) => {
                const n = Number(prefix);
                if (!Number.isFinite(n) || n < 0 || n > 32) return '';
                const mask = (0xffffffff << (32 - n)) >>> 0;
                return `${(mask >>> 24) & 255}.${(mask >>> 16) & 255}.${(mask >>> 8) & 255}.${mask & 255}`;
            };
            const selectPrimaryNetwork = (list) => {
                if (!Array.isArray(list) || list.length === 0) return null;
                const scored = list.map((a, idx) => {
                    const ipv4 = Array.isArray(a.ipv4) ? a.ipv4 : [];
                    const prefixes = Array.isArray(a.ipv4_prefix) ? a.ipv4_prefix : [];
                    const ipv6 = Array.isArray(a.ipv6) ? a.ipv6 : [];
                    const gateway = Array.isArray(a.gateway) ? a.gateway : [];
                    const dns = Array.isArray(a.dns) ? a.dns : [];
                    const ipv4Entries = ipv4.map((addr, i) => ({
                        addr,
                        prefix: Number(prefixes[i])
                    })).filter(e => e.addr);
                    const score = (ipv4Entries.length ? 10 : 0) + (gateway.length ? 5 : 0) + (dns.length ? 1 : 0);
                    return { adapter: a, ipv4Entries, ipv6, gateway, dns, score, order: idx };
                }).sort((a, b) => {
                    if (b.score === a.score) return a.order - b.order;
                    return b.score - a.score;
                });
                return scored[0] || null;
            };

            const primary = selectPrimaryNetwork(adapters);
            let primaryIp = 'Unknown';
            let primarySubnet = 'Unknown';
            let primaryGateway = 'Unknown';
            let primaryDns = 'Unknown';

            if (primary) {
                const ipv4Entry = primary.ipv4Entries.find(e => typeof e.addr === 'string' && e.addr.trim().length > 0);
                const ipv6Entry = Array.isArray(primary.ipv6) && primary.ipv6.length > 0
                    ? primary.ipv6.find(ip => typeof ip === 'string' && ip.trim().length > 0)
                    : null;
                const chosen = ipv4Entry || (ipv6Entry ? { addr: ipv6Entry, prefix: undefined } : null);
                if (chosen && typeof chosen.addr === 'string') {
                    primaryIp = chosen.addr.trim();
                    if (ipv4Entry && Number.isFinite(ipv4Entry.prefix) && ipv4Entry.prefix > 0) {
                        const mask = prefixToMask(ipv4Entry.prefix);
                        primarySubnet = mask ? `${mask} (/${ipv4Entry.prefix})` : `/${ipv4Entry.prefix}`;
                    }
                }
                const gw = Array.isArray(primary.gateway) ? primary.gateway.find(g => g && g.trim().length > 0) : null;
                if (gw) primaryGateway = gw;
                const dnsList = Array.isArray(primary.dns)
                    ? primary.dns
                        .map(d => (typeof d === 'string' ? d.trim() : d))
                        .filter(d => d && d !== '::1')
                    : [];
                if (dnsList.length > 0) primaryDns = dnsList.join(', ');
            }

            const reachabilityMarkup = renderReachabilityRow(server);

            card.innerHTML = `
                <div class="card-body">
                <div class="server-card-header flex justify-between items-center gap-2 flex-wrap">
                    <div class="flex items-center gap-2 flex-nowrap min-w-0">
                        <div class="server-name whitespace-nowrap">${highlightedName}</div>
                    </div>
                    <div class="flex gap-2 items-center flex-wrap">
                        ${statusBadge}
                        ${pendingBadge}
                        ${winrmBadge}
                        ${onlineBadge}
                    </div>
                </div>
                ${groupMarkup}
                ${server.notes ? `<div class="text-base-content/60 text-sm mb-3 italic">üìù ${highlightMatch(server.notes, searchTerm)}</div>` : ''}
                <div class="last-refresh flex gap-2 flex-wrap items-center">
                    <span class="badge ${quickStale ? 'badge-warning' : 'badge-success'} gap-1" title="Full refresh: ${escapeHtml(lastRefreshLabel)}">‚è±Ô∏è Quick: ${escapeHtml(quickLabel)}</span>
                </div>
                ${reachabilityMarkup}
                ${locationLine}
                <!-- Always visible: Basic system info -->
                <div class="flex gap-4 flex-wrap mb-1">
                    <div><span class="text-xs text-info font-semibold">‚è±Ô∏è Uptime:</span> <span class="font-bold text-sm text-primary">${highlightMatch(uptimeLabel, searchTerm)}</span></div>
                    <div><span class="text-xs text-info font-semibold">üñ•Ô∏è CPU Load:</span> <span class="font-bold text-sm ${cpuValue >= 90 ? 'text-error' : cpuValue >= 70 ? 'text-warning' : 'text-success'}">${highlightMatch(cpuLoadLabel, searchTerm)}</span></div>
                </div>
                <div class="flex gap-4 flex-wrap mb-1">
                    <div><span class="text-xs text-secondary font-semibold">üíø OS Version:</span> <span class="font-bold text-sm text-accent">${highlightMatch(data.os_info?.os_version || 'Unknown', searchTerm)}</span></div>
                </div>
                <div class="flex gap-4 flex-wrap mb-1">
                    <div><span class="text-xs text-info font-semibold">üß† Total RAM:</span> <span class="font-bold text-sm text-primary">${totalMemGb > 0 ? `${totalMemGb} GB` : 'Unknown'}</span></div>
                    <div><span class="text-xs text-info font-semibold">üìä RAM Usage:</span> <span class="font-bold text-sm ${memPercent >= 80 ? 'text-error' : memPercent >= 65 ? 'text-warning' : 'text-success'}">${usedMemGb > 0 ? `${usedMemGb} GB` : 'Unknown'} (${Math.round(memPercent)}%)</span></div>
                </div>
                <!-- Hidden until expanded: Detailed info -->
                <div class="card-details flex gap-4 flex-wrap mb-1">
                    <div><span class="text-xs text-accent font-semibold">‚öôÔ∏è Processes:</span> <span class="font-bold text-sm text-primary">${processCount}</span></div>
                    <div><span class="text-xs text-accent font-semibold">üî• High CPU (&gt; ${highCpuThreshold}%):</span> <span class="font-bold text-sm ${highCpuCount > 0 ? 'text-warning' : 'text-success'}">${highCpuCount > 0 ? highCpuNames : 'None'}</span></div>
                </div>
                <div class="card-details flex flex-col gap-1 mb-2">
                    <div><span class="text-xs text-secondary font-semibold">üåê IP:</span> <span class="font-bold text-sm text-info">${highlightMatch(primaryIp, searchTerm)}</span></div>
                    <div><span class="text-xs text-secondary font-semibold">üì° Subnet:</span> <span class="font-bold text-sm text-info">${highlightMatch(primarySubnet, searchTerm)}</span></div>
                    <div><span class="text-xs text-secondary font-semibold">üö™ Gateway:</span> <span class="font-bold text-sm text-info">${highlightMatch(primaryGateway, searchTerm)}</span></div>
                    <div><span class="text-xs text-secondary font-semibold">üîç DNS:</span> <span class="font-bold text-sm text-info">${highlightMatch(primaryDns, searchTerm)}</span></div>
                </div>
                <div class="server-services card-details">
                    <div class="metric-label text-primary font-semibold">üîß Services Status:</div>
                    <div class="services-summary">
                        <span class="text-success font-semibold">‚úì ${runningServices.length} Running</span>
                        ${stoppedServices.length > 0 ?
                    `<span class="text-error font-semibold">‚úó ${stoppedServices.length} Stopped</span>` :
                    '<span class="text-success font-semibold">All OK</span>'}
                    </div>
                    ${serviceStatus.length > 0 ? `
                    <div class="mt-2 text-sm text-base-content/60 leading-relaxed">
                        ${serviceStatus.map(s => {
                        const status = (s.status || '').toLowerCase();
                        const colorClass = status === 'running' ? 'text-success' : 'text-error';
                        const label = `${s.name || 'Unknown'}: ${s.status || 'Unknown'}`;
                        return `<div class="${colorClass}">${highlightMatch(label, searchTerm)}</div>`;
                    }).join('')}
                    </div>` : ''}
                </div>
                ${data.disks && data.disks.length > 0 ? `
                <div class="card-details mt-3">
                    <div class="metric-label text-primary font-semibold">üíæ Disk Space:</div>
                    <div class="text-sm text-base-content/90 leading-relaxed">
                        ${data.disks.map(d => {
                        const pct = d.percent_free ? Math.round(d.percent_free * 10) / 10 : 0;
                        const colorClass = pct < 10 ? 'text-error' : pct < 20 ? 'text-warning' : 'text-success';
                        const free = typeof d.free_gb === 'number' ? d.free_gb.toFixed(1) : '0';
                        const total = typeof d.total_gb === 'number' ? d.total_gb.toFixed(1) : '0';
                        const diskLabel = `${d.drive || ''} - ${free} GB free of ${total} GB (${pct}% free)`;
                        return `<div>${highlightMatch(diskLabel, searchTerm)} <span class="${colorClass}">‚óè</span></div>`;
                    }).join('')}
                    </div>
                </div>` : ''}
                ${errorsMarkup}
                <div class="qp-card-actions">
                    <div class="qp-card-actions-row">
                        <button class="refresh-btn">üîÑ Refresh</button>
                        <button class="edit-host-btn">‚úèÔ∏è Edit</button>
                        <button class="rdp-creds-btn">üîë Host Creds</button>
                    </div>
                    <div class="qp-card-actions-row">
                        <div class="dropdown dropdown-end">
                            <button tabindex="0" class="manage-btn">‚öôÔ∏è Manage</button>
                            <ul tabindex="0" class="dropdown-content menu bg-base-200 rounded-box z-50 w-52 p-2 shadow-lg border border-base-300">
                                <li><a class="manage-services-btn">${isLinux ? 'üêß Manage Services (systemd)' : 'üîß Manage Services'}</a></li>
                                <li><a class="manage-processes-btn">${isLinux ? 'üêß Manage Processes (top)' : 'üìä Manage Processes'}</a></li>
                                <li><a class="remote-shell-btn">${isLinux ? 'üêß Remote SSH' : 'üíª Remote PowerShell'}</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
                </div>
            `;

            const refreshBtn = card.querySelector('.refresh-btn');
            if (refreshBtn) {
                refreshBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Disable button IMMEDIATELY to prevent double-submit (Issue #5)
                    if (refreshBtn.disabled) return;
                    refreshBtn.disabled = true;
                    refreshBtn.textContent = '‚è≥ Refreshing';
                    refreshServer(server.name, refreshBtn);
                });
            }

            const editBtn = card.querySelector('.edit-host-btn');
            if (editBtn) {
                editBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    editHost(server.name);
                });
            }

            const credsBtn = card.querySelector('.rdp-creds-btn');
            if (credsBtn) {
                credsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    setHostCredentials(server.name);
                });
            }

            // Manage Services button handler
            const manageServicesBtn = card.querySelector('.manage-services-btn');
            if (manageServicesBtn) {
                manageServicesBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    openManageServicesModal(server.name);
                });
            }

            // Manage Processes button handler
            const manageProcessesBtn = card.querySelector('.manage-processes-btn');
            if (manageProcessesBtn) {
                manageProcessesBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    openManageProcessesModal(server.name);
                });
            }

            // Remote Shell button handler (PowerShell for Windows, SSH for Linux)
            const remoteShellBtn = card.querySelector('.remote-shell-btn');
            if (remoteShellBtn) {
                remoteShellBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    if (isLinux) {
                        openRemoteSshModal(server.name);
                    } else {
                        openRemotePowerShellModal(server.name);
                    }
                });
            }

            return card;
        }

        async function editServerNotes(serverName, currentNotes) {
            if (!openNotesDialog) {
                showError('Notes dialog unavailable. Please reload the dashboard.');
                return;
            }

            if (noteSaveBusy) {
                showError('Note save already in progress');
                return;
            }

            triggerQuickProbe(serverName, 'edit-notes');

            const result = await openNotesDialog(serverName, currentNotes || '');
            if (!result || result.notes === undefined || result.notes === null) {
                return; // User cancelled
            }

            // Check if notes actually changed
            const trimmedNew = (result.notes || '').trim();
            const trimmedOld = (currentNotes || '').trim();
            if (trimmedNew === trimmedOld) {
                return; // No change
            }

            if (!window.__TAURI__) {
                showError('Tauri API not available');
                return;
            }

            const { invoke } = window.__TAURI__.core;
            noteSaveBusy = true;
            const previousData = serversData.map(s => ({ ...s }));

            try {
                await invoke('save_server_notes', {
                    serverName: serverName,
                    notes: result.notes
                });

                // Update local cache immediately so the card reflects the change
                serversData = serversData.map((s) => {
                    if (s.name !== serverName) return s;
                    return {
                        ...s,
                        notes: result.notes
                    };
                });
                cacheDashboardData();
                displayAllServers();
                showInfo('Notes saved');

                // Also kick off a background refresh to keep cache consistent
                loadAllServers({ silent: true });
            } catch (error) {
                showError('Failed to save notes: ' + error);
                // Rollback on error
                serversData = previousData;
                cacheDashboardData();
                displayAllServers();
            } finally {
                noteSaveBusy = false;
            }
        }

        async function deleteHostFromDashboard(serverName) {
            if (!serverName) {
                showError('Server name is required');
                return;
            }

            if (!window.__TAURI__) {
                showError('Tauri API not available');
                return;
            }

            const { invoke } = window.__TAURI__.core;
            const previousServersData = serversData.map(s => ({ ...s }));
            const previousHostsByName = new Map(hostsByName);

            try {
                // Build updated hosts list without the deleted host
                const updatedHosts = [];
                hostsByName.forEach((host, name) => {
                    if (name !== serverName) {
                        updatedHosts.push({
                            name: host.name,
                            notes: host.notes || null,
                            group: host.group || host.box || null,
                            services: Array.isArray(host.services) ? host.services : null,
                            os_type: host.os_type || host.os || 'Windows'
                        });
                    }
                });

                // Call set_hosts with the updated list
                await invoke('set_hosts', { hosts: updatedHosts });

                // Update local caches
                serversData = serversData.filter(s => s.name !== serverName);
                hostsByName.delete(serverName);

                // Remove the card from DOM without refreshing the entire view
                const cardToRemove = document.querySelector(`.server-card[data-server="${serverName}"]`);
                if (cardToRemove) {
                    cardToRemove.remove();
                }

                // Also remove from group view if present
                const groupCardToRemove = document.querySelector(`.group-card-hosts .server-card[data-server="${serverName}"]`);
                if (groupCardToRemove) {
                    groupCardToRemove.remove();
                }

                // Update summary stats without changing the current filter/view
                const summary = Utils.summarize(serversData);
                updateSummaryCards(summary);

                cacheDashboardData();
                showInfo(`Host "${serverName}" deleted`);

            } catch (error) {
                showError('Failed to delete host: ' + error);
                // Rollback on error
                serversData = previousServersData;
                hostsByName.clear();
                previousHostsByName.forEach((v, k) => hostsByName.set(k, v));
            }
        }

        async function editHost(serverName) {
            if (!openEditHostDialog) {
                showError('Edit host dialog unavailable. Please reload the dashboard.');
                return;
            }

            if (editHostBusy) {
                showError('Edit already in progress');
                return;
            }

            // Find current server data
            const server = serversData.find(s => s.name === serverName);
            if (!server) {
                showError('Server not found: ' + serverName);
                return;
            }

            // Get host metadata for services
            const hostMeta = hostsByName.get(serverName);

            triggerQuickProbe(serverName, 'edit-host');

            const currentData = {
                notes: server.notes || '',
                group: server.group || server.box || '',
                os_type: server.os_type || server.os || hostMeta?.os_type || hostMeta?.os || 'Windows',
                services: Array.isArray(server.services) ? server.services : (
                    Array.isArray(hostMeta?.services) ? hostMeta.services : []
                )
            };

            const result = await openEditHostDialog(serverName, currentData);
            if (!result) {
                editHostServerName = null;
                return; // User cancelled
            }

            // Handle delete action
            if (result.action === 'delete') {
                editHostServerName = null;
                await deleteHostFromDashboard(serverName);
                return;
            }

            // Check if anything actually changed
            const newNotes = (result.notes || '').trim();
            const newGroup = (result.group || '').trim();
            const newOs = (result.os || 'Windows').trim();
            const newServices = (result.services || '').split(';')
                .map(s => s.trim())
                .filter(s => s.length > 0);

            const oldNotes = (currentData.notes || '').trim();
            const oldGroup = (currentData.group || '').trim();
            const oldOs = (currentData.os_type || 'Windows').trim();
            const oldServices = Array.isArray(currentData.services) ? currentData.services : [];

            const notesChanged = newNotes !== oldNotes;
            const groupChanged = newGroup !== oldGroup;
            const osChanged = newOs.toLowerCase() !== oldOs.toLowerCase();
            const servicesChanged = JSON.stringify(newServices.sort()) !== JSON.stringify(oldServices.map(s => s.trim()).sort());

            if (!notesChanged && !groupChanged && !osChanged && !servicesChanged) {
                return; // No change
            }

            if (!window.__TAURI__) {
                showError('Tauri API not available');
                return;
            }

            const { invoke } = window.__TAURI__.core;
            editHostBusy = true;
            const previousData = serversData.map(s => ({ ...s }));

            try {
                await invoke('update_host', {
                    serverName: serverName,
                    notes: newNotes || null,
                    group: newGroup || null,
                    osType: newOs,
                    services: newServices.length > 0 ? newServices : null
                });

                // Update local cache immediately so the card reflects the change
                serversData = serversData.map((s) => {
                    if (s.name !== serverName) return s;
                    return {
                        ...s,
                        notes: newNotes,
                        group: newGroup,
                        box: newGroup, // Keep both for compatibility
                        os_type: newOs,
                        os: newOs, // Keep both for compatibility
                        services: newServices
                    };
                });

                // Also update hostsByName cache
                const existingHost = hostsByName.get(serverName);
                if (existingHost) {
                    hostsByName.set(serverName, {
                        ...existingHost,
                        notes: newNotes,
                        group: newGroup,
                        box: newGroup,
                        os_type: newOs,
                        os: newOs,
                        services: newServices
                    });
                }

                cacheDashboardData();
                displayAllServers();
                showInfo('Host updated');

                // Also kick off a background refresh to keep cache consistent
                loadAllServers({ silent: true });
            } catch (error) {
                showError('Failed to update host: ' + error);
                // Rollback on error
                serversData = previousData;
                cacheDashboardData();
                displayAllServers();
            } finally {
                editHostBusy = false;
                editHostServerName = null;
            }
        }

        function updateSearchMeta(filteredCount) {
            const meta = document.getElementById('search-meta');
            if (!meta) return;

            const total = serversData.length;
            const term = searchTerm.trim();
            const filterLabel = activeFilterLabel(activeFilter?.type);

            if (!term) {
                if (filterLabel) {
                    meta.textContent = `Showing ${filteredCount} of ${total} servers (Filter: ${filterLabel})`;
                } else {
                    meta.textContent = `Showing all ${total} servers`;
                }
                return;
            }

            if (filteredCount === 0) {
                meta.textContent = `No matches for "${term}"${filterLabel ? ` with filter ${filterLabel}` : ''}`;
                return;
            }

            const filterText = filterLabel ? ` (Filter: ${filterLabel})` : '';
            meta.textContent = `Showing ${filteredCount} of ${total} servers (Search: "${term}")${filterText}`;
        }

        function showLoading() {
            const el = document.getElementById('loading');
            el.classList.remove('hidden');
            el.style.display = '';
        }

        function hideLoading() {
            const el = document.getElementById('loading');
            el.classList.add('hidden');
            el.style.display = 'none';
        }

        function pushNotification(message, type = 'info', options = {}) {
            const stack = document.getElementById('notification-stack');
            if (!stack || !message) return;

            const note = document.createElement('div');
            // Map types to DaisyUI alert classes
            const alertClass = type === 'error' ? 'alert-error' : type === 'warning' ? 'alert-warning' : 'alert-info';
            note.className = `alert ${alertClass} shadow-lg`;
            note.dataset.type = type;

            // Add icon SVG
            const icon = document.createElement('svg');
            icon.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            icon.setAttribute('class', 'stroke-current shrink-0 h-6 w-6');
            icon.setAttribute('fill', 'none');
            icon.setAttribute('viewBox', '0 0 24 24');

            if (type === 'error') {
                icon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />';
            } else if (type === 'warning') {
                icon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />';
            } else {
                icon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />';
            }

            const text = document.createElement('span');
            text.textContent = message;

            const closeBtn = document.createElement('button');
            closeBtn.className = 'btn btn-sm btn-ghost btn-circle';
            closeBtn.type = 'button';
            closeBtn.setAttribute('aria-label', 'Dismiss notification');
            closeBtn.textContent = '‚úï';
            closeBtn.addEventListener('click', () => note.remove());

            note.appendChild(icon);
            note.appendChild(text);
            note.appendChild(closeBtn);
            stack.appendChild(note);

            const timeoutMs = options.timeoutMs;
            if (Number.isFinite(timeoutMs) && timeoutMs > 0) {
                setTimeout(() => {
                    note.remove();
                }, timeoutMs);
            }
        }

        function clearNotifications(types = ['info', 'warning']) {
            const stack = document.getElementById('notification-stack');
            if (!stack) return;
            const allowed = new Set(types);
            Array.from(stack.children).forEach(child => {
                if (allowed.has(child.dataset.type)) {
                    child.remove();
                }
            });
        }

        function showError(message) {
            const timeoutMs = Number(settings?.errorTimeoutMs) > 0 ? Number(settings.errorTimeoutMs) : null;
            pushNotification(message, 'error', { timeoutMs });
        }

        function hideError() {
            // Keep error notifications persistent; only clear info/warning banners.
            clearNotifications(['info', 'warning']);
        }

        function showLoadError(message) {
            setLastRefreshStatus('fail', 'Unable to load hosts');
            const state = document.getElementById('load-error-state');
            const text = document.getElementById('load-error-text');
            if (text) {
                text.textContent = message || 'Please retry or edit hosts.';
            }
            if (state) {
                state.classList.remove('hidden');
            }
            hideEmptyState();
            const grid = document.getElementById('servers-grid');
            if (grid) {
                grid.innerHTML = '';
                grid.classList.add('hidden');
            }
            const summary = document.getElementById('summary-stats');
            if (summary) {
                summary.classList.add('hidden');
            }
            const searchMeta = document.getElementById('search-meta');
            if (searchMeta) {
                searchMeta.textContent = 'Unable to load hosts.';
            }
        }

        function hideLoadError() {
            const state = document.getElementById('load-error-state');
            if (state) {
                state.classList.add('hidden');
            }
        }

        function showEmptyState(message = 'No hosts configured yet.') {
            const empty = document.getElementById('empty-state');
            if (empty) {
                const title = empty.querySelector('.empty-state-title');
                if (title) title.textContent = message;
                empty.classList.remove('hidden');
            }
            const grid = document.getElementById('servers-grid');
            if (grid) {
                grid.innerHTML = '';
                grid.classList.add('hidden');
            }
            const summary = document.getElementById('summary-stats');
            if (summary) {
                summary.classList.add('hidden');
            }
            const searchMeta = document.getElementById('search-meta');
            if (searchMeta) {
                searchMeta.textContent = message;
            }
        }

        function hideEmptyState() {
            const empty = document.getElementById('empty-state');
            if (empty) {
                empty.classList.add('hidden');
            }
        }

        function showInfo(message, fallbackMs = 3500) {
            const timeoutMs = Number(settings?.infoTimeoutMs) >= 0 ? Number(settings.infoTimeoutMs) : fallbackMs;
            pushNotification(message, 'info', { timeoutMs });
        }

        function showWarning(message, fallbackMs = 4500) {
            const timeoutMs = Number(settings?.warningTimeoutMs) >= 0 ? Number(settings.warningTimeoutMs) : fallbackMs;
            pushNotification(message, 'warning', { timeoutMs });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Renders the probe status row for a server card.
         *
         * Probe hierarchy (most comprehensive wins):
         * 1. WinRM/SSH - Full remote session succeeded, comprehensive data available
         * 2. Degraded - Remote session failed but server is reachable (ping/TCP ok)
         * 3. Unreachable - All probe methods failed
         *
         * For successful probes (WinRM/SSH), we only show the method badge.
         * For degraded/unreachable, we show detailed reachability to help troubleshoot.
         */
        function renderReachabilityRow(server) {
            // Safely extract data from multiple sources with fallbacks
            const data = server?.data || {};
            const heartbeat = server?.heartbeat || {};
            const reachability = data.reachability || heartbeat.reachability || {};

            // Determine OS type for proper probe label (WinRM vs SSH)
            const rawOs = server?.os_type || server?.os || server?.osType || 'windows';
            const isLinux = typeof rawOs === 'string' && rawOs.toLowerCase() === 'linux';

            // Check WinRM/SSH session status from multiple indicators
            const winrmError = data.winrm_error || heartbeat.winrm_error || null;
            const winrmIssue = data.winrm_issue === true || !!winrmError;
            const sshError = data.ssh_error || heartbeat.ssh_error || null;
            const sshIssue = data.ssh_issue === true || !!sshError;

            // Determine if remote session succeeded
            // For Windows: check WinRM status
            // For Linux: check SSH status (or assume success if online with no ssh_issue flag)
            const remoteSessionOk = isLinux
                ? (server?.online === true && !sshIssue)
                : (server?.online === true && !winrmIssue && heartbeat.winrm_ok !== false);

            // Extract reachability data with defensive defaults
            const pingOk = reachability?.ping_ok ?? heartbeat?.ping_ok ?? false;
            const tcpRaw = reachability?.tcp_ports ?? heartbeat?.reachability?.tcp_ports;
            const tcpPorts = Array.isArray(tcpRaw) ? tcpRaw : (tcpRaw ? [tcpRaw] : []);

            // Determine probe method and label
            let probeMethod, probeMethodLabel, probeTooltip;

            if (remoteSessionOk) {
                // Full probe succeeded - show the remote management protocol used
                probeMethod = 'full';
                probeMethodLabel = isLinux ? 'SSH' : 'WinRM';
                probeTooltip = isLinux
                    ? 'Full SSH probe succeeded - comprehensive data available'
                    : 'Full WinRM probe succeeded - comprehensive data available';
            } else if (server?.online === true || pingOk) {
                // Server is reachable but remote session failed
                probeMethod = 'degraded';
                probeMethodLabel = 'Degraded';
                const reason = isLinux
                    ? (sshError || 'SSH session failed')
                    : (winrmError || 'WinRM session failed');
                probeTooltip = `Limited data - ${reason}`;
            } else {
                // Server is completely unreachable
                probeMethod = 'unreachable';
                probeMethodLabel = 'Unreachable';
                probeTooltip = 'Server did not respond to any probe methods';
            }

            // Map probe method to visual styling
            const probeMethodClass = probeMethod === 'full'
                ? 'badge-info'
                : probeMethod === 'degraded'
                    ? 'badge-warning'
                    : 'badge-error';

            const probeMethodBadge = `<span class="badge ${probeMethodClass} badge-sm font-bold uppercase" title="${escapeHtml(probeTooltip)}">${probeMethodLabel}</span>`;

            // For successful probes, only show the method badge (clean, minimal)
            if (probeMethod === 'full') {
                return `
                    <div class="flex gap-2 flex-wrap items-center my-2 text-sm">
                        <span class="text-base-content/60 font-semibold mr-1">Probe:</span>
                        ${probeMethodBadge}
                    </div>
                `;
            }

            // For degraded/unreachable, show detailed reachability to help troubleshoot
            const pingPill = `<span class="badge badge-sm ${pingOk ? 'badge-success' : 'badge-error'}" title="ICMP Ping ${pingOk ? 'succeeded' : 'failed'}">Ping: ${pingOk ? '‚úì' : '‚úó'}</span>`;

            // Build TCP port pills with meaningful labels and tooltips
            const tcpPills = tcpPorts.map(p => {
                const portNum = typeof p?.port === 'number' ? p.port : 0;
                const ok = p?.ok === true;

                // Map common ports to friendly names
                let label;
                if (portNum === 3389) label = 'RDP';
                else if (portNum === 5985) label = 'WinRM';
                else if (portNum === 22) label = 'SSH';
                else if (portNum === 445) label = 'SMB';
                else if (portNum === 135) label = 'RPC';
                else if (portNum > 0) label = `${portNum}`;
                else return ''; // Skip invalid ports

                const tooltip = ok
                    ? `Port ${portNum} (${label}) is open`
                    : (p?.error || `Port ${portNum} (${label}) is closed or filtered`);

                return `<span class="badge badge-sm ${ok ? 'badge-success' : 'badge-error'}" title="${escapeHtml(tooltip)}">${label}: ${ok ? '‚úì' : '‚úó'}</span>`;
            }).filter(Boolean).join('');

            return `
                <div class="flex gap-2 flex-wrap items-center my-2 text-sm">
                    <span class="text-base-content/60 font-semibold mr-1">Probe:</span>
                    ${probeMethodBadge}
                    ${pingPill}
                    ${tcpPills}
                </div>
            `;
        }

        function humanizeUptime(hours) {
            const totalSeconds = Number(hours) * 3600;
            if (!Number.isFinite(totalSeconds) || totalSeconds < 0) return 'Unknown';

            const seconds = Math.floor(totalSeconds);
            if (seconds < 60) {
                return `${seconds}s`;
            }

            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) {
                return `${minutes}m`;
            }

            const hrs = Math.floor(minutes / 60);
            if (hrs < 24) {
                return `${hrs}h`;
            }

            const days = Math.floor(hrs / 24);
            if (days < 7) {
                const remHrs = hrs % 24;
                return remHrs > 0 ? `${days}d ${remHrs}h` : `${days}d`;
            }

            const weeks = Math.floor(days / 7);
            if (weeks < 52) {
                const remDays = days % 7;
                return remDays > 0 ? `${weeks}w ${remDays}d` : `${weeks}w`;
            }

            const years = Math.floor(days / 365);
            const remWeeks = Math.floor((days % 365) / 7);
            return remWeeks > 0 ? `${years}y ${remWeeks}w` : `${years}y`;
        }

        function formatTimestamp(value) {
            if (!value) {
                return 'Unknown';
            }
            const parsed = new Date(value);
            if (Number.isNaN(parsed.getTime())) {
                return 'Unknown';
            }
            return parsed.toLocaleString();
        }

        function escapeRegex(value) {
            return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function highlightMatch(text, term) {
            if (!term) {
                return escapeHtml(text);
            }

            const safeTerm = escapeRegex(term.trim());
            if (!safeTerm) {
                return escapeHtml(text);
            }

            const regex = new RegExp(`(${safeTerm})`, 'ig');
            const parts = text.split(regex);

            return parts.map(part => {
                if (!part) return '';
                if (part.toLowerCase() === term.toLowerCase()) {
                    return `<span class="highlight">${escapeHtml(part)}</span>`;
                }
                return escapeHtml(part);
            }).join('');
        }

        function toggleFilter(filterType) {
            if (!filterType) return;
            // Reset group focus when switching filters so the view isn't locked to a single group.
            if (focusedGroup !== null) {
                focusedGroup = null;
                settingsBundle.qp_focused_group = null;
                queueSettingsSave(settingsPayload());
            }
            if (filterType === 'all') {
                activeFilter = null;
            } else if (activeFilter?.type === filterType) {
                activeFilter = null;
            } else {
                activeFilter = { type: filterType };
            }
            displayAllServers();
        }

        function activeFilterLabel(filterType) {
            switch (filterType) {
                case 'all': return 'All Servers';
                case 'online': return 'Online';
                case 'offline': return 'Offline';
                case 'diskWarnings': return 'Disk Warnings';
                case 'serviceIssues': return 'Service Issues';
                case 'winrmIssues': return 'WinRM Issues';
                case 'highCpu': return 'High CPU';
                case 'highMemory': return 'High RAM';
                case 'rebootNeeded': return 'Reboot Needed';
                default: return '';
            }
        }

        function updateSummaryCards(summary) {
            document.getElementById('stat-total').textContent = summary.total;
            document.getElementById('stat-online').textContent = summary.online;
            document.getElementById('stat-offline').textContent = summary.offline;
            document.getElementById('stat-disk-warnings').textContent = summary.diskWarnings;
            document.getElementById('stat-service-issues').textContent = summary.serviceIssues;
            document.getElementById('stat-winrm-issues').textContent = summary.winrmIssues;
            document.getElementById('stat-high-cpu').textContent = summary.highCpu;
            document.getElementById('stat-high-ram').textContent = summary.highMemory;
            document.getElementById('stat-reboot-needed').textContent = summary.rebootNeeded;

            document.querySelectorAll('.stat[data-filter]').forEach(card => {
                const isActive = activeFilter?.type === card.dataset.filter;
                card.classList.toggle('stat-card-active', isActive);
            });
        }

        async function launchRdp(serverName) {
            if (!serverName) return false;
            if (!window.__TAURI__) {
                showError('Tauri API not available');
                return false;
            }

            const { invoke } = window.__TAURI__.core;
            const attemptLaunch = async () => invoke('launch_rdp', { server: serverName });

            try {
                await attemptLaunch();
                hideError();
                return true;
            } catch (err) {
                const message = err?.toString?.() ? err.toString() : `${err}`;
                if (message.toLowerCase().includes('credential')) {
                    const saved = await setHostCredentials(serverName);
                    if (!saved) {
                        showError(message);
                        return false;
                    }
                    try {
                        await attemptLaunch();
                        hideError();
                        return true;
                    } catch (retryErr) {
                        showError(`Failed to launch RDP after saving credentials: ${retryErr}`);
                        return false;
                    }
                }
                showError(`Failed to launch RDP: ${message}`);
                return false;
            }
        }

        async function launchSsh(serverName) {
            if (!serverName) return false;
            if (!window.__TAURI__) {
                showError('Tauri API not available');
                return false;
            }

            const { invoke } = window.__TAURI__.core;
            const attemptLaunch = async () => invoke('launch_ssh', { server: serverName });

            try {
                await attemptLaunch();
                hideError();
                return true;
            } catch (err) {
                const message = err?.toString?.() ? err.toString() : `${err}`;
                if (message.toLowerCase().includes('credential')) {
                    const saved = await setHostCredentials(serverName);
                    if (!saved) {
                        showError(message);
                        return false;
                    }
                    try {
                        await attemptLaunch();
                        hideError();
                        return true;
                    } catch (retryErr) {
                        showError(`Failed to launch SSH after saving credentials: ${retryErr}`);
                        return false;
                    }
                }
                showError(`Failed to launch SSH: ${message}`);
                return false;
            }
        }

        async function setHostCredentials(serverName) {
            if (!openHostCredentialDialog) {
                showError('Credential dialog unavailable. Please reload the dashboard.');
                return false;
            }
            triggerQuickProbe(serverName, 'host-creds');

            const result = await openHostCredentialDialog(serverName);
            if (!result || !result.username) return false;
            const { username, password } = result;

            if (!window.__TAURI__) {
                showError('Tauri API not available');
                return false;
            }

            try {
                const { invoke } = window.__TAURI__.core;
                await invoke('save_rdp_credentials', {
                    server: serverName,
                    username: username.trim(),
                    password
                });
                hideError();
                return true;
            } catch (err) {
                showError(`Failed to save host credentials: ${err}`);
                return false;
            }
        }

        // ===== Manage Services Modal =====
        let manageServicesData = [];
        let manageServicesServerName = '';
        let manageServicesMonitoredList = [];
        let manageServicesSortColumn = 'name';
        let manageServicesSortAsc = true;
        let manageServicesActionInProgress = false;

        async function openManageServicesModal(serverName) {
            if (!window.__TAURI__) {
                showError('Tauri API not available');
                return;
            }

            manageServicesServerName = serverName;
            manageServicesData = [];
            manageServicesMonitoredList = [];

            const modal = document.getElementById('manage-services-modal');
            const hostSpan = document.getElementById('manage-services-host');
            const loadingDiv = document.getElementById('manage-services-loading');
            const contentDiv = document.getElementById('manage-services-content');
            const messageDiv = document.getElementById('manage-services-message');
            const searchInput = document.getElementById('manage-services-search');
            const statusFilter = document.getElementById('manage-services-status-filter');
            const monitoredFilter = document.getElementById('manage-services-monitored-filter');

            if (!modal) return;

            // Reset state
            hostSpan.textContent = serverName;
            loadingDiv.classList.remove('hidden');
            contentDiv.classList.add('hidden');
            messageDiv.classList.add('hidden');
            if (searchInput) searchInput.value = '';
            if (statusFilter) statusFilter.value = '';
            if (monitoredFilter) monitoredFilter.value = '';

            modal.showModal();

            // Fetch services and host info
            try {
                const { invoke } = window.__TAURI__.core;

                // Get monitored services list from host data
                try {
                    const allHosts = await invoke('get_hosts');
                    const hostInfo = allHosts.find(h => h.name.toUpperCase() === serverName.toUpperCase());
                    if (hostInfo && Array.isArray(hostInfo.services)) {
                        manageServicesMonitoredList = hostInfo.services.map(s => s.toUpperCase().trim());
                    }
                } catch (hostErr) {
                    console.warn('Failed to load host info for monitored services filter:', hostErr);
                }

                manageServicesData = await invoke('get_remote_services', { serverName });
                loadingDiv.classList.add('hidden');
                contentDiv.classList.remove('hidden');
                renderManageServicesTable();
            } catch (err) {
                loadingDiv.classList.add('hidden');
                messageDiv.classList.remove('hidden');
                messageDiv.className = 'alert alert-error mb-3';
                messageDiv.textContent = `Failed to fetch services: ${err}`;
            }
        }

        function renderManageServicesTable() {
            const tbody = document.getElementById('manage-services-tbody');
            const countSpan = document.getElementById('manage-services-count');
            const searchInput = document.getElementById('manage-services-search');
            const statusFilter = document.getElementById('manage-services-status-filter');
            const monitoredFilter = document.getElementById('manage-services-monitored-filter');

            if (!tbody) return;

            const searchTerm = (searchInput?.value || '').toLowerCase().trim();
            const statusFilterVal = statusFilter?.value || '';
            const monitoredFilterVal = monitoredFilter?.value || '';

            // Filter services
            let filtered = manageServicesData.filter(svc => {
                const matchesSearch = !searchTerm ||
                    svc.name.toLowerCase().includes(searchTerm) ||
                    svc.display_name.toLowerCase().includes(searchTerm);
                const matchesStatus = !statusFilterVal || svc.status === statusFilterVal;
                const matchesMonitored = !monitoredFilterVal ||
                    (monitoredFilterVal === 'monitored' && manageServicesMonitoredList.includes(svc.name.toUpperCase().trim()));
                return matchesSearch && matchesStatus && matchesMonitored;
            });

            // Sort services
            filtered.sort((a, b) => {
                let valA = a[manageServicesSortColumn] || '';
                let valB = b[manageServicesSortColumn] || '';
                if (typeof valA === 'string') valA = valA.toLowerCase();
                if (typeof valB === 'string') valB = valB.toLowerCase();
                if (valA < valB) return manageServicesSortAsc ? -1 : 1;
                if (valA > valB) return manageServicesSortAsc ? 1 : -1;
                return 0;
            });

            // Update count
            if (countSpan) countSpan.textContent = filtered.length;

            // Render rows
            tbody.innerHTML = filtered.map(svc => {
                const statusClass = svc.status === 'Running' ? 'badge-success' :
                    svc.status === 'Stopped' ? 'badge-error' : 'badge-warning';
                const isRunning = svc.status === 'Running';
                const isStopped = svc.status === 'Stopped';
                const isMonitored = manageServicesMonitoredList.includes(svc.name.toUpperCase().trim());

                return `
                    <tr class="hover:bg-base-200">
                        <td class="font-mono text-sm">
                            ${isMonitored ? '<span class="badge badge-primary badge-xs mr-1" title="Monitored service">üëÅ</span>' : ''}
                            ${escapeHtml(svc.name)}
                        </td>
                        <td>${escapeHtml(svc.display_name)}</td>
                        <td><span class="badge ${statusClass} badge-sm">${escapeHtml(svc.status)}</span></td>
                        <td class="text-sm">${escapeHtml(svc.startup_type)}</td>
                        <td class="text-center">
                            <div class="flex gap-1 justify-center">
                                <button class="btn btn-xs btn-success svc-start-btn"
                                    data-service="${escapeHtml(svc.name)}"
                                    ${isRunning ? 'disabled' : ''}
                                    title="Start service">‚ñ∂</button>
                                <button class="btn btn-xs btn-error svc-stop-btn"
                                    data-service="${escapeHtml(svc.name)}"
                                    ${isStopped ? 'disabled' : ''}
                                    title="Stop service">‚èπ</button>
                                <button class="btn btn-xs btn-warning svc-restart-btn"
                                    data-service="${escapeHtml(svc.name)}"
                                    title="Restart service">üîÑ</button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');

            // Attach event handlers
            tbody.querySelectorAll('.svc-start-btn').forEach(btn => {
                btn.addEventListener('click', () => controlServiceAction(btn.dataset.service, 'start', btn));
            });
            tbody.querySelectorAll('.svc-stop-btn').forEach(btn => {
                btn.addEventListener('click', () => controlServiceAction(btn.dataset.service, 'stop', btn));
            });
            tbody.querySelectorAll('.svc-restart-btn').forEach(btn => {
                btn.addEventListener('click', () => controlServiceAction(btn.dataset.service, 'restart', btn));
            });
        }

        async function controlServiceAction(serviceName, action, buttonEl) {
            if (manageServicesActionInProgress) return;
            if (!window.__TAURI__) {
                showError('Tauri API not available');
                return;
            }

            manageServicesActionInProgress = true;
            const messageDiv = document.getElementById('manage-services-message');

            // Disable button and show loading state
            const originalText = buttonEl.textContent;
            buttonEl.disabled = true;
            buttonEl.textContent = '...';

            try {
                const { invoke } = window.__TAURI__.core;
                const result = await invoke('control_service', {
                    serverName: manageServicesServerName,
                    serviceName,
                    action
                });

                // Show result message
                messageDiv.classList.remove('hidden');
                if (result.success) {
                    messageDiv.className = 'alert alert-success mb-3';
                    messageDiv.textContent = `${result.message} (${serviceName} is now ${result.new_status || 'unknown'})`;

                    // Update local data
                    const svc = manageServicesData.find(s => s.name === serviceName);
                    if (svc && result.new_status) {
                        svc.status = result.new_status;
                    }

                    // Re-render table
                    renderManageServicesTable();
                } else {
                    messageDiv.className = 'alert alert-error mb-3';
                    messageDiv.textContent = `Failed: ${result.message}`;
                    buttonEl.textContent = originalText;
                    buttonEl.disabled = false;
                }

                // Auto-hide success message after 3 seconds
                if (result.success) {
                    setTimeout(() => {
                        messageDiv.classList.add('hidden');
                    }, 3000);
                }
            } catch (err) {
                messageDiv.classList.remove('hidden');
                messageDiv.className = 'alert alert-error mb-3';
                messageDiv.textContent = `Error: ${err}`;
                buttonEl.textContent = originalText;
                buttonEl.disabled = false;
            } finally {
                manageServicesActionInProgress = false;
            }
        }

        function escapeHtml(str) {
            if (!str) return '';
            return str.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        // Initialize manage services modal event handlers
        (function initManageServicesModal() {
            const modal = document.getElementById('manage-services-modal');
            const closeBtn = document.getElementById('manage-services-close');
            const refreshBtn = document.getElementById('manage-services-refresh');
            const searchInput = document.getElementById('manage-services-search');
            const statusFilter = document.getElementById('manage-services-status-filter');
            const thead = modal?.querySelector('thead');

            if (closeBtn) {
                closeBtn.addEventListener('click', () => modal?.close());
            }

            if (refreshBtn) {
                refreshBtn.addEventListener('click', async () => {
                    if (!manageServicesServerName) return;
                    refreshBtn.disabled = true;
                    refreshBtn.textContent = '‚è≥ Loading...';
                    try {
                        await openManageServicesModal(manageServicesServerName);
                    } finally {
                        refreshBtn.disabled = false;
                        refreshBtn.textContent = 'üîÑ Refresh';
                    }
                });
            }

            if (searchInput) {
                searchInput.addEventListener('input', () => renderManageServicesTable());
            }

            if (statusFilter) {
                statusFilter.addEventListener('change', () => renderManageServicesTable());
            }

            const monitoredFilter = document.getElementById('manage-services-monitored-filter');
            if (monitoredFilter) {
                monitoredFilter.addEventListener('change', () => renderManageServicesTable());
            }

            // Sort column headers
            if (thead) {
                thead.querySelectorAll('th[data-sort]').forEach(th => {
                    th.addEventListener('click', () => {
                        const col = th.dataset.sort;
                        if (manageServicesSortColumn === col) {
                            manageServicesSortAsc = !manageServicesSortAsc;
                        } else {
                            manageServicesSortColumn = col;
                            manageServicesSortAsc = true;
                        }
                        // Update sort indicators
                        thead.querySelectorAll('.sort-indicator').forEach(ind => ind.textContent = '');
                        const indicator = th.querySelector('.sort-indicator');
                        if (indicator) {
                            indicator.textContent = manageServicesSortAsc ? ' ‚ñ≤' : ' ‚ñº';
                        }
                        renderManageServicesTable();
                    });
                });
            }
        })();

        // ============ MANAGE PROCESSES MODAL ============
        let manageProcessesData = [];
        let manageProcessesServerName = '';
        let manageProcessesSortColumn = 'memory';
        let manageProcessesSortAsc = false; // Sort by memory descending by default
        let manageProcessesActionInProgress = false;
        let killProcessPendingPid = null;
        let killProcessPendingName = '';

        async function openManageProcessesModal(serverName) {
            if (!window.__TAURI__) {
                showError('Tauri API not available');
                return;
            }

            manageProcessesServerName = serverName;
            manageProcessesData = [];

            const modal = document.getElementById('manage-processes-modal');
            const hostSpan = document.getElementById('manage-processes-host');
            const loadingDiv = document.getElementById('manage-processes-loading');
            const contentDiv = document.getElementById('manage-processes-content');
            const messageDiv = document.getElementById('manage-processes-message');
            const searchInput = document.getElementById('manage-processes-search');

            if (!modal) return;

            // Reset state
            hostSpan.textContent = serverName;
            loadingDiv.classList.remove('hidden');
            contentDiv.classList.add('hidden');
            messageDiv.classList.add('hidden');
            if (searchInput) searchInput.value = '';

            modal.showModal();

            // Fetch processes
            try {
                const { invoke } = window.__TAURI__.core;
                manageProcessesData = await invoke('get_remote_processes', { serverName });
                loadingDiv.classList.add('hidden');
                contentDiv.classList.remove('hidden');
                renderManageProcessesTable();
            } catch (err) {
                loadingDiv.classList.add('hidden');
                messageDiv.classList.remove('hidden');
                messageDiv.className = 'alert alert-error mb-3';
                messageDiv.textContent = `Failed to fetch processes: ${err}`;
            }
        }

        function renderManageProcessesTable() {
            const tbody = document.getElementById('manage-processes-tbody');
            const countSpan = document.getElementById('manage-processes-count');
            const searchInput = document.getElementById('manage-processes-search');

            if (!tbody) return;

            const searchTerm = (searchInput?.value || '').toLowerCase().trim();

            // Filter processes
            let filtered = manageProcessesData.filter(proc => {
                const matchesSearch = !searchTerm ||
                    proc.name.toLowerCase().includes(searchTerm) ||
                    proc.user.toLowerCase().includes(searchTerm) ||
                    proc.pid.toString().includes(searchTerm);
                return matchesSearch;
            });

            // Sort processes
            filtered.sort((a, b) => {
                let valA = a[manageProcessesSortColumn];
                let valB = b[manageProcessesSortColumn];

                // Handle different column types
                if (manageProcessesSortColumn === 'cpu' || manageProcessesSortColumn === 'memory') {
                    valA = manageProcessesSortColumn === 'cpu' ? a.cpu_percent : a.memory_mb;
                    valB = manageProcessesSortColumn === 'cpu' ? b.cpu_percent : b.memory_mb;
                } else if (typeof valA === 'string') {
                    valA = valA.toLowerCase();
                    valB = valB.toLowerCase();
                }

                if (valA < valB) return manageProcessesSortAsc ? -1 : 1;
                if (valA > valB) return manageProcessesSortAsc ? 1 : -1;
                return 0;
            });

            // Update count
            if (countSpan) countSpan.textContent = filtered.length;

            // Render rows
            tbody.innerHTML = filtered.map(proc => {
                const cpuClass = proc.cpu_percent > 50 ? 'text-error font-bold' :
                    proc.cpu_percent > 20 ? 'text-warning' : '';
                const memClass = proc.memory_mb > 1000 ? 'text-error font-bold' :
                    proc.memory_mb > 500 ? 'text-warning' : '';

                return `
                    <tr class="hover:bg-base-200">
                        <td class="font-mono text-sm">${escapeHtml(proc.name)}</td>
                        <td class="text-sm">${proc.pid}</td>
                        <td class="${cpuClass}">${proc.cpu_percent.toFixed(1)}</td>
                        <td class="${memClass}">${proc.memory_mb.toFixed(1)}</td>
                        <td class="text-sm truncate max-w-[200px]" title="${escapeHtml(proc.user)}">${escapeHtml(proc.user)}</td>
                        <td class="text-center">
                            <button class="btn btn-xs btn-error proc-kill-btn"
                                data-pid="${proc.pid}"
                                data-name="${escapeHtml(proc.name)}"
                                title="Kill process">‚ò†Ô∏è Kill</button>
                        </td>
                    </tr>
                `;
            }).join('');

            // Attach event handlers for kill buttons
            tbody.querySelectorAll('.proc-kill-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    showKillProcessConfirm(parseInt(btn.dataset.pid), btn.dataset.name);
                });
            });
        }

        function showKillProcessConfirm(pid, processName) {
            const confirmModal = document.getElementById('kill-process-confirm-modal');
            const nameSpan = document.getElementById('kill-process-name');
            const pidSpan = document.getElementById('kill-process-pid');
            const hostSpan = document.getElementById('kill-process-host');

            if (!confirmModal) return;

            killProcessPendingPid = pid;
            killProcessPendingName = processName;

            nameSpan.textContent = processName;
            pidSpan.textContent = pid;
            hostSpan.textContent = manageProcessesServerName;

            confirmModal.showModal();
        }

        async function executeKillProcess() {
            if (manageProcessesActionInProgress) return;
            if (!window.__TAURI__) {
                showError('Tauri API not available');
                return;
            }
            if (!killProcessPendingPid) return;

            manageProcessesActionInProgress = true;
            const confirmModal = document.getElementById('kill-process-confirm-modal');
            const messageDiv = document.getElementById('manage-processes-message');
            const confirmBtn = document.getElementById('kill-process-confirm-btn');

            // Disable button during operation
            if (confirmBtn) {
                confirmBtn.disabled = true;
                confirmBtn.textContent = 'Killing...';
            }

            try {
                const { invoke } = window.__TAURI__.core;
                const result = await invoke('kill_process', {
                    serverName: manageProcessesServerName,
                    pid: killProcessPendingPid,
                    processName: killProcessPendingName
                });

                // Close confirmation modal
                confirmModal?.close();

                // Show result message
                messageDiv.classList.remove('hidden');
                if (result.success) {
                    messageDiv.className = 'alert alert-success mb-3';
                    messageDiv.textContent = result.message;

                    // Remove process from local data
                    manageProcessesData = manageProcessesData.filter(p => p.pid !== killProcessPendingPid);

                    // Re-render table
                    renderManageProcessesTable();

                    // Auto-hide success message after 3 seconds
                    setTimeout(() => {
                        messageDiv.classList.add('hidden');
                    }, 3000);
                } else {
                    messageDiv.className = 'alert alert-error mb-3';
                    messageDiv.textContent = `Failed: ${result.message}`;
                }
            } catch (err) {
                confirmModal?.close();
                messageDiv.classList.remove('hidden');
                messageDiv.className = 'alert alert-error mb-3';
                messageDiv.textContent = `Error: ${err}`;
            } finally {
                manageProcessesActionInProgress = false;
                killProcessPendingPid = null;
                killProcessPendingName = '';

                // Reset confirm button
                if (confirmBtn) {
                    confirmBtn.disabled = false;
                    confirmBtn.textContent = 'Kill Process';
                }
            }
        }

        // Initialize manage processes modal event handlers
        (function initManageProcessesModal() {
            const modal = document.getElementById('manage-processes-modal');
            const closeBtn = document.getElementById('manage-processes-close');
            const refreshBtn = document.getElementById('manage-processes-refresh');
            const searchInput = document.getElementById('manage-processes-search');
            const thead = modal?.querySelector('thead');
            const killConfirmBtn = document.getElementById('kill-process-confirm-btn');

            if (closeBtn) {
                closeBtn.addEventListener('click', () => modal?.close());
            }

            if (refreshBtn) {
                refreshBtn.addEventListener('click', async () => {
                    if (!manageProcessesServerName) return;
                    refreshBtn.disabled = true;
                    refreshBtn.textContent = '‚è≥ Loading...';
                    try {
                        await openManageProcessesModal(manageProcessesServerName);
                    } finally {
                        refreshBtn.disabled = false;
                        refreshBtn.textContent = 'üîÑ Refresh';
                    }
                });
            }

            if (searchInput) {
                searchInput.addEventListener('input', () => renderManageProcessesTable());
            }

            // Sort column headers
            if (thead) {
                thead.querySelectorAll('th[data-sort]').forEach(th => {
                    th.addEventListener('click', () => {
                        const col = th.dataset.sort;
                        if (manageProcessesSortColumn === col) {
                            manageProcessesSortAsc = !manageProcessesSortAsc;
                        } else {
                            manageProcessesSortColumn = col;
                            // Default to descending for numeric columns
                            manageProcessesSortAsc = !['cpu', 'memory', 'pid'].includes(col);
                        }
                        // Update sort indicators
                        thead.querySelectorAll('.sort-indicator').forEach(ind => ind.textContent = '');
                        const indicator = th.querySelector('.sort-indicator');
                        if (indicator) {
                            indicator.textContent = manageProcessesSortAsc ? ' ‚ñ≤' : ' ‚ñº';
                        }
                        renderManageProcessesTable();
                    });
                });
            }

            // Kill process confirmation button
            if (killConfirmBtn) {
                killConfirmBtn.addEventListener('click', () => {
                    executeKillProcess();
                });
            }
        })();

        // ==================== Remote PowerShell Modal ====================
        let remotePowerShellServerName = '';
        let remotePowerShellHistory = [];
        let remotePowerShellHistoryIndex = -1;
        let remotePowerShellExecuting = false;
        let remotePowerShellScriptContent = '';
        let remotePowerShellScriptName = '';

        async function openRemotePowerShellModal(serverName) {
            if (!window.__TAURI__) {
                showError('Tauri API not available');
                return;
            }

            remotePowerShellServerName = serverName;
            remotePowerShellHistoryIndex = -1;

            const modal = document.getElementById('remote-powershell-modal');
            const hostSpan = document.getElementById('remote-powershell-host');
            const outputDiv = document.getElementById('remote-powershell-output');
            const inputField = document.getElementById('remote-powershell-input');
            const statusDiv = document.getElementById('remote-powershell-status');
            const historyInfo = document.getElementById('remote-powershell-history-info');
            const scriptPreview = document.getElementById('remote-powershell-script-preview');

            if (!modal) return;

            // Reset state
            hostSpan.textContent = serverName;
            outputDiv.innerHTML = '<span class="text-base-content/50">Ready. Enter a command below and press Enter or click Execute.</span>';
            inputField.value = '';

            // Clear any pending script upload
            remotePowerShellScriptContent = '';
            remotePowerShellScriptName = '';
            if (scriptPreview) scriptPreview.classList.add('hidden');
            statusDiv.textContent = 'Ready';

            // Show history hint if there's history
            if (remotePowerShellHistory.length > 0) {
                historyInfo?.classList.remove('hidden');
            } else {
                historyInfo?.classList.add('hidden');
            }

            modal.showModal();

            // Focus input field after modal opens
            setTimeout(() => inputField?.focus(), 100);
        }

        async function executeRemotePowerShell() {
            if (remotePowerShellExecuting) return;
            if (!window.__TAURI__) {
                showError('Tauri API not available');
                return;
            }

            const inputField = document.getElementById('remote-powershell-input');
            const outputDiv = document.getElementById('remote-powershell-output');
            const statusDiv = document.getElementById('remote-powershell-status');
            const executeBtn = document.getElementById('remote-powershell-execute');
            const historyInfo = document.getElementById('remote-powershell-history-info');

            const command = inputField?.value?.trim();
            if (!command) return;

            // Add to history (avoid duplicates)
            if (remotePowerShellHistory.length === 0 || remotePowerShellHistory[remotePowerShellHistory.length - 1] !== command) {
                remotePowerShellHistory.push(command);
                // Limit history to last 50 commands
                if (remotePowerShellHistory.length > 50) {
                    remotePowerShellHistory.shift();
                }
            }
            remotePowerShellHistoryIndex = -1;
            historyInfo?.classList.remove('hidden');

            // Update UI state
            remotePowerShellExecuting = true;
            statusDiv.textContent = 'Executing...';
            executeBtn.disabled = true;
            executeBtn.textContent = '‚è≥ Running...';
            inputField.disabled = true;

            // Clear initial placeholder if present
            const placeholder = outputDiv.querySelector('span.text-base-content\\/50');
            if (placeholder && placeholder.textContent.includes('Ready.')) {
                outputDiv.innerHTML = '';
            }

            // Append command to output
            const cmdLine = document.createElement('div');
            cmdLine.className = 'text-primary font-bold';
            cmdLine.textContent = `PS ${remotePowerShellServerName}> ${command}`;
            outputDiv.appendChild(cmdLine);

            try {
                const { invoke } = window.__TAURI__.core;
                const result = await invoke('execute_remote_powershell', {
                    serverName: remotePowerShellServerName,
                    command: command
                });

                // Append output
                const outputLine = document.createElement('div');
                if (result.success) {
                    outputLine.className = 'text-base-content mb-2';
                    outputLine.textContent = result.output || '(No output)';
                } else {
                    outputLine.className = 'text-error mb-2';
                    outputLine.textContent = result.error || 'Command failed with no error message';
                }
                outputDiv.appendChild(outputLine);

                statusDiv.textContent = result.success ? 'Command completed' : 'Command failed';
            } catch (err) {
                const errorLine = document.createElement('div');
                errorLine.className = 'text-error mb-2';
                errorLine.textContent = `Error: ${err}`;
                outputDiv.appendChild(errorLine);
                statusDiv.textContent = 'Error';
            } finally {
                remotePowerShellExecuting = false;
                executeBtn.disabled = false;
                executeBtn.textContent = '‚ñ∂Ô∏è Execute';
                inputField.disabled = false;
                inputField.value = '';
                inputField.focus();

                // Scroll to bottom
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }
        }

        function clearRemotePowerShellOutput() {
            const outputDiv = document.getElementById('remote-powershell-output');
            if (outputDiv) {
                outputDiv.innerHTML = '<span class="text-base-content/50">Output cleared. Enter a command below.</span>';
            }
        }

        async function uploadPowerShellScript() {
            if (!window.__TAURI__) {
                showError('Tauri API not available');
                return;
            }

            try {
                const { open } = window.__TAURI__.dialog;
                const { readTextFile } = window.__TAURI__.fs;

                // Open file picker for PowerShell scripts
                const selected = await open({
                    multiple: false,
                    filters: [{
                        name: 'PowerShell Scripts',
                        extensions: ['ps1', 'psm1', 'psd1']
                    }, {
                        name: 'All Files',
                        extensions: ['*']
                    }],
                    title: 'Select PowerShell Script'
                });

                if (!selected) return; // User cancelled

                // Read the file content
                const content = await readTextFile(selected);

                // Extract filename from path
                const pathParts = selected.replace(/\\/g, '/').split('/');
                const fileName = pathParts[pathParts.length - 1];

                // Store for execution
                remotePowerShellScriptContent = content;
                remotePowerShellScriptName = fileName;

                // Show preview
                const previewDiv = document.getElementById('remote-powershell-script-preview');
                const nameSpan = document.getElementById('remote-powershell-script-name');
                const sizeSpan = document.getElementById('remote-powershell-script-size');
                const contentDiv = document.getElementById('remote-powershell-script-content');

                if (previewDiv && nameSpan && contentDiv) {
                    nameSpan.textContent = fileName;
                    sizeSpan.textContent = `(${formatScriptSize(content.length)}, ${content.split('\n').length} lines)`;

                    // Show preview with syntax highlighting hint
                    const preview = content.length > 5000
                        ? content.substring(0, 5000) + '\n\n... (truncated for preview)'
                        : content;
                    contentDiv.textContent = preview;
                    previewDiv.classList.remove('hidden');
                }

                document.getElementById('remote-powershell-status').textContent = `Script loaded: ${fileName}`;
            } catch (err) {
                showError(`Failed to load script: ${err}`);
            }
        }

        function formatScriptSize(bytes) {
            if (bytes < 1024) return `${bytes} bytes`;
            if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
            return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
        }

        function cancelScriptUpload() {
            remotePowerShellScriptContent = '';
            remotePowerShellScriptName = '';
            const previewDiv = document.getElementById('remote-powershell-script-preview');
            if (previewDiv) {
                previewDiv.classList.add('hidden');
            }
            document.getElementById('remote-powershell-status').textContent = 'Script cancelled';
        }

        async function runUploadedScript() {
            if (remotePowerShellExecuting) return;
            if (!remotePowerShellScriptContent) {
                showError('No script loaded');
                return;
            }
            if (!window.__TAURI__) {
                showError('Tauri API not available');
                return;
            }

            const outputDiv = document.getElementById('remote-powershell-output');
            const statusDiv = document.getElementById('remote-powershell-status');
            const runBtn = document.getElementById('remote-powershell-run-script');
            const uploadBtn = document.getElementById('remote-powershell-upload');

            // Update UI state
            remotePowerShellExecuting = true;
            statusDiv.textContent = `Running script: ${remotePowerShellScriptName}...`;
            if (runBtn) {
                runBtn.disabled = true;
                runBtn.textContent = '‚è≥ Running...';
            }
            if (uploadBtn) uploadBtn.disabled = true;

            // Clear initial placeholder if present
            const placeholder = outputDiv.querySelector('span.text-base-content\\/50');
            if (placeholder && (placeholder.textContent.includes('Ready.') || placeholder.textContent.includes('cleared'))) {
                outputDiv.innerHTML = '';
            }

            // Append script header to output
            const scriptHeader = document.createElement('div');
            scriptHeader.className = 'text-primary font-bold border-b border-base-content/20 pb-1 mb-2';
            scriptHeader.textContent = `üìÑ Running script: ${remotePowerShellScriptName} on ${remotePowerShellServerName}`;
            outputDiv.appendChild(scriptHeader);

            const startTime = Date.now();

            try {
                const { invoke } = window.__TAURI__.core;
                const result = await invoke('execute_remote_powershell', {
                    serverName: remotePowerShellServerName,
                    command: remotePowerShellScriptContent
                });

                const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);

                // Append output
                const outputLine = document.createElement('div');
                if (result.success) {
                    outputLine.className = 'text-base-content mb-2';
                    outputLine.textContent = result.output || '(No output)';
                } else {
                    outputLine.className = 'text-error mb-2';
                    outputLine.textContent = result.error || 'Script execution failed with no error message';
                }
                outputDiv.appendChild(outputLine);

                // Add completion footer
                const footer = document.createElement('div');
                footer.className = `text-sm ${result.success ? 'text-success' : 'text-error'} border-t border-base-content/20 pt-1 mt-2`;
                footer.textContent = `${result.success ? '‚úÖ' : '‚ùå'} Script completed in ${elapsed}s`;
                outputDiv.appendChild(footer);

                statusDiv.textContent = result.success
                    ? `Script completed successfully (${elapsed}s)`
                    : `Script failed (${elapsed}s)`;
            } catch (err) {
                const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                const errorLine = document.createElement('div');
                errorLine.className = 'text-error mb-2';
                errorLine.textContent = `Error: ${err}`;
                outputDiv.appendChild(errorLine);
                statusDiv.textContent = `Script error (${elapsed}s)`;
            } finally {
                remotePowerShellExecuting = false;
                if (runBtn) {
                    runBtn.disabled = false;
                    runBtn.textContent = '‚ñ∂Ô∏è Run Script';
                }
                if (uploadBtn) uploadBtn.disabled = false;

                // Scroll to bottom
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }
        }

        // ==================== Remote SSH Modal (Linux) ====================
        let remoteSshServerName = '';
        let remoteSshHistory = [];
        let remoteSshHistoryIndex = -1;
        let remoteSshExecuting = false;

        async function openRemoteSshModal(serverName) {
            if (!window.__TAURI__) {
                showError('Tauri API not available');
                return;
            }

            remoteSshServerName = serverName;
            remoteSshHistoryIndex = -1;

            const modal = document.getElementById('remote-ssh-modal');
            const hostSpan = document.getElementById('remote-ssh-host');
            const outputDiv = document.getElementById('remote-ssh-output');
            const inputField = document.getElementById('remote-ssh-input');
            const statusDiv = document.getElementById('remote-ssh-status');
            const historyInfo = document.getElementById('remote-ssh-history-info');

            if (!modal) return;

            // Reset state
            hostSpan.textContent = serverName;
            outputDiv.innerHTML = '<span class="text-base-content/50">Ready. Enter a command below and press Enter or click Execute.</span>';
            inputField.value = '';
            statusDiv.textContent = 'Ready';

            // Show history hint if there's history
            if (remoteSshHistory.length > 0) {
                historyInfo?.classList.remove('hidden');
            } else {
                historyInfo?.classList.add('hidden');
            }

            modal.showModal();

            // Focus input field after modal opens
            setTimeout(() => inputField?.focus(), 100);
        }

        async function executeRemoteSsh() {
            if (remoteSshExecuting) return;
            if (!window.__TAURI__) {
                showError('Tauri API not available');
                return;
            }

            const inputField = document.getElementById('remote-ssh-input');
            const outputDiv = document.getElementById('remote-ssh-output');
            const statusDiv = document.getElementById('remote-ssh-status');
            const executeBtn = document.getElementById('remote-ssh-execute');
            const historyInfo = document.getElementById('remote-ssh-history-info');
            const ptyToggle = document.getElementById('remote-ssh-pty-toggle');

            const command = inputField?.value?.trim();
            if (!command) return;

            // Check if PTY mode is enabled
            const usePty = ptyToggle?.checked || false;

            // Add to history (avoid duplicates)
            if (remoteSshHistory.length === 0 || remoteSshHistory[remoteSshHistory.length - 1] !== command) {
                remoteSshHistory.push(command);
                // Limit history to last 50 commands
                if (remoteSshHistory.length > 50) {
                    remoteSshHistory.shift();
                }
            }
            remoteSshHistoryIndex = -1;
            historyInfo?.classList.remove('hidden');

            // Update UI state
            remoteSshExecuting = true;
            statusDiv.textContent = usePty ? 'Executing (PTY mode)...' : 'Executing...';
            executeBtn.disabled = true;
            executeBtn.textContent = '‚è≥ Running...';
            inputField.disabled = true;

            // Clear initial placeholder if present
            const placeholder = outputDiv.querySelector('span.text-base-content\\/50');
            if (placeholder && placeholder.textContent.includes('Ready.')) {
                outputDiv.innerHTML = '';
            }

            // Append command to output
            const cmdLine = document.createElement('div');
            cmdLine.className = 'text-success font-bold';
            cmdLine.textContent = `${remoteSshServerName}$ ${command}${usePty ? ' (PTY)' : ''}`;
            outputDiv.appendChild(cmdLine);

            try {
                const { invoke } = window.__TAURI__.core;

                // Use PTY command if toggle is enabled (for curses/ncurses apps)
                const result = usePty
                    ? await invoke('execute_remote_ssh_pty', {
                        serverName: remoteSshServerName,
                        command: command,
                        cols: 120,
                        rows: 40
                    })
                    : await invoke('execute_remote_ssh', {
                        serverName: remoteSshServerName,
                        command: command
                    });

                // Append output
                const outputLine = document.createElement('div');
                if (result.success) {
                    outputLine.className = 'text-base-content mb-2';
                    // For PTY output, preserve ANSI escape codes for better formatting
                    if (usePty) {
                        outputLine.innerHTML = `<pre class="whitespace-pre-wrap">${escapeHtml(result.output || '(No output)')}</pre>`;
                    } else {
                        outputLine.textContent = result.output || '(No output)';
                    }
                } else {
                    outputLine.className = 'text-error mb-2';
                    outputLine.textContent = result.error || 'Command failed with no error message';
                }
                outputDiv.appendChild(outputLine);

                statusDiv.textContent = result.success ? 'Command completed' : 'Command failed';
            } catch (err) {
                const errorLine = document.createElement('div');
                errorLine.className = 'text-error mb-2';
                errorLine.textContent = `Error: ${err}`;
                outputDiv.appendChild(errorLine);
                statusDiv.textContent = 'Error';
            } finally {
                remoteSshExecuting = false;
                executeBtn.disabled = false;
                executeBtn.textContent = '‚ñ∂Ô∏è Execute';
                inputField.disabled = false;
                inputField.value = '';
                inputField.focus();

                // Scroll to bottom
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }
        }

        function clearRemoteSshOutput() {
            const outputDiv = document.getElementById('remote-ssh-output');
            const statusDiv = document.getElementById('remote-ssh-status');
            if (outputDiv) {
                outputDiv.innerHTML = '<span class="text-base-content/50">Ready. Enter a command below and press Enter or click Execute.</span>';
            }
            if (statusDiv) {
                statusDiv.textContent = 'Ready';
            }
        }

        // Initialize remote SSH modal event handlers
        (function initRemoteSshModal() {
            const modal = document.getElementById('remote-ssh-modal');
            const closeBtn = document.getElementById('remote-ssh-close');
            const executeBtn = document.getElementById('remote-ssh-execute');
            const clearBtn = document.getElementById('remote-ssh-clear');
            const inputField = document.getElementById('remote-ssh-input');

            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    modal?.close();
                });
            }

            if (executeBtn) {
                executeBtn.addEventListener('click', () => executeRemoteSsh());
            }

            if (clearBtn) {
                clearBtn.addEventListener('click', () => clearRemoteSshOutput());
            }

            if (inputField) {
                // Execute on Enter key
                inputField.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        executeRemoteSsh();
                    }
                    // Command history navigation
                    else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (remoteSshHistory.length > 0) {
                            if (remoteSshHistoryIndex < remoteSshHistory.length - 1) {
                                remoteSshHistoryIndex++;
                            }
                            inputField.value = remoteSshHistory[remoteSshHistory.length - 1 - remoteSshHistoryIndex] || '';
                        }
                    }
                    else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        if (remoteSshHistoryIndex > 0) {
                            remoteSshHistoryIndex--;
                            inputField.value = remoteSshHistory[remoteSshHistory.length - 1 - remoteSshHistoryIndex] || '';
                        } else if (remoteSshHistoryIndex === 0) {
                            remoteSshHistoryIndex = -1;
                            inputField.value = '';
                        }
                    }
                });
            }
        })();

        // Initialize remote PowerShell modal event handlers
        (function initRemotePowerShellModal() {
            const modal = document.getElementById('remote-powershell-modal');
            const closeBtn = document.getElementById('remote-powershell-close');
            const executeBtn = document.getElementById('remote-powershell-execute');
            const clearBtn = document.getElementById('remote-powershell-clear');
            const uploadBtn = document.getElementById('remote-powershell-upload');
            const runScriptBtn = document.getElementById('remote-powershell-run-script');
            const cancelScriptBtn = document.getElementById('remote-powershell-cancel-script');
            const inputField = document.getElementById('remote-powershell-input');

            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    cancelScriptUpload(); // Clear script state on close
                    modal?.close();
                });
            }

            if (executeBtn) {
                executeBtn.addEventListener('click', () => executeRemotePowerShell());
            }

            if (clearBtn) {
                clearBtn.addEventListener('click', () => {
                    clearRemotePowerShellOutput();
                    cancelScriptUpload(); // Also clear any pending script
                });
            }

            if (uploadBtn) {
                uploadBtn.addEventListener('click', () => uploadPowerShellScript());
            }

            if (runScriptBtn) {
                runScriptBtn.addEventListener('click', () => runUploadedScript());
            }

            if (cancelScriptBtn) {
                cancelScriptBtn.addEventListener('click', () => cancelScriptUpload());
            }

            if (inputField) {
                // Execute on Enter key
                inputField.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        executeRemotePowerShell();
                    }
                    // Command history navigation
                    else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (remotePowerShellHistory.length > 0) {
                            if (remotePowerShellHistoryIndex < remotePowerShellHistory.length - 1) {
                                remotePowerShellHistoryIndex++;
                            }
                            inputField.value = remotePowerShellHistory[remotePowerShellHistory.length - 1 - remotePowerShellHistoryIndex] || '';
                        }
                    }
                    else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        if (remotePowerShellHistoryIndex > 0) {
                            remotePowerShellHistoryIndex--;
                            inputField.value = remotePowerShellHistory[remotePowerShellHistory.length - 1 - remotePowerShellHistoryIndex] || '';
                        } else if (remotePowerShellHistoryIndex === 0) {
                            remotePowerShellHistoryIndex = -1;
                            inputField.value = '';
                        }
                    }
                });
            }
        })();
    </script>
</body>

</html>