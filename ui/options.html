<!DOCTYPE html>
<html lang="en" data-theme="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuickProbe Options</title>
    <script>
        (function () {
            const root = document.documentElement;
            root.classList.add('qp-preload');
            const reveal = () => root.classList.remove('qp-preload');
            window.__qpRevealSettings = reveal;
            window.__qpPreloadTimer = setTimeout(reveal, 100);

            // Apply theme immediately from localStorage (before ThemeModule loads)
            try {
                const settingsStr = localStorage.getItem('quickprobe_settings');
                if (settingsStr) {
                    const settings = JSON.parse(settingsStr);
                    const themeSetting = settings.theme || 'system';

                    // Simple inline resolution - ThemeModule will correct if needed
                    let resolvedTheme = themeSetting;
                    if (themeSetting === 'system') {
                        resolvedTheme = window.matchMedia?.('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
                    }

                    root.setAttribute('data-theme', resolvedTheme);
                } else {
                    root.setAttribute('data-theme', 'dark');
                }
            } catch (e) {
                console.warn('Failed to apply initial theme:', e);
                root.setAttribute('data-theme', 'dark');
            }
        })();

        function logDebug(message, obj) {
            try {
                const detail = obj ? `${message} | ${JSON.stringify(obj)}` : message;
                if (window.__TAURI__?.core?.invoke) {
                    window.__TAURI__.core.invoke('log_debug', { message: detail });
                } else {
                    console.debug(detail);
                }
            } catch (err) {
                console.debug('logDebug failed', err, message);
            }
        }
    </script>
    <!-- Tailwind CSS + DaisyUI (locally built) -->
    <link href="styles.css" rel="stylesheet">
    <!-- Unified theme module for cross-window sync -->
    <script src="theme.js"></script>
    <style>
        .qp-preload body {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>

<body class="bg-base-100 min-h-screen p-4">
    <div class="container mx-auto max-w-4xl">
        <h1 class="text-4xl font-bold text-primary mb-6">QuickProbe Options</h1>

        <!-- Startup Section -->
        <div class="card bg-base-200 shadow-lg mb-4">
            <div class="card-body">
                <h2 class="card-title text-2xl mb-4">Startup</h2>
                <div id="autostart-status" class="text-sm text-base-content/80 mb-3">Checking autostart...</div>
                <div class="mb-4">
                    <button id="toggle-autostart-btn" class="btn btn-primary">Toggle Autostart</button>
                </div>
                <div class="form-control">
                    <label class="label cursor-pointer justify-start gap-3">
                        <input type="checkbox" id="start-hidden-toggle" class="checkbox checkbox-primary">
                        <span class="label-text">Start QuickProbe hidden in system tray when credentials are
                            saved</span>
                    </label>
                    <label class="label">
                        <span class="label-text-alt text-base-content/60">If credentials are missing, the window will
                            still open so you can log in.</span>
                    </label>
                </div>
            </div>
        </div>

        <!-- Appearance Section -->
        <div class="card bg-base-200 shadow-lg mb-4">
            <div class="card-body">
                <h2 class="card-title text-2xl mb-4">Appearance</h2>
                <div class="form-control">
                    <label class="label" for="theme-select">
                        <span class="label-text font-medium">Theme</span>
                    </label>
                    <select id="theme-select" class="select select-bordered w-full max-w-md">
                        <option value="system">System (Auto)</option>
                        <optgroup label="Light Themes">
                            <option value="light">Light</option>
                            <option value="cupcake">Cupcake</option>
                            <option value="bumblebee">Bumblebee</option>
                            <option value="emerald">Emerald</option>
                            <option value="corporate">Corporate</option>
                            <option value="retro">Retro</option>
                            <option value="valentine">Valentine</option>
                            <option value="garden">Garden</option>
                            <option value="lofi">Lo-Fi</option>
                            <option value="pastel">Pastel</option>
                            <option value="fantasy">Fantasy</option>
                            <option value="wireframe">Wireframe</option>
                            <option value="cmyk">CMYK</option>
                            <option value="autumn">Autumn</option>
                            <option value="acid">Acid</option>
                            <option value="lemonade">Lemonade</option>
                            <option value="winter">Winter</option>
                            <option value="nord">Nord</option>
                        </optgroup>
                        <optgroup label="Dark Themes">
                            <option value="dark">Dark</option>
                            <option value="synthwave">Synthwave</option>
                            <option value="halloween">Halloween</option>
                            <option value="forest">Forest</option>
                            <option value="aqua">Aqua</option>
                            <option value="black">Black</option>
                            <option value="luxury">Luxury</option>
                            <option value="dracula">Dracula</option>
                            <option value="business">Business</option>
                            <option value="night">Night</option>
                            <option value="coffee">Coffee</option>
                            <option value="dim">Dim</option>
                            <option value="sunset">Sunset</option>
                            <option value="cyberpunk">Cyberpunk</option>
                        </optgroup>
                    </select>
                    <label class="label">
                        <span class="label-text-alt text-base-content/60">Choose from 32 professional themes. Changes
                            apply immediately across all windows.</span>
                    </label>
                </div>
            </div>
        </div>

        <!-- Backup & Restore Section -->
        <div class="card bg-base-200 shadow-lg mb-4">
            <div class="card-body">
                <h2 class="card-title text-2xl mb-4">Backup & Restore</h2>
                <div class="form-control mb-4">
                    <label class="label" for="backup-password">
                        <span class="label-text font-medium">Password</span>
                    </label>
                    <input id="backup-password" type="password" placeholder="Required for backup and restore"
                        autocomplete="off" class="input input-bordered w-full max-w-md">
                    <label class="label">
                        <span class="label-text-alt text-base-content/60">Protects all QuickProbe settings
                            (localStorage) and hosts.csv in an encrypted ZIP.</span>
                    </label>
                </div>
                <div class="flex gap-2 flex-wrap mb-3">
                    <button id="backup-btn" class="btn btn-primary">Create Backup</button>
                    <button id="restore-btn" class="btn btn-secondary">Restore Backup</button>
                </div>
                <div id="backup-status" class="text-sm font-medium"></div>
            </div>
        </div>

        <!-- CSV Export Section -->
        <div class="card bg-base-200 shadow-lg mb-4">
            <div class="card-body">
                <h2 class="card-title text-2xl mb-4">Export Hosts</h2>
                <p class="text-sm text-base-content/60 mb-4">Export comprehensive host data to CSV including: host
                    configuration (name, notes, group, monitored services), network details (IP addresses, subnets,
                    gateways, DNS, adapters), system info (OS version, hostname, install date), health metrics (memory,
                    CPU, uptime, processes), disk status, service status, reboot state, and recent errors.</p>
                <div class="flex gap-2 flex-wrap mb-3">
                    <button id="export-csv-btn" class="btn btn-primary">Export to CSV</button>
                </div>
                <div id="csv-export-status" class="text-sm font-medium"></div>
            </div>
        </div>

        <!-- Location Mapping Section -->
        <div id="location-section" class="card bg-base-200 shadow-lg mb-4">
            <div class="card-body">
                <h2 class="card-title text-2xl mb-2">Location Mapping</h2>
                <p class="text-sm text-base-content/60 mb-4">Map IPv4 addresses or CIDR ranges to a location label.
                    First match wins.</p>
                <div id="location-rows" class="space-y-3 mb-3"></div>
                <div id="location-empty" class="alert alert-info shadow-sm mb-4">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24"
                        stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    <span>No location mappings configured. Click "Add Location" to create one.</span>
                </div>
                <button id="add-location-btn" type="button" class="btn btn-accent btn-sm gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24"
                        stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
                    </svg>
                    Add Location
                </button>
            </div>
        </div>

        <!-- Probes Section -->
        <div class="card bg-base-200 shadow-lg mb-4">
            <div class="card-body">
                <h2 class="card-title text-2xl mb-4">Probes</h2>
                <div class="form-control mb-4">
                    <label class="label" for="probe-timeout">
                        <span class="label-text font-medium">Full probe timeout (seconds)</span>
                    </label>
                    <input id="probe-timeout" type="number" min="10" max="600" step="5" placeholder="60"
                        autocomplete="off" class="input input-bordered w-full max-w-xs">
                    <label class="label">
                        <span class="label-text-alt text-base-content/60">Timeout for complete system health checks.
                            Increase for slower hosts.</span>
                    </label>
                </div>

                <div class="form-control">
                    <label class="label" for="quick-probe-timeout">
                        <span class="label-text font-medium">Quick probe timeout (seconds)</span>
                    </label>
                    <input id="quick-probe-timeout" type="number" min="5" max="120" step="5" placeholder="30"
                        autocomplete="off" class="input input-bordered w-full max-w-xs">
                    <label class="label">
                        <span class="label-text-alt text-base-content/60">Timeout for connectivity tests and fallback
                            probes. Should be less than full probe timeout.</span>
                    </label>
                </div>
            </div>
        </div>

        <!-- Notifications Section -->
        <div class="card bg-base-200 shadow-lg mb-4">
            <div class="card-body">
                <h2 class="card-title text-2xl mb-4">Notifications</h2>
                <div class="form-control mb-4">
                    <label class="label" for="info-timeout">
                        <span class="label-text font-medium">Info timeout (ms)</span>
                    </label>
                    <input id="info-timeout" type="number" min="0" max="120000" step="100" placeholder="3500"
                        autocomplete="off" class="input input-bordered w-full max-w-xs">
                    <label class="label">
                        <span class="label-text-alt text-base-content/60">0 keeps the notification until closed.</span>
                    </label>
                </div>

                <div class="form-control mb-4">
                    <label class="label" for="warning-timeout">
                        <span class="label-text font-medium">Warning timeout (ms)</span>
                    </label>
                    <input id="warning-timeout" type="number" min="0" max="120000" step="100" placeholder="4500"
                        autocomplete="off" class="input input-bordered w-full max-w-xs">
                </div>

                <div class="form-control">
                    <label class="label" for="error-timeout">
                        <span class="label-text font-medium">Error timeout (ms)</span>
                    </label>
                    <input id="error-timeout" type="number" min="0" max="120000" step="100" placeholder="0"
                        autocomplete="off" class="input input-bordered w-full max-w-xs">
                    <label class="label">
                        <span class="label-text-alt text-base-content/60">Errors are persistent when set to 0.</span>
                    </label>
                </div>
            </div>
        </div>

        <!-- Troubleshooting Section -->
        <div class="card bg-base-200 shadow-lg mb-4">
            <div class="card-body">
                <h2 class="card-title text-2xl mb-4">Troubleshooting</h2>
                <p class="text-sm text-base-content/60 mb-4">Clear all locally stored settings and cached data. This
                    resets QuickProbe to defaults but does not affect Windows Credential Manager or hosts.csv.</p>
                <div class="flex gap-2 flex-wrap items-center mb-3">
                    <button id="clear-localstorage-btn" class="btn btn-warning gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24"
                            stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                        </svg>
                        Clear LocalStorage
                    </button>
                    <span id="clear-localstorage-status" class="text-sm"></span>
                </div>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="card bg-base-200 shadow-lg mb-4">
            <div class="card-body">
                <div class="flex gap-3 flex-wrap">
                    <button id="save-btn" class="btn btn-primary btn-wide">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24"
                            stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" />
                        </svg>
                        Save All Settings
                    </button>
                    <button id="close-btn" class="btn btn-ghost">Close</button>
                </div>
                <div id="status" class="text-sm font-medium mt-3"></div>
            </div>
        </div>
    </div>

    <!-- Generic Confirmation Modal -->
    <dialog id="confirm-modal" class="modal modal-bottom sm:modal-middle">
        <div class="modal-box">
            <h3 id="confirm-modal-title" class="font-bold text-lg">Confirm</h3>
            <p id="confirm-modal-message" class="py-4 text-base-content/80 whitespace-pre-wrap"></p>
            <div class="modal-action">
                <button type="button" id="confirm-modal-cancel" class="btn">Cancel</button>
                <button type="button" id="confirm-modal-ok" class="btn btn-primary">OK</button>
            </div>
        </div>
        <div class="modal-backdrop bg-black/50" id="confirm-modal-backdrop"></div>
    </dialog>

    <!-- Update Required Modal (Blocking - no close button, no escape, no backdrop click) -->
    <dialog id="update-modal" class="modal">
        <div class="modal-box max-w-lg">
            <div class="text-center mb-6">
                <div class="mx-auto w-16 h-16 mb-4 text-warning">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                    </svg>
                </div>
                <h3 class="font-bold text-2xl text-warning">Update Required</h3>
                <p class="text-base-content/70 mt-2">A new version of QuickProbe is available.</p>
            </div>

            <div class="flex justify-center items-center gap-4 mb-6">
                <div class="text-center p-3 bg-base-200 rounded-lg min-w-24">
                    <div class="text-xs uppercase tracking-wide text-base-content/50 mb-1">Current</div>
                    <div id="update-modal-current" class="font-mono font-bold">v0.0.0</div>
                </div>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-base-content/50" fill="none"
                    viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M14 5l7 7m0 0l-7 7m7-7H3" />
                </svg>
                <div class="text-center p-3 bg-success/20 rounded-lg min-w-24 border border-success/30">
                    <div class="text-xs uppercase tracking-wide text-success/70 mb-1">New</div>
                    <div id="update-modal-new" class="font-mono font-bold text-success">v0.0.0</div>
                </div>
            </div>

            <div class="collapse collapse-arrow bg-base-200 rounded-lg mb-6">
                <input type="checkbox" checked />
                <div class="collapse-title font-medium">What's New</div>
                <div class="collapse-content">
                    <pre id="update-modal-notes"
                        class="text-sm whitespace-pre-wrap text-base-content/80 max-h-48 overflow-y-auto"></pre>
                </div>
            </div>

            <div id="update-modal-error" class="alert alert-error mb-4 hidden">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24"
                    stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <span id="update-modal-error-text"></span>
            </div>

            <div class="flex gap-3 justify-end">
                <button type="button" id="update-modal-quit" class="btn btn-ghost">Quit</button>
                <button type="button" id="update-modal-download" class="btn btn-primary gap-2">
                    <span class="btn-text">Download Update</span>
                    <span class="loading loading-spinner loading-sm hidden"></span>
                </button>
            </div>
        </div>
        <!-- No backdrop click handler - update is mandatory -->
        <div class="modal-backdrop bg-black/70"></div>
    </dialog>

    <script>
        // Tauri 2.x API structure
        const invoke = window.__TAURI__?.core?.invoke;
        const dialog = window.__TAURI__?.dialog;
        const webviewWindow = window.__TAURI__?.webviewWindow;

        function getAppWindow() {
            try {
                // Tauri 2.x uses webviewWindow.getCurrentWebviewWindow()
                if (webviewWindow?.getCurrentWebviewWindow) return webviewWindow.getCurrentWebviewWindow();
            } catch (e) {
                console.warn('getAppWindow failed', e);
            }
            return null;
        }
        const SETTINGS_KEY = 'quickprobe_settings';
        const SERVER_ORDER_KEY = 'qp_server_order';
        const HOST_VIEW_KEY = 'qp_host_view_mode';
        const HOSTS_CHANGED_KEY = 'qp_hosts_changed';
        const settingsDefaultBundle = () => ({
            qp_settings: defaultSettings(),
            qp_server_order: [],
            qp_host_view_mode: 'cards',
            qp_hosts_changed: null,
        });
        let settingsBundle = settingsDefaultBundle();
        let settingsDirty = false;
        let lastSavedSnapshot = '';
        let saveBusy = false;

        function debounce(fn, wait) {
            let t;
            return (...args) => {
                clearTimeout(t);
                t = setTimeout(() => fn(...args), wait);
            };
        }

        // ========== Confirmation Dialog ==========
        let confirmResolve = null;

        function showConfirmDialog(message, options = {}) {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirm-modal');
                const titleEl = document.getElementById('confirm-modal-title');
                const messageEl = document.getElementById('confirm-modal-message');
                const okBtn = document.getElementById('confirm-modal-ok');
                const cancelBtn = document.getElementById('confirm-modal-cancel');
                const backdrop = document.getElementById('confirm-modal-backdrop');

                if (!modal) {
                    resolve(window.confirm(message));
                    return;
                }

                let resolved = false;

                titleEl.textContent = options.title || 'Confirm';
                messageEl.textContent = message;
                okBtn.textContent = options.okText || 'OK';
                okBtn.className = `btn ${options.okClass || 'btn-primary'}`;
                cancelBtn.textContent = options.cancelText || 'Cancel';

                const doResolve = (value) => {
                    if (resolved) return;
                    resolved = true;
                    cleanup();
                    modal.close();
                    resolve(value);
                };

                const handleOk = (e) => { e.preventDefault(); e.stopPropagation(); doResolve(true); };
                const handleCancel = (e) => { e.preventDefault(); e.stopPropagation(); doResolve(false); };
                const handleBackdropClick = (e) => { e.preventDefault(); e.stopPropagation(); doResolve(false); };
                const handleKeydown = (e) => { if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); doResolve(false); } };
                const handleClose = () => { doResolve(false); };

                const cleanup = () => {
                    okBtn.removeEventListener('click', handleOk);
                    cancelBtn.removeEventListener('click', handleCancel);
                    if (backdrop) backdrop.removeEventListener('click', handleBackdropClick);
                    modal.removeEventListener('keydown', handleKeydown);
                    modal.removeEventListener('close', handleClose);
                    confirmResolve = null;
                };

                confirmResolve = doResolve;
                okBtn.addEventListener('click', handleOk);
                cancelBtn.addEventListener('click', handleCancel);
                if (backdrop) backdrop.addEventListener('click', handleBackdropClick);
                modal.addEventListener('keydown', handleKeydown);
                modal.addEventListener('close', handleClose);

                modal.showModal();
                okBtn.focus();
            });
        }
        // ========== End Confirmation Dialog ==========

        function queueSettingsSave(payload) {
            if (!invoke) return;
            queueSettingsSave._fn = queueSettingsSave._fn || debounce((body) => {
                console.log('[Settings] Saving to backend:', JSON.stringify(body, null, 2));
                invoke('settings_set_all', { payload: body }).then((result) => {
                    console.log('[Settings] Save successful:', result);
                }).catch((err) => {
                    console.error('[Settings] settings_set_all failed:', err);
                });
            }, 200);
            queueSettingsSave._fn(payload);
        }

        function settingsPayload() {
            return {
                qp_settings: settingsBundle.qp_settings,
                qp_server_order: settingsBundle.qp_server_order,
                qp_host_view_mode: settingsBundle.qp_host_view_mode,
                qp_hosts_changed: settingsBundle.qp_hosts_changed,
            };
        }

        function revealApp() {
            if (window.__qpPreloadTimer) {
                clearTimeout(window.__qpPreloadTimer);
                window.__qpPreloadTimer = null;
            }
            if (typeof window.__qpRevealSettings === 'function') {
                window.__qpRevealSettings();
            } else {
                document.documentElement.classList.remove('qp-preload');
            }
        }

        function readLocalSettingsSnapshot() {
            const snapshot = settingsDefaultBundle();
            try {
                const raw = localStorage.getItem(SETTINGS_KEY);
                if (raw) snapshot.qp_settings = JSON.parse(raw);
            } catch (e) { /* ignore */ }
            try {
                const raw = localStorage.getItem(SERVER_ORDER_KEY);
                if (raw) snapshot.qp_server_order = JSON.parse(raw);
            } catch (e) { /* ignore */ }
            try {
                const raw = localStorage.getItem(HOST_VIEW_KEY);
                if (raw) snapshot.qp_host_view_mode = JSON.parse(raw);
            } catch (e) { /* ignore */ }
            try {
                const raw = localStorage.getItem(HOSTS_CHANGED_KEY);
                if (raw) snapshot.qp_hosts_changed = JSON.parse(raw);
            } catch (e) { /* ignore */ }
            return snapshot;
        }

        async function primeSettingsFromBackend() {
            const fallbackSnapshot = readLocalSettingsSnapshot();
            settingsBundle = { ...fallbackSnapshot };
            if (!invoke) {
                console.warn('settings_get_all unavailable; using fallback snapshot');
                return { usedFallback: true };
            }
            try {
                const bundle = await invoke('settings_get_all');
                settingsBundle = {
                    qp_settings: bundle?.qp_settings || fallbackSnapshot.qp_settings,
                    qp_server_order: bundle?.qp_server_order || fallbackSnapshot.qp_server_order,
                    qp_host_view_mode: bundle?.qp_host_view_mode || fallbackSnapshot.qp_host_view_mode,
                    qp_hosts_changed: bundle?.qp_hosts_changed ?? fallbackSnapshot.qp_hosts_changed,
                };
                // Sync loaded settings to localStorage to keep them in sync with backend
                try {
                    if (settingsBundle.qp_settings) {
                        localStorage.setItem(SETTINGS_KEY, JSON.stringify(settingsBundle.qp_settings));
                    }
                } catch (e) {
                    console.warn('Failed to sync settings to localStorage', e);
                }
                return { usedFallback: false };
            } catch (err) {
                console.warn('settings_get_all failed; using fallback snapshot', err);
                return { usedFallback: true };
            }
        }

        function applyThemeValue(themeSetting) {
            if (window.ThemeModule?.applyTheme) {
                window.ThemeModule.applyTheme(themeSetting);
            } else {
                // Fallback if ThemeModule not loaded - use basic theme resolution
                let resolved = themeSetting;
                if (themeSetting === 'system') {
                    resolved = window.matchMedia?.('(prefers-color-scheme: light)').matches ? 'light' : 'dark';
                }
                document.documentElement.setAttribute('data-theme', resolved);
                logDebug('[Options] Theme applied (fallback): ' + resolved);
            }
        }

        function applyThemeFromSettings() {
            const themeSetting = typeof settingsBundle?.qp_settings?.theme === 'string'
                ? settingsBundle.qp_settings.theme
                : 'dark';
            applyThemeValue(themeSetting);
        }

        function disableAutocompleteAll() {
            document.querySelectorAll('input, textarea').forEach(el => {
                el.setAttribute('autocomplete', 'off');
                if (el.getAttribute('type') === 'text') {
                    el.setAttribute('spellcheck', 'false');
                }
            });
        }

        function defaultSettings() {
            return {
                probeTimeoutSeconds: 60,
                quickProbeTimeoutSeconds: 30,
                infoTimeoutMs: 3500,
                warningTimeoutMs: 4500,
                errorTimeoutMs: 0,
                locationMappings: [],
                theme: 'system'
            };
        }

        function captureSettingsSnapshot() {
            return JSON.stringify({
                probeTimeout: document.getElementById('probe-timeout')?.value,
                quickProbeTimeout: document.getElementById('quick-probe-timeout')?.value,
                infoTimeout: document.getElementById('info-timeout')?.value,
                warningTimeout: document.getElementById('warning-timeout')?.value,
                errorTimeout: document.getElementById('error-timeout')?.value,
                theme: document.getElementById('theme-select')?.value,
                locations: readLocationMappingsFromDom().mappings,
                startHidden: document.getElementById('start-hidden-toggle')?.checked
            });
        }

        function markSettingsDirty() {
            if (saveBusy) return;
            const currentSnapshot = captureSettingsSnapshot();
            if (currentSnapshot !== lastSavedSnapshot) {
                settingsDirty = true;
            }
        }

        function clearSettingsDirty() {
            settingsDirty = false;
            lastSavedSnapshot = captureSettingsSnapshot();
        }

        function setThemeSelection(value) {
            const el = document.getElementById('theme-select');
            if (!el) return;
            // Accept all valid DaisyUI theme names
            const validThemes = ['system', 'dark', 'light', 'cupcake', 'bumblebee', 'emerald', 'corporate',
                'synthwave', 'retro', 'cyberpunk', 'valentine', 'halloween', 'garden',
                'forest', 'aqua', 'lofi', 'pastel', 'fantasy', 'wireframe', 'black',
                'luxury', 'dracula', 'cmyk', 'autumn', 'business', 'acid', 'lemonade',
                'night', 'coffee', 'winter', 'dim', 'nord', 'sunset'];
            const normalized = validThemes.includes(value) ? value : 'system';
            el.value = normalized;
            applyThemeValue(normalized);
        }

        function getThemeSelection(fallback = 'system') {
            const el = document.getElementById('theme-select');
            if (!el) return fallback;
            const val = el.value;
            // Accept any theme value from the dropdown (includes all 32 DaisyUI themes)
            return val || fallback;
        }

        function normalizeLocationMappings(raw) {
            if (!Array.isArray(raw)) return [];
            return raw.map(item => {
                const cidr = typeof item?.cidr === 'string' ? item.cidr.trim() : '';
                const range = typeof item?.range === 'string' ? item.range.trim() : '';
                const start = typeof item?.start === 'string' ? item.start.trim() : '';
                const end = typeof item?.end === 'string' ? item.end.trim() : '';
                const label = typeof item?.label === 'string' ? item.label.trim() : '';
                const rawValue = cidr || range || (start && end ? `${start}-${end}` : start || '');
                const parsed = rangeFromInput(rawValue);
                const canonical = parsed && !parsed.error ? (parsed.canonical || rawValue) : rawValue;
                return { cidr: canonical, range: canonical, label };
            }).filter(entry => (entry.cidr || entry.range) && entry.label);
        }

        function loadSettings() {
            const parsed = (typeof settingsBundle?.qp_settings === 'object' && settingsBundle.qp_settings !== null)
                ? settingsBundle.qp_settings
                : {};
            console.log('[Options] loadSettings - parsed.locationMappings:', parsed.locationMappings);
            const normalized = normalizeLocationMappings(parsed.locationMappings);
            console.log('[Options] loadSettings - normalized locationMappings:', normalized);
            return {
                ...defaultSettings(),
                ...parsed,
                locationMappings: normalized,
            };
        }

        async function saveSettings(settings) {
            console.log('[saveSettings] Saving settings:', settings);
            console.log('[saveSettings] settings.locationMappings:', settings.locationMappings);
            console.log('[saveSettings] settings.theme:', settings.theme);
            settingsBundle.qp_settings = settings;
            console.log('[saveSettings] settingsBundle.qp_settings after assignment:', settingsBundle.qp_settings);

            const payload = settingsPayload();

            // Save to backend FIRST and wait for completion
            if (window.__TAURI__?.core?.invoke) {
                try {
                    console.log('[saveSettings] Saving to backend database...');
                    await window.__TAURI__.core.invoke('settings_set_all', { payload });
                    console.log('[saveSettings] Backend save successful');
                } catch (err) {
                    console.error('[saveSettings] Backend save failed:', err);
                    // Continue to update localStorage and emit event even if backend fails
                }
            }

            // Update localStorage AFTER backend save completes
            try {
                localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
                console.log('[saveSettings] localStorage updated, key:', SETTINGS_KEY);
            } catch (e) {
                console.warn('Failed to write settings to localStorage', e);
            }

            // Emit Tauri event AFTER backend save completes
            // This ensures dashboard will read fresh data from backend when it receives the event
            if (window.__TAURI__?.event?.emit) {
                window.__TAURI__.event.emit('settings-updated', {
                    timestamp: Date.now(),
                    theme: settings.theme,
                    hasLocationMappings: Array.isArray(settings.locationMappings) && settings.locationMappings.length > 0
                }).then(() => {
                    console.log('[saveSettings] Tauri event emitted: settings-updated');
                }).catch(err => {
                    console.warn('Failed to emit settings-updated event', err);
                });
            }
        }

        async function hydrateStartHiddenSetting() {
            const checkbox = document.getElementById('start-hidden-toggle');
            if (!checkbox || !invoke) return;
            try {
                const enabled = await invoke('get_start_hidden_setting');
                checkbox.checked = !!enabled;
            } catch (e) {
                showStatus(`Failed to load start-hidden preference: ${e}`, true);
            }
        }

        async function persistStartHiddenSetting(enabled) {
            if (!invoke) {
                showStatus('Tauri API not available', true);
                return;
            }
            try {
                const saved = await invoke('set_start_hidden_setting', {
                    args: {
                        startHidden: enabled
                    }
                });
                showStatus(saved ? 'Will start hidden when credentials are saved' : 'Will show window on start');
            } catch (e) {
                showStatus(`Failed to save start-hidden preference: ${e}`, true);
                const checkbox = document.getElementById('start-hidden-toggle');
                if (checkbox) checkbox.checked = !enabled;
            }
        }

        function showStatus(message, isError = false) {
            const el = document.getElementById('status');
            if (!el) return;
            el.textContent = message;
            el.style.color = isError ? '#fca5a5' : '#a5b4fc';
        }

        function showBackupStatus(message, isError = false) {
            const el = document.getElementById('backup-status');
            if (!el) return;
            el.textContent = message;
            el.style.color = isError ? '#fca5a5' : '#a5b4fc';
        }

        function showModeStatus(message = '', isError = false) {
            const el = document.getElementById('mode-status');
            if (!el) return;
            el.textContent = message;
            el.style.color = isError ? '#fca5a5' : '#a5b4fc';
        }

        function resetStatusMessages() {
            showStatus('');
            showBackupStatus('');
            showModeStatus('');
        }

        function ipToInt(ip) {
            const parts = (ip || '').trim().split('.');
            if (parts.length !== 4) return null;
            const bytes = parts.map(p => Number(p));
            if (bytes.some(b => !Number.isInteger(b) || b < 0 || b > 255)) {
                return null;
            }
            return ((bytes[0] << 24) >>> 0) + (bytes[1] << 16) + (bytes[2] << 8) + bytes[3];
        }

        function intToIp(intValue) {
            const v = Number(intValue) >>> 0;
            return [
                (v >>> 24) & 255,
                (v >>> 16) & 255,
                (v >>> 8) & 255,
                v & 255
            ].join('.');
        }

        function cidrToRange(value) {
            const raw = (value || '').trim();
            if (!raw) return { error: 'CIDR/IP is required' };
            if (!raw.includes('/')) {
                const single = ipToInt(raw);
                if (single === null) return { error: 'Invalid IP address' };
                return { start: single, end: single, prefix: 32 };
            }
            const [ipPart, prefixPart] = raw.split('/');
            const prefix = Number(prefixPart);
            const base = ipToInt(ipPart);
            if (base === null || !Number.isInteger(prefix) || prefix < 0 || prefix > 32) {
                return { error: 'Invalid CIDR notation' };
            }
            const mask = prefix === 0 ? 0 : (~0 << (32 - prefix)) >>> 0;
            const start = base & mask;
            const end = start | (~mask >>> 0);
            return { start, end, prefix };
        }

        function rangeFromInput(value) {
            const trimmed = (value || '').trim();
            if (!trimmed) return { error: 'IP or CIDR is required' };
            if (trimmed.includes('-')) {
                const [startRaw, endRaw] = trimmed.split('-');
                const start = ipToInt(startRaw);
                const end = ipToInt(endRaw || startRaw);
                if (start === null || end === null) return { error: 'Invalid IP range' };
                const min = Math.min(start, end);
                const max = Math.max(start, end);
                const canonical = `${intToIp(min)}-${intToIp(max)}`;
                return { start: min, end: max, canonical };
            }
            if (trimmed.includes('/')) {
                const cidrRange = cidrToRange(trimmed);
                if (cidrRange.error) return cidrRange;
                const canonical = `${intToIp(cidrRange.start)}/${cidrRange.prefix}`;
                return { start: cidrRange.start, end: cidrRange.end, canonical };
            }
            const single = ipToInt(trimmed);
            if (single === null) return { error: 'Invalid IP address' };
            const canonical = intToIp(single);
            return { start: single, end: single, canonical };
        }

        function ensureLocationPlaceholder() {
            const placeholder = document.getElementById('location-empty');
            const container = document.getElementById('location-rows');
            if (!placeholder) return;
            const hasRows = !!(container && container.querySelectorAll('.location-row').length);
            placeholder.style.display = hasRows ? 'none' : 'block';
        }

        function addLocationRow(entry = {}) {
            const container = document.getElementById('location-rows');
            if (!container) return;
            const row = document.createElement('div');
            row.className = 'location-row flex gap-3 items-end p-3 bg-base-100 rounded-lg border border-base-300';
            row.innerHTML = `
                <div class="form-control flex-1">
                    <label class="label">
                        <span class="label-text font-medium">IP or CIDR</span>
                    </label>
                    <input type="text" class="location-cidr input input-bordered input-sm w-full" 
                        placeholder="10.0.0.0/24 or 10.0.0.5" value="${entry.cidr || ''}" autocomplete="off">
                </div>
                <div class="form-control flex-1">
                    <label class="label">
                        <span class="label-text font-medium">Location</span>
                    </label>
                    <input type="text" class="location-label input input-bordered input-sm w-full" 
                        placeholder="Data Center A" value="${entry.label || ''}" autocomplete="off">
                </div>
                <button type="button" class="remove-location-btn btn btn-error btn-sm">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            `;
            const removeBtn = row.querySelector('.remove-location-btn');
            if (removeBtn) {
                removeBtn.addEventListener('click', () => {
                    row.remove();
                    ensureLocationPlaceholder();
                    markSettingsDirty();
                });
            }
            // Track changes in location inputs
            const cidrInput = row.querySelector('.location-cidr');
            const labelInput = row.querySelector('.location-label');
            if (cidrInput) cidrInput.addEventListener('input', markSettingsDirty);
            if (labelInput) labelInput.addEventListener('input', markSettingsDirty);

            container.appendChild(row);
            ensureLocationPlaceholder();
        }

        function renderLocationRows(locations) {
            const container = document.getElementById('location-rows');
            if (!container) {
                console.warn('[Options] renderLocationRows - container not found');
                return;
            }
            container.innerHTML = '';
            const list = normalizeLocationMappings(locations);
            console.log('[Options] renderLocationRows - input:', locations, '| normalized:', list);
            if (!list.length) {
                ensureLocationPlaceholder();
                return;
            }
            list.forEach(loc => addLocationRow({ cidr: loc.cidr || loc.range, label: loc.label }));
            ensureLocationPlaceholder();
        }

        function readLocationMappingsFromDom() {
            const container = document.getElementById('location-rows');
            const rows = container ? Array.from(container.querySelectorAll('.location-row')) : [];
            const mappings = [];
            const errors = [];

            rows.forEach((row, index) => {
                const cidr = (row.querySelector('.location-cidr')?.value || '').trim();
                const label = (row.querySelector('.location-label')?.value || '').trim();
                if (!cidr && !label) {
                    return;
                }

                if (!label) {
                    errors.push(`Row ${index + 1}: Location label is required`);
                    return;
                }

                const range = rangeFromInput(cidr);
                if (range.error) {
                    errors.push(`Row ${index + 1}: ${range.error}`);
                    return;
                }

                const canonical = range.canonical || cidr;
                mappings.push({
                    cidr: canonical,
                    range: canonical,
                    label
                });
            });

            return { mappings, errors };
        }

        async function refreshAutostart() {
            const statusEl = document.getElementById('autostart-status');
            if (!statusEl || !invoke) return;
            statusEl.textContent = 'Checking autostart...';
            try {
                const enabled = await invoke('check_autostart');
                statusEl.textContent = enabled ? 'Autostart is enabled' : 'Autostart is disabled';
            } catch (e) {
                statusEl.textContent = `Failed to read autostart: ${e}`;
            }
        }

        async function toggleAutostart() {
            const statusEl = document.getElementById('autostart-status');
            if (!invoke) {
                showStatus('Tauri API not available', true);
                return;
            }
            try {
                const enabled = await invoke('toggle_autostart');
                statusEl.textContent = enabled ? 'Autostart is enabled' : 'Autostart is disabled';
                showStatus('Autostart updated');
            } catch (e) {
                showStatus(`Failed to toggle autostart: ${e}`, true);
            }
        }
        function populateSettings() {
            const settings = loadSettings();
            console.log('[Options] populateSettings - settings.locationMappings:', settings.locationMappings);
            document.getElementById('probe-timeout').value = settings.probeTimeoutSeconds;
            document.getElementById('quick-probe-timeout').value = settings.quickProbeTimeoutSeconds;
            document.getElementById('info-timeout').value = settings.infoTimeoutMs;
            document.getElementById('warning-timeout').value = settings.warningTimeoutMs;
            document.getElementById('error-timeout').value = settings.errorTimeoutMs;
            setThemeSelection(settings.theme);
            renderLocationRows(settings.locationMappings);
            clearSettingsDirty();
        }

        function parseTimeout(inputEl, fallback) {
            const val = Number(inputEl.value);
            if (Number.isNaN(val) || val < 0) return fallback;
            return Math.min(val, 120000);
        }

        function parseProbeTimeoutSeconds(inputEl, fallback) {
            const val = Number(inputEl.value);
            if (Number.isNaN(val) || val < 10) return fallback;
            return Math.min(val, 600);
        }

        function parseQuickProbeTimeoutSeconds(inputEl, fallback) {
            const val = Number(inputEl.value);
            if (Number.isNaN(val) || val < 5) return fallback;
            return Math.min(val, 120);
        }

        function wireEvents() {
            const toggleBtn = document.getElementById('toggle-autostart-btn');
            if (toggleBtn) toggleBtn.addEventListener('click', toggleAutostart);

            const startHiddenToggle = document.getElementById('start-hidden-toggle');
            if (startHiddenToggle) {
                startHiddenToggle.addEventListener('change', (event) => {
                    persistStartHiddenSetting(event.target.checked);
                });
            }

            const themeSelect = document.getElementById('theme-select');
            if (themeSelect) {
                themeSelect.addEventListener('change', () => {
                    const newTheme = getThemeSelection();
                    applyThemeValue(newTheme);

                    // Save theme to localStorage AND backend immediately for cross-window sync
                    // This allows instant preview in all windows and persists the change
                    try {
                        const currentSettings = loadSettings();
                        currentSettings.theme = newTheme;
                        settingsBundle.qp_settings = currentSettings;

                        // Save to localStorage (for instant cross-window sync)
                        localStorage.setItem(SETTINGS_KEY, JSON.stringify(currentSettings));
                        console.log('[Theme Change] Theme saved to localStorage for cross-window sync:', newTheme);

                        // Save to backend (for persistence across sessions)
                        queueSettingsSave(settingsPayload());
                        console.log('[Theme Change] Theme queued for backend save:', newTheme);

                        // Emit Tauri event to notify other windows
                        if (window.__TAURI__?.event?.emit) {
                            window.__TAURI__.event.emit('settings-updated', {
                                timestamp: Date.now(),
                                theme: newTheme
                            }).catch(err => console.warn('Failed to emit settings-updated event', err));
                        }
                    } catch (e) {
                        console.warn('[Theme Change] Failed to save theme:', e);
                    }

                    markSettingsDirty();
                });
            }

            // Track changes in all input fields
            const trackableInputs = [
                'probe-timeout',
                'quick-probe-timeout',
                'info-timeout',
                'warning-timeout',
                'error-timeout',
                'theme-select'
            ];
            trackableInputs.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', markSettingsDirty);
                    el.addEventListener('change', markSettingsDirty);
                }
            });

            const addLocationBtn = document.getElementById('add-location-btn');
            if (addLocationBtn) {
                addLocationBtn.addEventListener('click', () => {
                    addLocationRow({});
                    markSettingsDirty();
                    const lastCidr = document.querySelector('.location-row:last-of-type .location-cidr');
                    if (lastCidr) lastCidr.focus();
                });
            }

            const saveBtn = document.getElementById('save-btn');
            if (saveBtn) {
                saveBtn.addEventListener('click', async () => {
                    if (saveBusy) {
                        showStatus('Save already in progress', true);
                        return;
                    }

                    const current = loadSettings();
                    const previousSettings = { ...settingsBundle };
                    const locationResult = readLocationMappingsFromDom();

                    if (locationResult.errors.length) {
                        showStatus(locationResult.errors[0], true);
                        return;
                    }

                    // Validate timeout values
                    const probeTimeout = parseProbeTimeoutSeconds(document.getElementById('probe-timeout'), current.probeTimeoutSeconds);
                    const quickProbeTimeout = parseQuickProbeTimeoutSeconds(document.getElementById('quick-probe-timeout'), current.quickProbeTimeoutSeconds);
                    const infoTimeout = parseTimeout(document.getElementById('info-timeout'), current.infoTimeoutMs);
                    const warningTimeout = parseTimeout(document.getElementById('warning-timeout'), current.warningTimeoutMs);
                    const errorTimeout = parseTimeout(document.getElementById('error-timeout'), current.errorTimeoutMs);

                    if (probeTimeout < 10 || probeTimeout > 600) {
                        showStatus('Full probe timeout must be between 10 and 600 seconds', true);
                        return;
                    }

                    if (quickProbeTimeout < 5 || quickProbeTimeout > 120) {
                        showStatus('Quick probe timeout must be between 5 and 120 seconds', true);
                        return;
                    }

                    if (quickProbeTimeout >= probeTimeout) {
                        showStatus('Quick probe timeout must be less than full probe timeout', true);
                        return;
                    }

                    const nextTheme = getThemeSelection(current.theme);
                    const next = {
                        ...current,
                        probeTimeoutSeconds: probeTimeout,
                        quickProbeTimeoutSeconds: quickProbeTimeout,
                        infoTimeoutMs: infoTimeout,
                        warningTimeoutMs: warningTimeout,
                        errorTimeoutMs: errorTimeout,
                        locationMappings: locationResult.mappings,
                        theme: nextTheme
                    };

                    saveBusy = true;
                    console.log('[Save] About to save settings with locationMappings:', next.locationMappings);
                    try {
                        await saveSettings(next);
                        console.log('[Save] Settings saved, settingsBundle.qp_settings.locationMappings:', settingsBundle.qp_settings.locationMappings);
                        applyThemeValue(nextTheme);
                        renderLocationRows(next.locationMappings);
                        console.log('[Save] Re-rendered location rows');
                        clearSettingsDirty();
                        showStatus('Settings saved');
                    } catch (error) {
                        // Rollback on error
                        settingsBundle = previousSettings;
                        populateSettings();
                        showStatus(`Failed to save settings: ${error}`, true);
                    } finally {
                        saveBusy = false;
                    }
                });
            }

            const closeBtn = document.getElementById('close-btn');
            if (closeBtn) closeBtn.addEventListener('click', async () => {
                if (settingsDirty) {
                    const confirmed = await showConfirmDialog(
                        'You have unsaved changes. Are you sure you want to close without saving?',
                        { title: 'Unsaved Changes', okText: 'Close', okClass: 'btn-warning' }
                    );
                    if (!confirmed) return;
                }
                hideOptionsWindow();
            });

            const backupBtn = document.getElementById('backup-btn');
            if (backupBtn) backupBtn.addEventListener('click', createBackup);

            const restoreBtn = document.getElementById('restore-btn');
            if (restoreBtn) restoreBtn.addEventListener('click', restoreBackup);

            const exportCsvBtn = document.getElementById('export-csv-btn');
            if (exportCsvBtn) exportCsvBtn.addEventListener('click', exportHostsCSV);

            const clearLocalStorageBtn = document.getElementById('clear-localstorage-btn');
            if (clearLocalStorageBtn) clearLocalStorageBtn.addEventListener('click', clearLocalStorage);
        }

        function showClearLocalStorageStatus(message, isError = false) {
            const statusEl = document.getElementById('clear-localstorage-status');
            if (!statusEl) return;
            statusEl.textContent = message;
            statusEl.className = 'text-sm ' + (isError ? 'text-error' : 'text-success');
            if (message && !isError) {
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 5000);
            }
        }

        async function clearLocalStorage() {
            const confirmed = await showConfirmDialog(
                'This will clear all locally stored settings and cached data.\n\n' +
                ' Theme, timeouts, and location mappings will reset to defaults\n' +
                ' Host cache and probe history will be cleared\n' +
                ' Windows credentials and hosts.csv are NOT affected\n\n' +
                'The application will reload after clearing.',
                { title: 'Clear LocalStorage?', okText: 'Clear Data', okClass: 'btn-warning' }
            );
            if (!confirmed) return;

            try {
                localStorage.clear();
                showClearLocalStorageStatus('LocalStorage cleared. Reloading...');
                setTimeout(() => {
                    window.location.reload();
                }, 1000);
            } catch (error) {
                console.error('Failed to clear localStorage:', error);
                showClearLocalStorageStatus(`Failed to clear: ${error}`, true);
            }
        }

        function collectLocalStorage() {
            const snapshot = {};
            for (let i = 0; i < localStorage.length; i += 1) {
                const key = localStorage.key(i);
                if (!key) continue;
                snapshot[key] = localStorage.getItem(key);
            }
            return snapshot;
        }

        async function createBackup() {
            showBackupStatus('');
            if (saveBusy) {
                showBackupStatus('Please wait for current operation to complete', true);
                return;
            }
            if (!invoke || !dialog) {
                showBackupStatus('Tauri API not available', true);
                return;
            }
            const password = (document.getElementById('backup-password')?.value || '').trim();
            if (!password) {
                showBackupStatus('Enter a password to protect the backup', true);
                return;
            }
            if (password.length < 4) {
                showBackupStatus('Password must be at least 4 characters', true);
                return;
            }

            const defaultName = `QuickProbe-backup-${new Date().toISOString().slice(0, 10)}.zip`;
            const destination = await dialog.save({
                defaultPath: defaultName,
                filters: [{ name: 'QuickProbe Backup', extensions: ['zip'] }]
            });
            if (!destination) return;

            try {
                const savedPath = await invoke('export_backup_encrypted', {
                    destination,
                    password
                });
                showBackupStatus(`Backup saved to ${savedPath || destination}`);
            } catch (e) {
                showBackupStatus(`Backup failed: ${e}`, true);
            }
        }

        async function restoreBackup() {
            showBackupStatus('');
            if (saveBusy) {
                showBackupStatus('Please wait for current operation to complete', true);
                return;
            }
            if (settingsDirty) {
                const confirmed = await showConfirmDialog(
                    'You have unsaved changes. Restoring will overwrite them. Continue?',
                    { title: 'Unsaved Changes', okText: 'Continue', okClass: 'btn-warning' }
                );
                if (!confirmed) return;
            }
            if (!invoke || !dialog) {
                showBackupStatus('Tauri API not available', true);
                return;
            }
            const password = (document.getElementById('backup-password')?.value || '').trim();
            if (!password) {
                showBackupStatus('Enter the password for the backup', true);
                return;
            }
            const selection = await dialog.open({
                multiple: false,
                filters: [{ name: 'QuickProbe Backup', extensions: ['zip'] }]
            });
            const source = Array.isArray(selection) ? selection[0] : selection;
            if (!source) return;

            try {
                const result = await invoke('import_backup_encrypted', { source, password });
                const ls = (result && result.local_storage && typeof result.local_storage === 'object')
                    ? result.local_storage
                    : {};
                if (ls.qp_settings) settingsBundle.qp_settings = ls.qp_settings;
                if (ls.qp_server_order) settingsBundle.qp_server_order = ls.qp_server_order;
                if (ls.qp_host_view_mode) settingsBundle.qp_host_view_mode = ls.qp_host_view_mode;
                if (ls.qp_hosts_changed !== undefined) settingsBundle.qp_hosts_changed = ls.qp_hosts_changed;
                populateSettings();
                clearSettingsDirty();
                showBackupStatus('Backup restored. Hosts and settings updated.');
            } catch (e) {
                showBackupStatus(`Restore failed: ${e}`, true);
            }
        }

        function showCsvExportStatus(message, isError = false) {
            const status = document.getElementById('csv-export-status');
            if (!status) return;
            status.textContent = message;
            status.className = `text-sm font-medium ${isError ? 'text-error' : 'text-success'}`;
        }

        async function exportHostsCSV() {
            showCsvExportStatus('');
            if (!invoke || !dialog) {
                showCsvExportStatus('Tauri API not available', true);
                return;
            }

            const defaultName = `QuickProbe-hosts-${new Date().toISOString().slice(0, 10)}.csv`;
            const destination = await dialog.save({
                defaultPath: defaultName,
                filters: [{ name: 'CSV Files', extensions: ['csv'] }]
            });
            if (!destination) return;

            try {
                const savedPath = await invoke('export_hosts_csv', {
                    destination
                });
                showCsvExportStatus(`CSV exported to ${savedPath || destination}`);
            } catch (e) {
                showCsvExportStatus(`Export failed: ${e}`, true);
            }
        }

        // ========== Update Check Functions ==========
        let updateCheckBusy = false;
        let pendingUpdateInfo = null;

        function showUpdateCheckStatus(message, isError = false, isSuccess = false) {
            const el = document.getElementById('update-check-status');
            if (!el) return;
            el.textContent = message;
            if (isError) {
                el.className = 'text-sm text-error';
            } else if (isSuccess) {
                el.className = 'text-sm text-success';
            } else {
                el.className = 'text-sm text-base-content/70';
            }
        }

        async function displayCurrentVersion() {
            const el = document.getElementById('current-version-display');
            if (!el) return;

            try {
                if (invoke) {
                    const appInfo = await invoke('get_app_info');
                    if (appInfo && appInfo.version) {
                        el.textContent = `v${appInfo.version}`;
                    } else {
                        el.textContent = 'Unknown';
                    }
                } else {
                    el.textContent = 'N/A';
                }
            } catch (error) {
                console.warn('Failed to get app version:', error);
                el.textContent = 'Error';
            }
        }

        function setUpdateCheckLoading(loading) {
            const btn = document.getElementById('check-updates-btn');
            if (!btn) return;
            if (loading) {
                btn.disabled = true;
                btn.innerHTML = `
                    <span class="loading loading-spinner loading-sm"></span>
                    Checking...
                `;
            } else {
                btn.disabled = false;
                btn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24"
                        stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                    Check for Updates
                `;
            }
        }

        function showUpdateModal(updateInfo) {
            pendingUpdateInfo = updateInfo;
            const modal = document.getElementById('update-modal');
            const currentEl = document.getElementById('update-modal-current');
            const newEl = document.getElementById('update-modal-new');
            const notesEl = document.getElementById('update-modal-notes');
            const errorEl = document.getElementById('update-modal-error');

            if (!modal) return;

            // Populate modal
            if (currentEl) currentEl.textContent = `v${updateInfo.current_version}`;
            if (newEl) newEl.textContent = `v${updateInfo.version}`;
            if (notesEl) {
                // Clean up markdown
                let notes = updateInfo.body || 'No release notes available.';
                notes = notes
                    .replace(/^#+\s*/gm, '')
                    .replace(/\*\*(.*?)\*\*/g, '$1')
                    .replace(/__(.*?)__/g, '$1')
                    .replace(/\*(.*?)\*/g, '$1')
                    .replace(/_(.*?)_/g, '$1')
                    .trim();
                notesEl.textContent = notes;
            }

            // Hide any previous error
            if (errorEl) errorEl.classList.add('hidden');

            // Reset download button
            setUpdateDownloadLoading(false);

            // Show modal - prevent escape key from closing
            modal.showModal();

            // Prevent escape key
            modal.addEventListener('cancel', preventModalClose);
            modal.addEventListener('keydown', handleUpdateModalKeydown);
        }

        function preventModalClose(e) {
            e.preventDefault();
        }

        function handleUpdateModalKeydown(e) {
            if (e.key === 'Escape') {
                e.preventDefault();
                e.stopPropagation();
            }
        }

        function hideUpdateModal() {
            const modal = document.getElementById('update-modal');
            if (!modal) return;
            modal.removeEventListener('cancel', preventModalClose);
            modal.removeEventListener('keydown', handleUpdateModalKeydown);
            modal.close();
            pendingUpdateInfo = null;
        }

        function showUpdateModalError(message) {
            const errorEl = document.getElementById('update-modal-error');
            const textEl = document.getElementById('update-modal-error-text');
            if (errorEl && textEl) {
                textEl.textContent = message;
                errorEl.classList.remove('hidden');
            }
        }

        function setUpdateDownloadLoading(loading) {
            const btn = document.getElementById('update-modal-download');
            const textEl = btn?.querySelector('.btn-text');
            const spinnerEl = btn?.querySelector('.loading');
            const quitBtn = document.getElementById('update-modal-quit');

            if (loading) {
                if (btn) btn.disabled = true;
                if (quitBtn) quitBtn.disabled = true;
                if (textEl) textEl.textContent = 'Downloading...';
                if (spinnerEl) spinnerEl.classList.remove('hidden');
            } else {
                if (btn) btn.disabled = false;
                if (quitBtn) quitBtn.disabled = false;
                if (textEl) textEl.textContent = 'Download Update';
                if (spinnerEl) spinnerEl.classList.add('hidden');
            }
        }

        async function checkForUpdates() {
            if (updateCheckBusy) return;
            if (!invoke) {
                showUpdateCheckStatus('Tauri API not available', true);
                return;
            }

            updateCheckBusy = true;
            setUpdateCheckLoading(true);
            showUpdateCheckStatus('Checking...');

            try {
                const updateInfo = await invoke('check_for_update');

                // Update the version display badge
                const versionEl = document.getElementById('current-version-display');
                if (versionEl && updateInfo.current_version) {
                    versionEl.textContent = `v${updateInfo.current_version}`;
                }

                if (updateInfo.available) {
                    // Update is available - show blocking modal
                    showUpdateModal(updateInfo);
                    showUpdateCheckStatus(`Update available: v${updateInfo.version}`, false, false);
                } else {
                    // No update available
                    showUpdateCheckStatus('You are running the latest version.', false, true);
                }
            } catch (error) {
                console.error('Update check failed:', error);
                showUpdateCheckStatus(`Failed to check: ${error}`, true);
            } finally {
                updateCheckBusy = false;
                setUpdateCheckLoading(false);
            }
        }

        async function handleUpdateDownload() {
            if (!pendingUpdateInfo || !invoke) return;

            setUpdateDownloadLoading(true);

            try {
                await invoke('download_and_install_update', { updateInfo: pendingUpdateInfo });

                // Give installer time to start, then exit
                setTimeout(async () => {
                    try {
                        if (window.__TAURI__?.process?.exit) {
                            await window.__TAURI__.process.exit(0);
                        } else {
                            window.close();
                        }
                    } catch {
                        window.close();
                    }
                }, 1000);
            } catch (error) {
                console.error('Download failed:', error);
                setUpdateDownloadLoading(false);
                showUpdateModalError(`Download failed: ${error}`);
            }
        }

        async function handleUpdateQuit() {
            try {
                if (window.__TAURI__?.process?.exit) {
                    await window.__TAURI__.process.exit(0);
                } else {
                    window.close();
                }
            } catch {
                window.close();
            }
        }

        function wireUpdateEvents() {
            // Modal handlers for when update is required (triggered from About dialog)
            const downloadBtn = document.getElementById('update-modal-download');
            if (downloadBtn) {
                downloadBtn.addEventListener('click', handleUpdateDownload);
            }

            const quitBtn = document.getElementById('update-modal-quit');
            if (quitBtn) {
                quitBtn.addEventListener('click', handleUpdateQuit);
            }
        }
        // ========== End Update Check Functions ==========

        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await primeSettingsFromBackend();
                applyThemeFromSettings();
                disableAutocompleteAll();
                populateSettings();
                hydrateStartHiddenSetting();
                refreshAutostart();
                wireEvents();
                wireUpdateEvents();

                const appWin = getAppWindow();
                if (appWin?.onCloseRequested) {
                    appWin.onCloseRequested(async (event) => {
                        event.preventDefault();
                        if (settingsDirty) {
                            const shouldClose = await showConfirmDialog(
                                'You have unsaved changes. Are you sure you want to close without saving?',
                                { title: 'Unsaved Changes', okText: 'Close', okClass: 'btn-warning' }
                            );
                            if (!shouldClose) return;
                        }
                        hideOptionsWindow();
                    });
                }
            } catch (err) {
                console.error('Options init failed', err);
            } finally {
                revealApp();
            }
        });

        async function hideOptionsWindow() {
            resetStatusMessages();
            // Clear dirty flag since we're closing (user already confirmed if needed)
            settingsDirty = false;
            try {
                const appWin = getAppWindow();
                if (appWin?.hide) {
                    await appWin.hide();
                    return;
                }
                if (appWin?.close) {
                    await appWin.close();
                    return;
                }
            } catch (e) {
                console.warn('hideOptionsWindow failed', e);
            }
            window.close();
        }
    </script>
</body>

</html>